<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Scrabble Game v1.6.3</title>
  <!-- Version: 1.6.3 | Date: December 5, 2025 | MAJOR: Multiplayer fixes + rejoin system -->
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="Play Scrabble online with AI opponents or friends. Features 4 beautiful themes, multiplayer modes, and full SOWPODS dictionary.">
  <meta name="theme-color" content="#d4af37">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Scrabble">
  
  <style>
    :root {
      --board-bg: #e8d5b7;
      --tile-bg: #f4e8d0;
      --tile-shadow: rgba(139, 90, 43, 0.15);
      --text-dark: #3d2817;
      --accent: #8b5a2b;
      --star: #d4af37;
      --dls: #b8d4e8;
      --tls: #4a7ba7;
      --dws: #e8b8b8;
      --tws: #c85a54;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Georgia, 'Times New Roman', serif;
      background: linear-gradient(135deg, #f5ebe0 0%, #e3d5ca 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: var(--text-dark);
    }

    h1 {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 3.5rem;
      color: var(--accent);
      margin-bottom: 10px;
      letter-spacing: 2px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }

    .game-container {
      max-width: 1400px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 30px;
    }

    .scores {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      margin-bottom: 10px;
    }

    .score-card {
      background: var(--tile-bg);
      padding: 20px 40px;
      border-radius: 12px;
      box-shadow: 0 4px 12px var(--tile-shadow);
      transition: all 0.3s ease;
      text-align: center;
      border: 3px solid transparent;
    }

    .score-card.active {
      border: 3px solid var(--accent);
      background: linear-gradient(135deg, var(--tile-bg) 0%, rgba(244, 232, 208, 0.95) 100%);
      animation: highlightPlayer 1s ease-in-out;
    }

    .score-card.inactive {
      opacity: 0.6;
    }

    .score-label {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .score-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--accent);
      transition: all 0.3s ease;
    }

    .score-card.active .score-value {
      animation: letterPulse 1.5s ease-in-out infinite;
    }

    .board-container {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(15, 40px);
      grid-template-rows: repeat(15, 40px);
      gap: 2px;
      background: var(--accent);
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }

    .cell {
      width: 40px;
      height: 40px;
      background: var(--board-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      border-radius: 2px;
      color: rgba(0, 0, 0, 0.3); /* Default text color for empty cells */
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .cell:hover:not(.occupied) {
      background: #f0e0c8;
      transform: scale(1.05);
    }

    .cell.occupied {
      cursor: default;
    }

    .cell.preview {
      background: #d4e8d4;
    }

    .cell.star {
      background: var(--star);
      color: white;
    }

    .cell.dls {
      background: var(--dls);
      color: var(--text-dark);
    }

    .cell.tls {
      background: var(--tls);
      color: white;
    }

    .cell.dws {
      background: var(--dws);
      color: var(--text-dark);
    }

    .cell.tws {
      background: var(--tws);
      color: white;
    }

    .cell.opponent-preview {
      background: rgba(220, 53, 69, 0.15);
      border: 2px dashed rgba(220, 53, 69, 0.5);
      animation: pulse 1.5s ease-in-out infinite;
    }

    .tile {
      width: 38px;
      height: 38px;
      background: var(--tile-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1.4rem;
      font-weight: 700;
      border-radius: 4px;
      box-shadow: 0 2px 6px var(--tile-shadow);
      position: relative;
      cursor: move;
      user-select: none;
      color: #2c3e50; /* Default dark text for tiles */
    }

    .tile .points {
      position: absolute;
      bottom: 2px;
      right: 3px;
      font-size: 0.65rem;
      font-family: Georgia, 'Times New Roman', serif;
      opacity: 0.7;
      color: inherit; /* Inherit from tile */
    }

    .rack-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .rack {
      background: var(--accent);
      padding: 12px;
      border-radius: 8px;
      display: flex;
      gap: 8px;
      justify-content: center;
      box-shadow: 0 4px 12px var(--tile-shadow);
      min-height: 60px;
    }

    .rack-tile {
      width: 45px;
      height: 45px;
      background: var(--tile-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1.6rem;
      font-weight: 700;
      border-radius: 4px;
      box-shadow: 0 2px 8px var(--tile-shadow);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      user-select: none;
    }

    .rack-tile:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 12px rgba(139, 90, 43, 0.3);
    }

    .rack-tile.selected {
      background: #ffe4b5;
      transform: translateY(-8px);
    }

    .rack-tile .points {
      position: absolute;
      bottom: 3px;
      right: 4px;
      font-size: 0.7rem;
      font-family: Georgia, 'Times New Roman', serif;
      opacity: 0.7;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1rem;
      font-weight: 600;
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 12px var(--tile-shadow);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(139, 90, 43, 0.25);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-secondary {
      background: var(--tile-bg);
      color: var(--text-dark);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .numpad-btn {
      padding: 20px;
      font-size: 1.8rem;
      font-weight: bold;
      background: rgba(244, 232, 208, 0.2);
      color: #f4e8d0;
      border: 3px solid #f4e8d0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Georgia, serif;
      min-width: 80px;
      min-height: 80px;
    }

    .numpad-btn:hover {
      background: rgba(244, 232, 208, 0.4);
      transform: scale(1.05);
    }

    .numpad-btn:active {
      transform: scale(0.95);
      background: rgba(244, 232, 208, 0.6);
    }

    /* Bot Card Styles */
    .bot-card {
      background: white;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 200px;
      justify-content: center;
    }

    .bot-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      border-color: var(--accent);
    }

    .bot-card:active {
      transform: translateY(-2px);
    }

    .bot-icon {
      font-size: 3rem;
      margin-bottom: 5px;
    }

    .bot-name {
      font-size: 1.3rem;
      font-weight: 700;
      color: #2c3e50;
    }

    .bot-stars {
      font-size: 1rem;
      color: #f39c12;
      letter-spacing: 2px;
    }

    .bot-rating {
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent);
    }

    .bot-strategy {
      font-size: 0.9rem;
      color: #7f8c8d;
      line-height: 1.4;
      margin-top: 5px;
    }

    /* Theme-specific bot card styles */
    body.theme-dark-modern .bot-card {
      background: rgba(26, 26, 26, 0.95);
      border-color: rgba(52, 152, 219, 0.3);
    }

    body.theme-dark-modern .bot-card:hover {
      border-color: #3498db;
      box-shadow: 0 8px 24px rgba(52, 152, 219, 0.4);
    }

    body.theme-dark-modern .bot-name {
      color: #ecf0f1;
    }

    body.theme-dark-modern .bot-strategy {
      color: rgba(236, 240, 241, 0.7);
    }

    body.theme-classic-wood .bot-card {
      background: rgba(210, 180, 140, 0.95);
      border-color: #8b7355;
    }

    body.theme-classic-wood .bot-card:hover {
      box-shadow: 0 8px 24px rgba(139, 115, 85, 0.4);
    }

    body.theme-classic-wood .bot-name {
      color: #3d2817;
    }

    body.theme-classic-wood .bot-strategy {
      color: rgba(61, 40, 23, 0.7);
    }

    body.theme-neon-gaming .bot-card {
      background: rgba(10, 14, 39, 0.9);
      border: 2px solid rgba(0, 245, 255, 0.3);
    }

    body.theme-neon-gaming .bot-card:hover {
      border-color: #00f5ff;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.4);
    }

    body.theme-neon-gaming .bot-name {
      color: white;
    }

    body.theme-neon-gaming .bot-strategy {
      color: rgba(255, 255, 255, 0.7);
    }


    @keyframes flashDigit {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .flash {
      animation: flashDigit 0.5s ease-in-out;
    }

    @keyframes flipCard {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(0deg); }
    }

    @keyframes highlightPlayer {
      0%, 100% { 
        transform: scale(1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
      50% { 
        transform: scale(1.05);
        box-shadow: 0 8px 24px rgba(139, 90, 43, 0.6), 0 0 30px rgba(244, 232, 208, 0.4);
      }
    }

    @keyframes pulse {
      0%, 100% { 
        transform: scale(1);
      }
      50% { 
        transform: scale(1.08);
      }
    }

    @keyframes letterPulse {
      0%, 100% { 
        transform: scale(1);
      }
      50% { 
        transform: scale(1.15);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes tileFromBag {
      0% {
        opacity: 0;
        transform: translateY(-100px) scale(0.5) rotateZ(-20deg);
      }
      60% {
        opacity: 1;
        transform: translateY(10px) scale(1.1) rotateZ(5deg);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1) rotateZ(0deg);
      }
    }

    @keyframes flipIn {
      0% {
        transform: rotateY(90deg);
        opacity: 0;
      }
      100% {
        transform: rotateY(0deg);
        opacity: 1;
      }
    }

    .tile-entering {
      animation: tileFromBag 0.6s ease-out;
    }

    .tile-flip {
      animation: flipIn 0.3s ease-out;
    }

    .score-card.active {
      border: 3px solid var(--accent);
      background: linear-gradient(135deg, var(--tile-bg) 0%, rgba(244, 232, 208, 0.95) 100%);
      animation: highlightPlayer 1s ease-in-out;
    }

    .score-card.inactive {
      opacity: 0.6;
    }

    .rack-tile {
      animation: slideIn 0.3s ease-out;
    }

    #turnTransition {
      animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes turnFlip {
      0% { 
        opacity: 1;
        transform: scale(1) rotateY(0deg);
      }
      50% { 
        opacity: 0.7;
        transform: scale(1.1) rotateY(180deg);
      }
      100% { 
        opacity: 1;
        transform: scale(1) rotateY(360deg);
      }
    }

    .turn-flip {
      animation: turnFlip 0.6s ease-in-out;
    }

    .message {
      text-align: center;
      padding: 15px;
      background: var(--tile-bg);
      border-radius: 8px;
      font-size: 1.1rem;
      box-shadow: 0 2px 8px var(--tile-shadow);
      animation: fadeIn 0.5s ease;
    }

    .info-panel {
      background: var(--tile-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--tile-shadow);
      max-width: 300px;
    }

    .info-title {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1.3rem;
      margin-bottom: 15px;
      color: var(--accent);
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(139, 90, 43, 0.1);
    }

    .info-item:last-child {
      border-bottom: none;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    @keyframes tilePlace {
      0% {
        transform: scale(0.8) rotate(-5deg);
      }
      60% {
        transform: scale(1.1) rotate(2deg);
      }
      100% {
        transform: scale(1) rotate(0deg);
      }
    }

    .tile-placed {
      animation: tilePlace 0.4s ease;
    }

    /* v1.3.2 Fix: Theme buttons clickable in settings panel */
    .theme-option-settings {
      position: relative !important;
      z-index: 10 !important;
      pointer-events: auto !important;
      cursor: pointer !important;
    }
    
    .theme-option-settings:hover {
      transform: translateX(3px) !important;
    }
    
    .theme-option-settings:active {
      transform: translateX(1px) !important;
    }

    /* v1.3.2 Fix: Sound toggle animation */
    #soundToggle:checked + span {
      background-color: #27ae60;
    }
    
    #soundToggle:checked + span + span {
      transform: translateX(24px);
    }

    /* v1.4.0: Admin Panel Styles */
    .admin-tab {
      flex: 1;
      padding: 15px;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #7f8c8d;
      transition: all 0.2s;
      font-family: Georgia, 'Times New Roman', serif;
    }
    
    .admin-tab:hover {
      background: rgba(231, 76, 60, 0.1);
    }
    
    .active-admin-tab {
      background: white !important;
      border-bottom: 3px solid #e74c3c !important;
      color: #e74c3c !important;
    }
    
    .player-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 15px;
      border-left: 4px solid #3498db;
      transition: all 0.2s ease;
    }
    
    .player-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .player-card.banned {
      border-left-color: #e74c3c;
      background: #ffebee;
    }
    
    .player-card.warned {
      border-left-color: #f39c12;
      background: #fff3cd;
    }
    
    .admin-action-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-right: 8px;
      margin-top: 5px;
      transition: all 0.2s;
      font-family: Georgia, 'Times New Roman', serif;
    }
    
    .admin-action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .btn-warn {
      background: #f39c12;
      color: white;
    }
    
    .btn-ban {
      background: #e74c3c;
      color: white;
    }
    
    .btn-unban {
      background: #27ae60;
      color: white;
    }
    
    .btn-make-admin {
      background: #9b59b6;
      color: white;
    }
    
    .btn-remove-admin {
      background: #34495e;
      color: white;
    }

    #adminPanelBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.5);
    }

  </style>
  
  <!-- Theme System Styles -->
  <link rel="stylesheet" href="data:text/css;base64,LyogVGhlbWUgU2VsZWN0b3IgVUkgKi8KLnRoZW1lLXNlbGVjdG9yIHsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDIwcHg7IHJpZ2h0OiAyMHB4OyB6LWluZGV4OiAxMDAwMDsgfQoudGhlbWUtdG9nZ2xlLWJ0biB7IGRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGdhcDogOHB4OyBwYWRkaW5nOiAxMnB4IDIwcHg7IGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICNmZmZmZmYgMCUsICNmOGY5ZmEgMTAwJSk7IGJvcmRlcjogMnB4IHNvbGlkICNkNGFmMzc7IGJvcmRlci1yYWRpdXM6IDI1cHg7IGN1cnNvcjogcG9pbnRlcjsgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMTUpOyB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOyBmb250LXdlaWdodDogNjAwOyBjb2xvcjogIzJjM2U1MDsgZm9udC1zaXplOiAwLjlyZW07IH0KLnRoZW1lLXRvZ2dsZS1idG46aG92ZXIgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTJweCk7IGJveC1zaGFkb3c6IDAgNnB4IDIwcHggcmdiYSgyMTIsIDE3NSwgNTUsIDAuMyk7IH0KLnRoZW1lLWljb24geyBmb250LXNpemU6IDEuMnJlbTsgfQoudGhlbWUtbGFiZWwgeyB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyBsZXR0ZXItc3BhY2luZzogMC41cHg7IH0KLnRoZW1lLW1lbnUgeyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNjBweDsgcmlnaHQ6IDA7IHdpZHRoOiAzMjBweDsgYmFja2dyb3VuZDogd2hpdGU7IGJvcmRlci1yYWRpdXM6IDEycHg7IGJveC1zaGFkb3c6IDAgMTBweCA0MHB4IHJnYmEoMCwgMCwgMCwgMC4yKTsgYm9yZGVyOiAycHggc29saWQgI2Q0YWYzNzsgb3ZlcmZsb3c6IGhpZGRlbjsgYW5pbWF0aW9uOiBtZW51U2xpZGVJbiAwLjNzIGVhc2Utb3V0OyB9CkBrZXlmcmFtZXMgbWVudVNsaWRlSW4geyBmcm9tIHsgb3BhY2l0eTogMDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KTsgfSB0byB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfSB9Ci50aGVtZS1tZW51LWhlYWRlciB7IHBhZGRpbmc6IDE2cHggMjBweDsgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgI2Q0YWYzNyAwJSwgI2Y0ZDAzZiAxMDAlKTsgY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogNzAwOyBmb250LXNpemU6IDEuMXJlbTsgdGV4dC1hbGlnbjogY2VudGVyOyBsZXR0ZXItc3BhY2luZzogMXB4OyB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyB9Ci50aGVtZS1vcHRpb24geyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBnYXA6IDEycHg7IHBhZGRpbmc6IDE2cHggMjBweDsgYmFja2dyb3VuZDogd2hpdGU7IGJvcmRlcjogbm9uZTsgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlOWVjZWY7IGN1cnNvcjogcG9pbnRlcjsgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTsgd2lkdGg6IDEwMCU7IHRleHQtYWxpZ246IGxlZnQ7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfQoudGhlbWUtb3B0aW9uOmxhc3QtY2hpbGQgeyBib3JkZXItYm90dG9tOiBub25lOyB9Ci50aGVtZS1vcHRpb246aG92ZXIgeyBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjZjhmOWZhIDAlLCAjZmZmZmZmIDEwMCUpOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNXB4KTsgfQoudGhlbWUtb3B0aW9uLmFjdGl2ZSB7IGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICNmZmY5ZTYgMCUsICNmZmZlZjcgMTAwJSk7IGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2Q0YWYzNzsgfQoudGhlbWUtb3B0aW9uLWljb24geyBmb250LXNpemU6IDEuOHJlbTsgZmxleC1zaHJpbms6IDA7IH0KLnRoZW1lLW9wdGlvbi1pbmZvIHsgZmxleDogMTsgfQoudGhlbWUtb3B0aW9uLW5hbWUgeyBmb250LXdlaWdodDogNzAwOyBjb2xvcjogIzJjM2U1MDsgZm9udC1zaXplOiAxcmVtOyBtYXJnaW4tYm90dG9tOiA0cHg7IH0KLnRoZW1lLW9wdGlvbi1kZXNjIHsgZm9udC1zaXplOiAwLjhyZW07IGNvbG9yOiAjN2Y4YzhkOyBsaW5lLWhlaWdodDogMS4zOyB9Ci50aGVtZS1jaGVjayB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDIwcHg7IGZvbnQtc2l6ZTogMS4ycmVtOyBjb2xvcjogIzI3YWU2MDsgZm9udC13ZWlnaHQ6IDcwMDsgfQoudGhlbWUtbG9hZGVyIHsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC44KTsgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEwcHgpOyB6LWluZGV4OiAyMDAwMDsgZGlzcGxheTogbm9uZTsgYWxpZ24taXRlbXM6IGNlbnRlcjsganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IH0KLmxvYWRlci1jb250ZW50IHsgdGV4dC1hbGlnbjogY2VudGVyOyBjb2xvcjogd2hpdGU7IH0KLmxvYWRlci1zcGlubmVyIHsgd2lkdGg6IDYwcHg7IGhlaWdodDogNjBweDsgYm9yZGVyOiA0cHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpOyBib3JkZXItdG9wLWNvbG9yOiAjZDRhZjM3OyBib3JkZXItcmFkaXVzOiA1MCU7IGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7IG1hcmdpbjogMCBhdXRvIDIwcHg7IH0KQGtleWZyYW1lcyBzcGluIHsgdG8geyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH0KLmxvYWRlci10ZXh0IHsgZm9udC1zaXplOiAxLjJyZW07IGZvbnQtd2VpZ2h0OiA2MDA7IGNvbG9yOiB3aGl0ZTsgfQpAbWVkaWEgKG1heC13aWR0aDogNzY4cHgpIHsgLnRoZW1lLXNlbGVjdG9yIHsgdG9wOiAxMHB4OyByaWdodDogMTBweDsgfSAudGhlbWUtdG9nZ2xlLWJ0biB7IHBhZGRpbmc6IDEwcHggMTZweDsgfSAudGhlbWUtbGFiZWwgeyBkaXNwbGF5OiBub25lOyB9IC50aGVtZS1tZW51IHsgd2lkdGg6IDI4MHB4OyB9IH0=">
  
  <!-- All 4 Themes Embedded -->
  <style id="all-themes">
    /* Light Luxury Theme - Default */
    .theme-light-luxury { --accent: #d4af37; }
    body.theme-light-luxury { background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%) !important; }
    .theme-light-luxury h1 { background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .theme-light-luxury .cell.tws { background: #ffebee !important; color: #c62828 !important; border-color: #c62828 !important; }
    .theme-light-luxury .cell.dws { background: #fff3e0 !important; color: #ef6c00 !important; border-color: #ef6c00 !important; }
    .theme-light-luxury .cell.tls { background: #e3f2fd !important; color: #1565c0 !important; border-color: #1565c0 !important; }
    .theme-light-luxury .cell.dls { background: #e8f5e9 !important; color: #2e7d32 !important; border-color: #2e7d32 !important; }
    .theme-light-luxury .cell.center { background: #fff9c4 !important; color: #f57f17 !important; border-color: #f57f17 !important; }
    .theme-light-luxury .tile { color: #2c3e50; } /* Dark text on light tiles */
    .theme-light-luxury .rack-tile { 
      background: var(--tile-bg) !important; 
      color: #2c3e50 !important; 
    }
    .theme-light-luxury .rack-tile .points { color: #2c3e50 !important; opacity: 0.7; }
    .theme-light-luxury .cell { color: rgba(100, 100, 100, 0.5); } /* Visible empty cell text */
    .theme-light-luxury .info-item { color: #2c3e50 !important; } /* Dark text for info panel */
    .theme-light-luxury .info-item span { color: #2c3e50 !important; } /* Dark text for all spans */
    .theme-light-luxury .info-title { color: #d4af37 !important; } /* Gold title */
    
    /* Dark Modern Theme */
    body.theme-dark-modern { 
      background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%) !important; 
      color: #ecf0f1 !important; 
    }
    .theme-dark-modern h1 { background: linear-gradient(135deg, #3498db 0%, #2ecc71 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 10px rgba(52, 152, 219, 0.5)); }
    .theme-dark-modern .game-container { background: rgba(26, 26, 26, 0.95); border: 2px solid rgba(52, 152, 219, 0.3); box-shadow: 0 0 40px rgba(52, 152, 219, 0.2); }
    .theme-dark-modern .board { background: #1a1a1a; border: 3px solid #3498db; box-shadow: 0 0 30px rgba(52, 152, 219, 0.3); }
    .theme-dark-modern .cell { background: #2c2c2c; border: 1px solid #3a3a3a; color: rgba(255, 255, 255, 0.3); }
    .theme-dark-modern .cell:hover:not(.occupied) { background: rgba(52, 152, 219, 0.2); border-color: #3498db; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
    .theme-dark-modern .cell.tws { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important; color: white !important; }
    .theme-dark-modern .cell.dws { background: linear-gradient(135deg, #e67e22 0%, #d35400 100%) !important; color: white !important; }
    .theme-dark-modern .cell.tls { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important; color: white !important; }
    .theme-dark-modern .cell.dls { background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%) !important; color: white !important; }
    .theme-dark-modern .cell.center { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%) !important; color: white !important; box-shadow: 0 0 20px rgba(243, 156, 18, 0.6); }
    .theme-dark-modern .message { background: rgba(52, 152, 219, 0.2); border: 2px solid rgba(52, 152, 219, 0.5); color: white; }
    .theme-dark-modern .info-panel { background: rgba(26, 26, 26, 0.95) !important; border: 2px solid rgba(52, 152, 219, 0.3); } /* Dark panel background */
    .theme-dark-modern .info-item { color: #ecf0f1 !important; } /* Light text for info panel */
    .theme-dark-modern .info-item span { color: #ecf0f1 !important; } /* Light text for all spans */
    .theme-dark-modern .info-title { color: #3498db !important; } /* Blue title */
    .theme-dark-modern .score-card { background: linear-gradient(135deg, rgba(52, 152, 219, 0.2) 0%, rgba(41, 128, 185, 0.2) 100%); border: 2px solid rgba(52, 152, 219, 0.4); }
    .theme-dark-modern .score-card.active { border-color: #3498db; box-shadow: 0 0 30px rgba(52, 152, 219, 0.6); }
    .theme-dark-modern .btn-primary { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); }
    .theme-dark-modern .rack { background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(52, 152, 219, 0.4); }
    .theme-dark-modern .tile { color: #2c3e50; } /* Dark text on light tiles */
    .theme-dark-modern .rack-tile { 
      background: var(--tile-bg) !important; 
      color: #2c3e50 !important; 
      border: 1px solid #3498db;
    }
    .theme-dark-modern .rack-tile .points { color: #2c3e50 !important; opacity: 0.7; }
    
    /* Classic Wood Theme */
    body.theme-classic-wood { 
      background: linear-gradient(135deg, #e8d5b7 0%, #d4b896 100%) !important; 
      color: #3d2817 !important; 
    }
    .theme-classic-wood h1 { font-family: Georgia, serif; background: linear-gradient(135deg, #8b4513 0%, #d2691e 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .theme-classic-wood .game-container { background: rgba(210, 180, 140, 0.95); border: 4px solid #8b7355; }
    .theme-classic-wood .board { background: #c19a6b; border: 4px solid #8b7355; }
    .theme-classic-wood .cell { background: linear-gradient(145deg, #c8a882 0%, #b8956a 100%); border: 1px solid #8b7355; color: rgba(61, 40, 23, 0.4); font-family: Georgia, serif; }
    .theme-classic-wood .cell.tws { background: #8b2500 !important; color: white !important; }
    .theme-classic-wood .cell.dws { background: #cd853f !important; color: white !important; }
    .theme-classic-wood .cell.tls { background: #4682b4 !important; color: white !important; }
    .theme-classic-wood .cell.dls { background: #87ceeb !important; color: white !important; }
    .theme-classic-wood .cell.center { background: #ffd700 !important; color: #8b7355 !important; }
    .theme-classic-wood .tile { background: linear-gradient(145deg, #fffef7 0%, #f4e8d0 100%); border: 2px solid #8b7355; font-family: Georgia, serif; color: #3d2817; }
    .theme-classic-wood .rack-tile { 
      background: linear-gradient(145deg, #fffef7 0%, #f4e8d0 100%) !important; 
      border: 2px solid #8b7355; 
      font-family: Georgia, serif; 
      color: #3d2817 !important; 
    }
    .theme-classic-wood .rack-tile .points { color: #3d2817 !important; opacity: 0.8; }
    .theme-classic-wood .rack { background: linear-gradient(145deg, #b8956a 0%, #a0826d 100%); border: 3px solid #8b7355; }
    .theme-classic-wood .score-card { background: linear-gradient(135deg, rgba(210, 180, 140, 0.95) 0%, rgba(184, 149, 106, 0.95) 100%); border: 3px solid #8b7355; }
    .theme-classic-wood .btn-primary { background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%); }
    .theme-classic-wood .message { background: rgba(244, 232, 208, 0.98); border: 2px solid #8b7355; color: #3d2817; font-family: Georgia, serif; }
    .theme-classic-wood .info-panel { background: rgba(210, 180, 140, 0.95) !important; } /* Wood panel background */
    .theme-classic-wood .info-item { color: #3d2817 !important; } /* Dark text for info panel */
    .theme-classic-wood .info-item span { color: #3d2817 !important; } /* Dark text for all spans */
    .theme-classic-wood .info-title { color: #8b4513 !important; } /* Brown title */
    
    /* Neon Gaming Theme */
    body.theme-neon-gaming { 
      background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%) !important; 
      color: white !important; 
      position: relative;
    }
    
    /* Neon border effect around entire page */
    body.theme-neon-gaming::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 4px solid #00f5ff;
      box-shadow: 
        inset 0 0 30px rgba(0, 245, 255, 0.3),
        0 0 30px rgba(0, 245, 255, 0.5);
      pointer-events: none;
      z-index: 9999;
      animation: neonBorderPulse 3s ease-in-out infinite;
    }
    
    @keyframes neonBorderPulse {
      0%, 100% { 
        box-shadow: 
          inset 0 0 30px rgba(0, 245, 255, 0.3),
          0 0 30px rgba(0, 245, 255, 0.5);
      }
      50% { 
        box-shadow: 
          inset 0 0 50px rgba(0, 245, 255, 0.5),
          0 0 50px rgba(0, 245, 255, 0.8);
      }
    }
    
    /* Animated starfield background */
    body.theme-neon-gaming::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        radial-gradient(2px 2px at 20px 30px, white, transparent),
        radial-gradient(2px 2px at 60px 70px, white, transparent),
        radial-gradient(1px 1px at 50px 50px, white, transparent),
        radial-gradient(1px 1px at 130px 80px, white, transparent),
        radial-gradient(2px 2px at 90px 10px, white, transparent);
      background-repeat: repeat;
      background-size: 200px 200px;
      opacity: 0.4;
      animation: twinkle 5s linear infinite;
      pointer-events: none;
      z-index: 1;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.2; }
    }
    
    .theme-neon-gaming h1 { 
      font-family: 'Courier New', monospace; 
      font-weight: 900; 
      background: linear-gradient(135deg, #00f5ff 0%, #ff006e 50%, #8338ec 100%); 
      -webkit-background-clip: text; 
      -webkit-text-fill-color: transparent; 
      filter: drop-shadow(0 0 20px #00f5ff);
      position: relative;
      z-index: 10;
    }
    .theme-neon-gaming .game-container { 
      background: rgba(10, 14, 39, 0.9); 
      border: 2px solid #00f5ff; 
      box-shadow: 0 0 30px #00f5ff;
      position: relative;
      z-index: 10;
    }
    .theme-neon-gaming .board { background: #050814; border: 3px solid #00f5ff; box-shadow: 0 0 40px rgba(0, 245, 255, 0.5); }
    .theme-neon-gaming .cell { background: rgba(10, 14, 39, 0.8); border: 1px solid rgba(0, 245, 255, 0.3); color: rgba(0, 245, 255, 0.4); font-family: 'Courier New', monospace; }
    .theme-neon-gaming .cell:hover:not(.occupied) { background: rgba(0, 245, 255, 0.1); border-color: #00f5ff; box-shadow: 0 0 15px rgba(0, 245, 255, 0.5); }
    .theme-neon-gaming .cell.tws { background: radial-gradient(circle, rgba(255, 0, 110, 0.3) 0%, rgba(139, 0, 76, 0.3) 100%) !important; border-color: #ff006e; color: white !important; box-shadow: 0 0 15px #ff006e; }
    .theme-neon-gaming .cell.dws { background: radial-gradient(circle, rgba(255, 190, 11, 0.3) 0%, rgba(179, 133, 8, 0.3) 100%) !important; border-color: #ffbe0b; color: white !important; box-shadow: 0 0 15px #ffbe0b; }
    .theme-neon-gaming .cell.tls { background: radial-gradient(circle, rgba(131, 56, 236, 0.3) 0%, rgba(91, 39, 165, 0.3) 100%) !important; border-color: #8338ec; color: white !important; box-shadow: 0 0 15px #8338ec; }
    .theme-neon-gaming .cell.dls { background: radial-gradient(circle, rgba(62, 255, 0, 0.3) 0%, rgba(43, 179, 0, 0.3) 100%) !important; border-color: #3eff00; color: white !important; box-shadow: 0 0 15px #3eff00; }
    .theme-neon-gaming .cell.center { background: radial-gradient(circle, rgba(0, 245, 255, 0.4) 0%, rgba(0, 172, 179, 0.4) 100%) !important; border-color: #00f5ff; color: white !important; box-shadow: 0 0 30px #00f5ff; animation: centerPulse 2s ease-in-out infinite; }
    @keyframes centerPulse { 0%, 100% { box-shadow: 0 0 30px #00f5ff; } 50% { box-shadow: 0 0 50px #00f5ff; } }
    .theme-neon-gaming .tile { background: linear-gradient(145deg, #1a1f3a 0%, #0f1228 100%); border: 2px solid #00f5ff; color: white !important; box-shadow: 0 0 15px rgba(0, 245, 255, 0.5); font-family: 'Courier New', monospace; font-weight: 900; }
    .theme-neon-gaming .tile .points { color: white !important; } /* White points number */
    .theme-neon-gaming .rack-tile { 
      background: linear-gradient(145deg, #1a1f3a 0%, #0f1228 100%) !important; 
      border: 2px solid #00f5ff; 
      color: white !important; 
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.5); 
      font-family: 'Courier New', monospace; 
      font-weight: 900; 
    }
    .theme-neon-gaming .rack-tile .points { color: white !important; opacity: 0.9; }
    .theme-neon-gaming .rack-tile:hover { border-color: #ff006e; box-shadow: 0 0 25px #ff006e; }
    .theme-neon-gaming .tile:hover { border-color: #ff006e; box-shadow: 0 0 25px #ff006e; }
    .theme-neon-gaming .rack { background: rgba(10, 14, 39, 0.9); border: 2px solid #8338ec; box-shadow: 0 0 20px rgba(131, 56, 236, 0.4); }
    .theme-neon-gaming .score-card { background: linear-gradient(135deg, rgba(10, 14, 39, 0.95) 0%, rgba(26, 31, 58, 0.95) 100%); border: 2px solid #00f5ff; box-shadow: 0 0 20px rgba(0, 245, 255, 0.4); }
    .theme-neon-gaming .score-card.active { border-color: #ff006e; box-shadow: 0 0 30px #ff006e; }
    .theme-neon-gaming .btn-primary { background: linear-gradient(135deg, #8338ec 0%, #ff006e 100%); border: 2px solid #ff006e; color: white; box-shadow: 0 0 20px rgba(255, 0, 110, 0.5); font-family: 'Courier New', monospace; font-weight: 700; }
    .theme-neon-gaming .message { background: rgba(10, 14, 39, 0.95); border: 2px solid #00f5ff; color: white; font-family: 'Courier New', monospace; box-shadow: 0 0 20px rgba(0, 245, 255, 0.4); }
    .theme-neon-gaming .info-panel { background: rgba(10, 14, 39, 0.95) !important; border: 2px solid #00f5ff; box-shadow: 0 0 20px rgba(0, 245, 255, 0.4); } /* Dark panel background */
    .theme-neon-gaming .info-item { color: white !important; font-family: 'Courier New', monospace; } /* White text for info panel */
    .theme-neon-gaming .info-item span { color: white !important; } /* White text for all spans */
    .theme-neon-gaming .info-title { color: #00f5ff !important; font-family: 'Courier New', monospace; } /* Cyan title */
    
    /* Fix theme selector for neon theme */
    .theme-neon-gaming .theme-selector { z-index: 10000; }
    
    /* ========================================
       MOBILE RESPONSIVE STYLES
       ======================================== */
    
    /* Tablet and smaller */
    @media (max-width: 1024px) {
      h1 {
        font-size: 2.5rem;
        margin-bottom: 15px;
      }
      
      .game-container {
        padding: 20px;
        gap: 15px;
      }
      
      .board {
        max-width: 600px;
      }
      
      .cell {
        font-size: 0.6rem;
      }
    }
    
    /* Mobile landscape and smaller tablets */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      h1 {
        font-size: 2rem;
        margin-bottom: 10px;
      }
      
      .game-container {
        padding: 15px;
        gap: 12px;
      }
      
      /* Smaller board for mobile */
      .board {
        max-width: 100%;
        padding: 4px;
        gap: 1px;
      }
      
      .cell {
        font-size: 0.5rem;
        border-width: 1px;
      }
      
      /* Smaller tiles */
      .tile {
        font-size: 1rem;
      }
      
      .tile .letter {
        font-size: 1.3rem;
      }
      
      .tile .points {
        font-size: 0.6rem;
        bottom: 2px;
        right: 4px;
      }
      
      /* Rack optimization */
      .rack-container {
        padding: 10px;
      }
      
      .rack {
        gap: 4px;
        padding: 10px;
        min-height: 60px;
      }
      
      /* Score cards stack vertically on mobile */
      .scores {
        flex-direction: column;
        gap: 10px;
      }
      
      .score-card {
        padding: 15px;
      }
      
      .score-card .score-value {
        font-size: 2rem;
      }
      
      /* Buttons */
      .controls {
        gap: 8px;
      }
      
      button {
        padding: 10px 18px;
        font-size: 0.9rem;
      }
      
      /* Message */
      .message {
        padding: 12px 18px;
        font-size: 1rem;
      }
      
      /* Info display */
      .info {
        flex-direction: column;
        gap: 8px;
        font-size: 0.85rem;
      }
      
      .info-item {
        padding: 6px 12px;
      }
      
      /* Mode selection buttons */
      #modeSelection button,
      #deviceSelection button {
        font-size: 1rem;
        padding: 18px 24px;
      }
      
      /* Theme selector mobile */
      .theme-selector {
        top: 10px;
        right: 10px;
      }
      
      .theme-toggle-btn {
        padding: 8px 14px;
        font-size: 0.85rem;
      }
      
      .theme-icon {
        font-size: 1rem;
      }
      
      .theme-label {
        display: none; /* Hide "Themes" text on mobile */
      }
      
      .theme-menu {
        width: 280px;
        right: -10px; /* Align with button */
      }
      
      .theme-option {
        padding: 12px 16px;
      }
      
      .theme-option-icon {
        font-size: 1.5rem;
      }
      
      .theme-option-name {
        font-size: 0.9rem;
      }
      
      .theme-option-desc {
        font-size: 0.75rem;
      }
    }
    
    /* Small mobile phones */
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }
      
      h1 {
        font-size: 1.5rem;
        margin-bottom: 8px;
      }
      
      .game-container {
        padding: 10px;
        gap: 10px;
      }
      
      /* Very compact board */
      .board {
        padding: 3px;
        gap: 1px;
      }
      
      .cell {
        font-size: 0.4rem;
        min-height: unset;
      }
      
      /* Even smaller tiles */
      .tile {
        font-size: 0.8rem;
        border-width: 1px;
      }
      
      .tile .letter {
        font-size: 1rem;
      }
      
      .tile .points {
        font-size: 0.5rem;
        bottom: 1px;
        right: 2px;
      }
      
      /* Rack */
      .rack {
        gap: 3px;
        padding: 8px;
        min-height: 50px;
      }
      
      /* Score cards */
      .score-card {
        padding: 12px;
      }
      
      .score-card .label {
        font-size: 0.85rem;
      }
      
      .score-card .score-value {
        font-size: 1.8rem;
      }
      
      /* Buttons smaller */
      button {
        padding: 8px 14px;
        font-size: 0.85rem;
      }
      
      /* Message */
      .message {
        padding: 10px 14px;
        font-size: 0.9rem;
      }
      
      /* Mode selection */
      #modeSelection button,
      #deviceSelection button {
        font-size: 0.9rem;
        padding: 15px 20px;
      }
      
      /* Difficulty slider */
      #difficultySlider {
        height: 10px;
      }
      
      #difficultySlider::-webkit-slider-thumb {
        width: 24px;
        height: 24px;
      }
      
      /* Theme menu even smaller */
      .theme-menu {
        width: 260px;
      }
      
      .theme-option {
        padding: 10px 12px;
      }
      
      .theme-option-icon {
        font-size: 1.3rem;
      }
    }
    
    /* Touch optimization for all mobile devices */
    @media (hover: none) and (pointer: coarse) {
      /* Larger touch targets */
      .cell {
        min-height: 30px;
        min-width: 30px;
      }
      
      .tile {
        cursor: grab;
        touch-action: none;
        min-height: 40px;
        min-width: 40px;
      }
      
      .tile:active {
        cursor: grabbing;
      }
      
      button {
        min-height: 44px; /* iOS recommended touch target */
        cursor: pointer;
      }
      
      /* Prevent text selection during drag */
      .board,
      .rack,
      .tile {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      
      /* Better touch feedback */
      .tile:active {
        transform: scale(0.95);
      }
      
      .cell:active:not(.occupied) {
        background: rgba(255, 255, 255, 0.1);
      }
    }
    
    /* Landscape mode on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .scores {
        flex-direction: row;
      }
      
      .board {
        max-width: 400px;
      }
    }
    
    /* Very small screens - ultra compact */
    @media (max-width: 360px) {
      h1 {
        font-size: 1.3rem;
      }
      
      .board {
        padding: 2px;
      }
      
      .cell {
        font-size: 0.35rem;
      }
      
      .tile .letter {
        font-size: 0.9rem;
      }
      
      .rack {
        gap: 2px;
        padding: 6px;
      }
    }
  </style>
  
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <script>
    // Wait for page load to ensure Supabase SDK is loaded
    if (!window.supabaseInitialized) {
      window.supabaseInitialized = true;
      
      // Supabase configuration
      const SUPABASE_URL = 'https://bovfmxfdbrmbmybzvuss.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJvdmZteGZkYnJtYm15Ynp2dXNzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4MDM0MDgsImV4cCI6MjA4MDM3OTQwOH0.558ePBHGLj5Igow2qy5PhB8TTN88snZ_dsv_KYhJAMI';
      
      // Create Supabase client (the CDN exposes 'supabase' globally with createClient method)
      const { createClient } = supabase;
      window.supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      
      console.log('âœ… Supabase initialized:', window.supabase);
    }
  </script>
  
</head>
<body class="theme-light-luxury">
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
  
  <!-- Authentication Screens -->
  <div id="authContainer" class="game-container" style="display: flex; max-width: 450px; margin: 50px auto;">
    <div style="text-align: center; padding: 40px; width: 100%;">
      <h2 style="color: var(--accent); margin-bottom: 30px;">ðŸŽ® Scrabble Game</h2>
      
      <!-- Google Sign-In Screen -->
      <div id="loginScreen">
        <p style="color: #7f8c8d; margin-bottom: 30px; font-size: 15px;">
          Sign in to save your progress, track stats, and play online!
        </p>
        
        <button onclick="signInWithGoogle()" style="
          width: 100%;
          padding: 18px 24px;
          font-size: 16px;
          font-weight: 600;
          border: 2px solid #4285f4;
          border-radius: 12px;
          background: white;
          color: #3c4043;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 12px;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          margin-bottom: 20px;
        " onmouseover="this.style.background='#f8f9fa'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'" onmouseout="this.style.background='white'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'">
          <svg width="20" height="20" viewBox="0 0 24 24">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Sign in with Google
        </button>
        
        <div style="text-align: center; margin: 25px 0; padding-top: 20px; border-top: 1px solid #ddd;">
          <button onclick="playAnonymously()" class="btn-secondary" style="width: 100%; padding: 15px; font-size: 16px;">
            ðŸ‘» Play as Guest
          </button>
          <p style="font-size: 12px; color: #7f8c8d; margin-top: 10px;">No stats tracking â€¢ No online play â€¢ Local only</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Ban Screen (shown when user is banned) -->
  <div id="banScreen" style="display: none;"></div>
  
  <!-- Profile Button (shown when logged in) -->
  <!-- User Menu Button (Hamburger) -->
  <button id="userMenuBtn" onclick="toggleUserPanel()" style="
    position: fixed;
    top: 20px;
    left: 20px;
    background: white;
    border: 2px solid var(--accent);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    cursor: pointer;
    z-index: 10001;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
    align-items: center;
    justify-content: center;
    font-size: 24px;
  ">
    â˜°
  </button>

  <!-- User Side Panel (Slides from Left) -->
  <div id="userSidePanel" style="
    position: fixed;
    top: 0;
    left: -350px;
    width: 350px;
    height: 100vh;
    background: white;
    box-shadow: 4px 0 20px rgba(0,0,0,0.2);
    z-index: 10002;
    transition: left 0.3s ease;
    overflow-y: auto;
  ">
    <!-- Header with User Info -->
    <div style="
      padding: 30px 20px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark, #2980b9) 100%);
      color: white;
    ">
      <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
        <div style="flex: 1;">
          <div style="
            width: 70px;
            height: 70px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 35px;
            margin-bottom: 15px;
            border: 3px solid rgba(255,255,255,0.5);
          ">
            ðŸ‘¤
          </div>
          <div id="panelUsername" style="font-size: 20px; font-weight: 600; margin-bottom: 5px;">Username</div>
          <div id="panelEmail" style="font-size: 13px; opacity: 0.9;"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e5ede1e9ecc0e5f8e1edf0ece5aee3efed">[email&#160;protected]</a></div>
        </div>
        <button onclick="toggleUserPanel()" style="
          background: rgba(255,255,255,0.2);
          border: none;
          color: white;
          width: 35px;
          height: 35px;
          border-radius: 50%;
          cursor: pointer;
          font-size: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
        ">Ã—</button>
      </div>
      
      <!-- Quick Stats -->
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
        <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; text-align: center;">
          <div id="panelGamesPlayed" style="font-size: 24px; font-weight: 600;">0</div>
          <div style="font-size: 11px; opacity: 0.9;">Games</div>
        </div>
        <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; text-align: center;">
          <div id="panelWins" style="font-size: 24px; font-weight: 600;">0</div>
          <div style="font-size: 11px; opacity: 0.9;">Wins</div>
        </div>
      </div>
    </div>

    <!-- Menu Options -->
    <div style="padding: 20px;">
      
      <!-- Stats Section (Expandable) -->
      <div id="statsSection" style="margin-bottom: 10px;">
        <div onclick="toggleSection('statsContent')" style="
          padding: 15px;
          background: #f8f9fa;
          border-radius: 10px;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: space-between;
          transition: all 0.2s;
        " onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
          <div style="display: flex; align-items: center; gap: 15px;">
            <div style="
              width: 45px;
              height: 45px;
              background: var(--accent);
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 22px;
              color: white;
            ">ðŸ“Š</div>
            <div>
              <div style="font-weight: 600; font-size: 15px; color: #2c3e50;">Stats</div>
              <div style="font-size: 12px; color: #7f8c8d;">View your statistics</div>
            </div>
          </div>
          <span id="statsToggle" style="font-size: 18px; color: #7f8c8d;">â–¼</span>
        </div>
        
        <!-- Stats Content (Collapsible) -->
        <div id="statsContent" style="display: none; padding: 15px; background: white; border-radius: 0 0 10px 10px; margin-top: 2px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsGamesPlayed" style="font-size: 20px; font-weight: 600; color: var(--accent);">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">Games Played</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsWins" style="font-size: 20px; font-weight: 600; color: #27ae60;">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">Wins</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsLosses" style="font-size: 20px; font-weight: 600; color: #e74c3c;">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">Losses</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsHighScore" style="font-size: 20px; font-weight: 600; color: #f39c12;">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">High Score</div>
            </div>
          </div>
          <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
            <div id="menuStatsWinRate" style="font-size: 18px; font-weight: 600; color: var(--accent);">0%</div>
            <div style="font-size: 11px; color: #7f8c8d;">Win Rate</div>
          </div>
        </div>
      </div>

      <!-- Settings Section (Expandable) -->
      <div id="settingsSection" style="margin-bottom: 10px;">
        <div onclick="openSettingsPanel()" style="
          padding: 15px;
          background: #f8f9fa;
          border-radius: 10px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 15px;
          transition: all 0.2s;
        " onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
          <div style="
            width: 45px;
            height: 45px;
            background: #3498db;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: white;
          ">âš™ï¸</div>
          <div>
            <div style="font-weight: 600; font-size: 15px; color: #2c3e50;">Settings</div>
            <div style="font-size: 12px; color: #7f8c8d;">Themes & preferences</div>
          </div>
        </div>
      </div>

      <!-- Admin Panel Section (Hidden by default) -->
      <div id="adminPanelOption" onclick="showPanelAdmin()" style="
        padding: 15px;
        margin-bottom: 10px;
        background: #ffebee;
        border-radius: 10px;
        cursor: pointer;
        display: none;
        align-items: center;
        gap: 15px;
        transition: all 0.2s;
      " onmouseover="this.style.background='#ffcdd2'" onmouseout="this.style.background='#ffebee'">
        <div style="
          width: 45px;
          height: 45px;
          background: #e74c3c;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 22px;
          color: white;
        ">ðŸ‘®</div>
        <div>
          <div style="font-weight: 600; font-size: 15px; color: #e74c3c;">Admin Panel</div>
          <div style="font-size: 12px; color: #c0392b;">Manage players & settings</div>
        </div>
      </div>

      <div style="height: 1px; background: #e0e0e0; margin: 20px 0;"></div>

      <!-- Logout -->
      <div onclick="handleLogout()" style="
        padding: 15px;
        background: white;
        border: 2px solid #e74c3c;
        border-radius: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 15px;
        transition: all 0.2s;
      " onmouseover="this.style.background='#ffebee'" onmouseout="this.style.background='white'">
        <div style="
          width: 45px;
          height: 45px;
          background: #e74c3c;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 22px;
          color: white;
        ">ðŸšª</div>
        <div>
          <div style="font-weight: 600; font-size: 15px; color: #e74c3c;">Logout</div>
          <div style="font-size: 12px; color: #c0392b;">Sign out of your account</div>
        </div>
      </div>

    </div>
  </div>

  <!-- Overlay (darkens background when panel open) -->
  <div id="panelOverlay" onclick="toggleUserPanel()" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 10001;
    display: none;
    backdrop-filter: blur(2px);
  "></div>

  <!-- Admin Panel Button (shown for admins only) -->
  <button id="adminPanelBtn" onclick="openAdminPanel()" style="
    position: fixed;
    top: 20px;
    left: 20px;
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    z-index: 10001;
    display: none;
    box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
    transition: all 0.3s ease;
  ">
    ðŸ‘® Admin Panel
  </button>
  
  <!-- Anonymous Mode Toggle (shown when not logged in and on mode selection) -->
  <div id="anonymousToggle" style="
    position: fixed;
    top: 20px;
    left: 20px;
    background: #7f8c8d;
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 12px;
    z-index: 1000;
    display: none;
  ">
    ðŸ‘» Anonymous Mode
  </div>
  </button>
  
  <!-- Settings Panel -->
  <div id="settingsPanel" style="
    position: fixed;
    top: 0;
    right: -450px;
    width: 450px;
    height: 100vh;
    background: white;
    box-shadow: -4px 0 20px rgba(0,0,0,0.3);
    z-index: 2000;
    transition: right 0.3s ease;
    overflow-y: auto;
  ">
    <div style="padding: 0;">
      <!-- Header -->
      <div style="padding: 25px 30px; border-bottom: 2px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; background: var(--accent); color: white;">
        <h2 style="margin: 0; font-size: 24px;">âš™ï¸ Settings</h2>
        <button onclick="toggleSettingsPanel()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: white;">Ã—</button>
      </div>
      
      <!-- Tabs -->
      <div style="display: flex; border-bottom: 2px solid #f0f0f0; background: #f8f9fa;">
        <button id="profileTab" class="settings-tab active-tab" onclick="switchSettingsTab('profile')" style="
          flex: 1;
          padding: 15px;
          background: white;
          border: none;
          border-bottom: 3px solid var(--accent);
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          color: var(--accent);
        ">
          ðŸ‘¤ Stats
        </button>
        <button id="generalTab" class="settings-tab" onclick="switchSettingsTab('general')" style="
          flex: 1;
          padding: 15px;
          background: transparent;
          border: none;
          border-bottom: 3px solid transparent;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          color: #7f8c8d;
        ">
          âš™ï¸ Settings
        </button>
        <button id="adminTabBtn" class="settings-tab" onclick="switchSettingsTab('admin')" style="
          flex: 1;
          padding: 15px;
          background: transparent;
          border: none;
          border-bottom: 3px solid transparent;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          color: #7f8c8d;
          display: none;
        ">
          ðŸ‘® Admin
        </button>
      </div>
      
      <!-- Profile Tab Content -->
      <div id="profileTabContent" class="settings-tab-content" style="padding: 30px; display: block;">
        <div style="text-align: center; margin-bottom: 30px;">
          <div style="width: 80px; height: 80px; background: var(--accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 36px; color: white;">
            ðŸ‘¤
          </div>
          <h3 id="profileUsername" style="margin: 0 0 5px 0;">Username</h3>
          <p id="profileEmail" style="margin: 0; color: #7f8c8d; font-size: 14px;"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8eebe3efe7e2ceebf6efe3fee2eba0ede1e3">[email&#160;protected]</a></p>
        </div>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 15px 0; color: var(--accent);">ðŸ“Š Stats</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <div style="font-size: 24px; font-weight: bold; color: var(--accent);" id="statsGamesPlayed">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Games Played</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #27ae60;" id="statsWins">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Wins</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="statsLosses">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Losses</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #f39c12;" id="statsHighScore">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">High Score</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #3498db;" id="statsAvgScore">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Avg Score</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #9b59b6;" id="statsTotalPoints">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Total Points</div>
            </div>
          </div>
          <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <div style="font-size: 18px; font-weight: bold; color: var(--accent);" id="statsWinRate">0%</div>
              <div style="font-size: 12px; color: #7f8c8d;">Win Rate</div>
            </div>
            <div>
              <div style="font-size: 18px; font-weight: bold; color: #e67e22;" id="statsWinStreak">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Win Streak</div>
            </div>
          </div>
          <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
            <div style="font-size: 14px; color: #7f8c8d; margin-bottom: 5px;">ðŸ… Best Word</div>
            <div style="font-size: 20px; font-weight: bold; color: var(--accent);" id="statsBestWord">â€”</div>
          </div>
        </div>
        
        <button onclick="showLeaderboard()" class="btn-primary" style="width: 100%; margin-bottom: 10px;">
          ðŸ† View Leaderboard
        </button>
        
        <button onclick="handleLogout()" class="btn-secondary" style="width: 100%;">
          Logout
        </button>
      </div>
      
      <!-- General Tab Content (includes Themes) -->
      <div id="generalTabContent" class="settings-tab-content" style="padding: 30px; display: none;">
        <h3 style="margin: 0 0 20px 0; color: var(--accent);">âš™ï¸ Settings</h3>
        
        <!-- Themes Section -->
        <div style="margin-bottom: 30px;">
          <h4 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;">ðŸŽ¨ Themes</h4>
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <button class="theme-option-settings active" data-theme="light-luxury" onclick="switchThemeFromSettings('light-luxury')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid var(--accent);
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">âœ¨</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Light Luxury</div>
                <div style="font-size: 12px; color: #7f8c8d;">Clean white, gold accents</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: var(--accent);">âœ“</span>
            </button>
            
            <button class="theme-option-settings" data-theme="dark-modern" onclick="switchThemeFromSettings('dark-modern')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid #ddd;
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">ðŸŒ™</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Dark Modern</div>
                <div style="font-size: 12px; color: #7f8c8d;">Dark gradients, glowing tiles</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: #ddd;">âœ“</span>
            </button>
            
            <button class="theme-option-settings" data-theme="classic-wood" onclick="switchThemeFromSettings('classic-wood')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid #ddd;
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">ðŸŽ¨</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Classic Wood</div>
                <div style="font-size: 12px; color: #7f8c8d;">Wooden board, traditional</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: #ddd;">âœ“</span>
            </button>
            
            <button class="theme-option-settings" data-theme="neon-gaming" onclick="switchThemeFromSettings('neon-gaming')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid #ddd;
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">âš¡</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Neon Gaming</div>
                <div style="font-size: 12px; color: #7f8c8d;">Cyberpunk neon, vibrant</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: #ddd;">âœ“</span>
            </button>
          </div>
        </div>
        
        <!-- General Settings Section -->
        <h4 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;">ðŸ”§ Preferences</h4>
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <div style="font-weight: bold; margin-bottom: 5px;">ðŸ”Š Sound Effects</div>
              <div style="font-size: 12px; color: #7f8c8d;">Play sounds during gameplay</div>
            </div>
            <label style="position: relative; display: inline-block; width: 50px; height: 26px; cursor: pointer; z-index: 10;">
              <input type="checkbox" id="soundToggle" checked onchange="toggleSound(this.checked)" style="opacity: 0; width: 0; height: 0; position: absolute;">
              <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--accent); transition: 0.3s; border-radius: 26px; pointer-events: all;"></span>
              <span style="position: absolute; content: ''; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%; pointer-events: none;"></span>
            </label>
          </div>
        </div>
        
        <div style="background: #fff3cd; padding: 15px; border-radius: 12px; border-left: 4px solid #ffc107;">
          <div style="font-size: 14px; color: #856404;">
            <strong>ðŸ’¡ More settings coming soon!</strong><br>
            <span style="font-size: 12px;">Animations, notifications, and more...</span>
          </div>
        </div>
      </div>
      
      <!-- Admin Tab Content -->
      <div id="adminTabContent" class="settings-tab-content" style="padding: 20px; display: none;">
        <h3 style="margin: 0 0 20px 0; color: #e74c3c;">ðŸ‘® Admin Panel</h3>
        
        <!-- Admin Sub-tabs -->
        <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
          <button id="adminSubTabPlayers" class="admin-subtab" onclick="switchAdminSubTab('players')" style="
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
          ">
            ðŸ‘¥ Players
          </button>
          <button id="adminSubTabBanned" class="admin-subtab" onclick="switchAdminSubTab('banned')" style="
            padding: 10px 20px;
            background: #f8f9fa;
            color: #7f8c8d;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
          ">
            ðŸš« Banned
          </button>
          <button id="adminSubTabWarnings" class="admin-subtab" onclick="switchAdminSubTab('warnings')" style="
            padding: 10px 20px;
            background: #f8f9fa;
            color: #7f8c8d;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
          ">
            âš ï¸ Warnings
          </button>
          <button id="adminSubTabAdmins" class="admin-subtab" onclick="switchAdminSubTab('admins')" style="
            padding: 10px 20px;
            background: #f8f9fa;
            color: #7f8c8d;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            display: none;
          ">
            ðŸ‘® Admins
          </button>
        </div>
        
        <!-- Players Sub-tab -->
        <div id="adminSubTabPlayersContent" class="admin-subtab-content">
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 15px 0; color: var(--accent);">ðŸ” Search Players</h4>
            <div style="display: flex; gap: 10px;">
              <input type="text" id="adminSearchInput" placeholder="Search by username or email..." style="
                flex: 1;
                padding: 12px;
                border: 2px solid #ddd;
                border-radius: 8px;
                font-size: 14px;
              " onkeypress="if(event.key==='Enter') searchPlayers()">
              <button onclick="searchPlayers()" class="btn-primary" style="padding: 12px 30px;">
                Search
              </button>
            </div>
          </div>
          
          <div id="adminSearchResults">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Search for players to manage
            </div>
          </div>
        </div>
        
        <!-- Banned Sub-tab -->
        <div id="adminSubTabBannedContent" class="admin-subtab-content" style="display: none;">
          <h4 style="margin: 0 0 20px 0; color: var(--accent);">ðŸš« Banned Players</h4>
          <div id="bannedPlayersList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading banned players...
            </div>
          </div>
        </div>
        
        <!-- Warnings Sub-tab -->
        <div id="adminSubTabWarningsContent" class="admin-subtab-content" style="display: none;">
          <h4 style="margin: 0 0 20px 0; color: var(--accent);">âš ï¸ Player Warnings</h4>
          <div id="warningsList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading warnings...
            </div>
          </div>
        </div>
        
        <!-- Admins Sub-tab -->
        <div id="adminSubTabAdminsContent" class="admin-subtab-content" style="display: none;">
          <h4 style="margin: 0 0 20px 0; color: var(--accent);">ðŸ‘® Admin Management</h4>
          <div id="adminsList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading admins...
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Admin Panel Modal -->
  <div id="adminPanel" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    backdrop-filter: blur(5px);
  ">
    <div style="
      background: white;
      border-radius: 12px;
      padding: 0;
      max-width: 800px;
      width: 90%;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    ">
      <!-- Header -->
      <div style="
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        color: white;
        padding: 20px 30px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h2 style="margin: 0; font-size: 24px;">ðŸ‘® Admin Panel</h2>
        <button onclick="closeAdminPanel()" style="
          background: none;
          border: none;
          color: white;
          font-size: 28px;
          cursor: pointer;
          padding: 0;
          line-height: 1;
        ">Ã—</button>
      </div>
      
      <!-- Tabs -->
      <div style="display: flex; border-bottom: 2px solid #f0f0f0; background: #f8f9fa;">
        <button id="tabPlayers" class="admin-tab active-admin-tab" onclick="switchAdminTab('players')">
          ðŸ‘¥ Players
        </button>
        <button id="tabBanned" class="admin-tab" onclick="switchAdminTab('banned')">
          ðŸš« Banned
        </button>
        <button id="tabWarnings" class="admin-tab" onclick="switchAdminTab('warnings')">
          âš ï¸ Warnings
        </button>
        <button id="tabAdmins" class="admin-tab" onclick="switchAdminTab('admins')" style="display: none;">
          ðŸ‘® Admins
        </button>
      </div>
      
      <!-- Content Area -->
      <div style="padding: 30px; overflow-y: auto; max-height: calc(85vh - 120px);">
        
        <!-- Players Tab -->
        <div id="adminTabPlayers" class="admin-tab-content">
          <div style="margin-bottom: 20px;">
            <h3 style="margin: 0 0 15px 0; color: var(--accent);">ðŸ” Search Players</h3>
            <div style="display: flex; gap: 10px;">
              <input type="text" id="adminSearchInput" placeholder="Search by username or email..." style="
                flex: 1;
                padding: 12px;
                border: 2px solid #ddd;
                border-radius: 8px;
                font-size: 14px;
              " onkeypress="if(event.key==='Enter') searchPlayers()">
              <button onclick="searchPlayers()" class="btn-primary" style="padding: 12px 30px;">
                Search
              </button>
            </div>
          </div>
          
          <div id="adminSearchResults">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Search for players to manage
            </div>
          </div>
        </div>
        
        <!-- Banned Tab -->
        <div id="adminTabBanned" class="admin-tab-content" style="display: none;">
          <h3 style="margin: 0 0 20px 0; color: var(--accent);">ðŸš« Banned Players</h3>
          <div id="bannedPlayersList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading banned players...
            </div>
          </div>
        </div>
        
        <!-- Warnings Tab -->
        <div id="adminTabWarnings" class="admin-tab-content" style="display: none;">
          <h3 style="margin: 0 0 20px 0; color: var(--accent);">âš ï¸ Player Warnings</h3>
          <div id="warningsList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading warnings...
            </div>
          </div>
        </div>
        
        <!-- Admins Tab (Super Admin Only) -->
        <div id="adminTabAdmins" class="admin-tab-content" style="display: none;">
          <h3 style="margin: 0 0 20px 0; color: var(--accent);">ðŸ‘® Admin Management</h3>
          <div id="adminsList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading admins...
            </div>
          </div>
        </div>
        
      </div>
    </div>
  </div>

  <!-- Ban Dialog Modal -->
  <div id="banDialog" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10002;
  ">
    <div style="
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    ">
      <h3 style="margin: 0 0 20px 0; color: #e74c3c; font-size: 22px;">ðŸš« Ban Player</h3>
      
      <p style="margin-bottom: 20px; color: #34495e;">
        You are about to ban <strong id="banPlayerName"></strong>
      </p>
      
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
        Ban Duration:
      </label>
      <select id="banDuration" style="
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        margin-bottom: 20px;
        font-family: Georgia, 'Times New Roman', serif;
      ">
        <option value="3600000">1 Hour</option>
        <option value="86400000">1 Day</option>
        <option value="259200000">3 Days</option>
        <option value="604800000" selected>7 Days</option>
        <option value="2592000000">30 Days</option>
        <option value="permanent">Permanent</option>
      </select>
      
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
        Reason (required):
      </label>
      <textarea id="banReason" placeholder="Enter reason for ban..." style="
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        min-height: 100px;
        resize: vertical;
        margin-bottom: 20px;
        font-family: Georgia, 'Times New Roman', serif;
      "></textarea>
      
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button onclick="closeBanDialog()" style="
          padding: 12px 24px;
          background: #95a5a6;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 600;
          font-family: Georgia, 'Times New Roman', serif;
        ">
          Cancel
        </button>
        <button onclick="confirmBanFromDialog()" style="
          padding: 12px 24px;
          background: #e74c3c;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 600;
          font-family: Georgia, 'Times New Roman', serif;
        ">
          Ban Player
        </button>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="leaderboardModal" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 3000;
  ">
    <div style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: var(--accent); margin: 0;">ðŸ† Leaderboard</h2>
        <button onclick="closeLeaderboard()" style="background: none; border: none; font-size: 24px; cursor: pointer;">Ã—</button>
      </div>
      <div id="leaderboardContent">
        Loading...
      </div>
    </div>
  </div>
  
  <!-- Dictionary Loading Status -->
  <div id="dict-status" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #4CAF50;
    color: white;
    padding: 8px;
    text-align: center;
    z-index: 10000;
    font-size: 13px;
  ">
    ðŸ“š Loading SOWPODS dictionary (267K words)...
  </div>
  
  <h1>Scrabble</h1>
  
  <!-- Manual Test Button for Update Notification - DISABLED -->
  <!--
  <div style="position: fixed; bottom: 20px; left: 20px; z-index: 10000;">
    <button onclick="showUpdateNotification('1.0.1')" style="
      background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(155, 89, 182, 0.4);
      transition: all 0.2s;
    " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
      ðŸ§ª Test Update Notification
    </button>
  </div>
  -->
  
  <div class="game-container" id="modeSelection" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Choose Game Mode</div>
      <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
        <button class="btn-primary" onclick="showDifficulty()" style="padding: 20px 40px; font-size: 1.2rem;">
          Play vs AI
        </button>
        <button class="btn-primary" onclick="showDeviceSelection()" style="padding: 20px 40px; font-size: 1.2rem;">
          2 Players
        </button>
      </div>
    </div>
  </div>

  <!-- Device Selection Screen -->
  <div class="game-container" id="deviceSelection" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Choose Play Mode</div>
      <div style="display: flex; flex-direction: column; gap: 20px; max-width: 500px; margin: 0 auto;">
        
        <button class="btn-primary" onclick="showPlayerNames()" style="padding: 30px; font-size: 1.1rem; text-align: left;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸ“± One Device</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Pass and play on the same device</div>
        </button>
        
        <button class="btn-primary" onclick="showMultiplayerSetup()" style="padding: 30px; font-size: 1.1rem; text-align: left;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸ”— Two Devices (Online)</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Play with a friend on different devices</div>
        </button>
        <button class="btn-secondary" onclick="backToModeSelection()" style="margin-top: 20px;">
          Back
        </button>
      </div>
    </div>
  </div>

  <!-- Multiplayer Setup Screen -->
  <div class="game-container" id="multiplayerSetup" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Online Multiplayer</div>
      <div style="display: flex; flex-direction: column; gap: 20px; max-width: 500px; margin: 0 auto;">
        
        <!-- Name input -->
        <div>
          <label style="display: block; margin-bottom: 12px; font-weight: 600; text-align: left;">Your Name:</label>
          <input type="text" id="onlinePlayerName" placeholder="Enter your name" 
                 style="width: 100%; padding: 12px; font-size: 1rem; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;">
        </div>
        
        <button class="btn-primary" onclick="createOnlineGame()" style="padding: 30px; font-size: 1.1rem;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸŽ® Create Game</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Start a new game and share code with friend</div>
        </button>
        <button class="btn-primary" onclick="showJoinGame()" style="padding: 30px; font-size: 1.1rem;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸ”‘ Join Game</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Enter a game code to join friend's game</div>
        </button>
        <button class="btn-secondary" onclick="backToDeviceSelection()" style="margin-top: 20px;">
          Back
        </button>
      </div>
    </div>
  </div>

  <!-- Create Game Screen -->
  <div class="game-container" id="createGameScreen" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Creating Game...</div>
      <div style="max-width: 500px; margin: 0 auto;">
        <div id="connectionStatus" style="padding: 20px; background: rgba(139, 90, 43, 0.1); border-radius: 12px; margin-bottom: 20px;">
          <div style="font-size: 1.1rem; margin-bottom: 15px;">â³ Connecting to server...</div>
        </div>
        <div id="gameCodeDisplay" style="display: none;">
          <div style="font-size: 1.1rem; margin-bottom: 15px;">Share this code with your friend:</div>
          <div style="font-size: 3rem; font-weight: bold; color: var(--accent); padding: 30px; background: rgba(139, 90, 43, 0.1); border-radius: 12px; margin-bottom: 20px; letter-spacing: 8px;" id="gameCode"></div>
          <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 20px;">Waiting for opponent to join...</div>
        </div>
        <button class="btn-secondary" onclick="cancelOnlineGame()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Join Game Screen -->
  <div class="game-container" id="joinGameScreen" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Join Game</div>
      <div style="max-width: 500px; margin: 0 auto;">
        <label style="display: block; margin-bottom: 12px; font-weight: 600; text-align: left;">Enter Game Code:</label>
        <input type="text" id="joinGameCode" placeholder="XXXXXX" maxlength="6" 
               style="width: 100%; padding: 20px; font-size: 2rem; text-align: center; border: 2px solid var(--accent); border-radius: 12px; font-family: Georgia, serif; text-transform: uppercase; letter-spacing: 8px; margin-bottom: 20px;">
        <div id="joinStatus" style="min-height: 24px; color: #ff6b6b; margin-bottom: 20px;"></div>
        <div style="display: flex; gap: 15px;">
          <button class="btn-secondary" onclick="backToMultiplayerSetup()" style="flex: 1;">Back</button>
          <button class="btn-primary" onclick="joinOnlineGame()" style="flex: 1;">Join Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="game-container" id="difficultySelection" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Choose Your Opponent</div>
      <div style="max-width: 700px; margin: 0 auto;">
        
        <!-- Bot Selection Grid -->
        <div id="botGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px;">
          <!-- Bots will be inserted here by JavaScript -->
        </div>
        
        <button class="btn-secondary" onclick="backToModeSelection()" style="margin-top: 15px;">
          Back
        </button>
      </div>
    </div>
  </div>
  
  <style>
    /* Custom slider thumb */
    #difficultySlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: white;
      border: 3px solid var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    
    #difficultySlider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: white;
      border: 3px solid var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
  </style>

  <div class="game-container" id="playerNames" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Enter Player Names</div>
      <div style="display: flex; flex-direction: column; gap: 20px; max-width: 400px; margin: 0 auto;">
        <div>
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">Player 1 Name:</label>
          <input type="text" id="player1Name" placeholder="Player 1" 
                 style="width: 100%; padding: 12px; font-size: 1rem; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">Player 2 Name:</label>
          <input type="text" id="player2Name" placeholder="Player 2" 
                 style="width: 100%; padding: 12px; font-size: 1rem; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;">
        </div>
        
        <div style="display: flex; gap: 15px; margin-top: 20px;">
          <button class="btn-secondary" onclick="backToDeviceSelection()" style="flex: 1;">Back</button>
          <button class="btn-primary" onclick="startGameWithNames()" style="flex: 1;">Start Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="game-container" id="gameBoard" style="display: none;">
    <div class="scores">
      <div class="score-card active" id="playerScoreCard">
        <div class="score-label" id="player1Label">Player 1</div>
        <div class="score-value" id="playerScore">0</div>
      </div>
      <div class="score-card" id="aiScoreCard">
        <div class="score-label" id="player2Label">AI</div>
        <div class="score-value" id="aiScore">0</div>
      </div>
    </div>

    <!-- Turn transition overlay for 2-player mode -->
    <div id="turnTransition" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(139, 90, 43, 0.95); z-index: 1000; justify-content: center; align-items: center; flex-direction: column; gap: 30px;">
      <div style="font-size: 2.5rem; color: #f4e8d0; font-weight: bold; text-align: center;" id="transitionPlayerName"></div>
      <div style="font-size: 1.3rem; color: #e8d5b7; text-align: center; max-width: 500px; line-height: 1.6;">
        Pass the device to <span id="transitionNextPlayer" style="font-weight: bold;"></span>
      </div>
      <div style="font-size: 1rem; color: #e8d5b7; opacity: 0.9; text-align: center; max-width: 400px;">
        Your tiles will be hidden when the game starts. Click "Ready?" to begin your turn.
      </div>
      <button class="btn-primary" onclick="game.confirmTurnTransition()" style="padding: 20px 50px; font-size: 1.3rem;">
        Ready?
      </button>
    </div>

    <div class="message" id="message">Select tiles from your rack and click on the board to place them</div>
    
    <!-- Cheating penalty indicator - DISABLED
    <div id="cheatingWarning" style="display: none; text-align: center; padding: 15px; background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); border-radius: 8px; color: white; font-size: 1.1rem; font-weight: bold; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(201, 42, 42, 0.4); animation: pulse 1.5s ease-in-out infinite;">
      âš ï¸ CHEATING DETECTED! -10 Points Penalty âš ï¸
    </div>
    -->

    <div class="board-container">
      <div class="board" id="board"></div>
      <div class="info-panel">
        <div class="info-title">Game Info</div>
        <div class="info-item">
          <span>Tiles Remaining:</span>
          <span id="tilesRemaining">100</span>
        </div>
        <div class="info-item">
          <span>Your Turn:</span>
          <span id="turnIndicator">âœ“</span>
        </div>
        <div class="info-item">
          <span>Current Word Score:</span>
          <span id="currentScore">0</span>
        </div>
      </div>
    </div>

    <!-- Chat panel for online mode -->
    <div id="chatPanel" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 320px; background: var(--tile-bg); border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 100;">
      <div style="background: var(--accent); color: white; padding: 15px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
        <span style="font-weight: bold;">ðŸ’¬ Chat</span>
        <button onclick="toggleChat()" style="background: none; border: none; color: white; cursor: pointer; font-size: 1.2rem; padding: 0;">Ã—</button>
      </div>
      <div id="chatMessages" style="height: 250px; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; background: rgba(244, 232, 208, 0.3);">
        <!-- Messages appear here -->
      </div>
      <div style="padding: 10px; border-top: 2px solid var(--accent);">
        <div style="display: flex; gap: 8px;">
          <input type="text" id="chatInput" placeholder="Type a message..." 
                 style="flex: 1; padding: 10px; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;"
                 onkeypress="if(event.key === 'Enter') sendChatMessage()">
          <button onclick="sendChatMessage()" class="btn-primary" style="padding: 10px 20px;">Send</button>
        </div>
      </div>
    </div>

    <!-- Chat toggle button (only visible in online mode) -->
    <button id="chatToggle" onclick="toggleChat()" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 60px; height: 60px; border-radius: 50%; background: var(--accent); color: white; border: none; cursor: pointer; font-size: 1.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 99;">
      ðŸ’¬
    </button>

    <div class="rack-container">
      <!-- Tile Bag Icon -->
      <div id="tileBag" style="position: absolute; top: -60px; right: 20px; font-size: 3rem; opacity: 0.7; pointer-events: none;">
        ðŸŽ’
      </div>
      <div class="rack" id="rack"></div>
      <div class="controls">
        <button class="btn-primary" id="playBtn">Play Word</button>
        <button class="btn-secondary" id="shuffleBtn">Shuffle Rack</button>
        <button class="btn-secondary" id="recallBtn">Recall Tiles</button>
        <button class="btn-secondary" id="passBtn">Pass Turn</button>
        <button class="btn-secondary" id="hideTilesBtn" style="display: none;">ðŸ‘ï¸ Hide Tiles</button>
      </div>
    </div>
  </div>

  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
    // ========================================
    // AUTHENTICATION SYSTEM (v1.5.0 - Supabase)
    // ========================================
    let currentUser = null;
    let userStats = null;
    let isAnonymousMode = false;
    
    // ============================================
    // GOOGLE OAUTH AUTHENTICATION
    // ============================================
    
    async function signInWithGoogle() {
      try {
        console.log('ðŸ” Starting Google sign in...');
        
        // Hardcoded redirect URL for GitHub Pages
        const redirectUrl = 'https://thitikhacharoen.github.io/Scrabble/';
        console.log('ðŸ“ Redirect URL:', redirectUrl);
        
        const { data, error} = await window.supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: redirectUrl,
            queryParams: {
              access_type: 'offline',
              prompt: 'consent',
            }
          }
        });
        
        if (error) {
          console.error('âŒ Google sign in error:', error);
          alert('Failed to sign in with Google: ' + error.message);
          return;
        }
        
        console.log('âœ… Redirecting to Google...');
        // User will be redirected to Google, then back to our app
        // onAuthStateChange will handle the rest when they return
      } catch (error) {
        console.error('âŒ Sign in error:', error);
        alert('An error occurred during sign in');
      }
    }
    
    async function handleAuthChange(session) {
      currentUser = session.user;
      await loadUserData(); // Wait for user data to load
      
      // Check ban status
      const isAllowed = await checkBanStatus();
      if (!isAllowed) {
        return; // User is banned, ban screen is shown
      }
      
      // Show admin options if user is admin/owner (AFTER loadUserData completes)
      console.log('ðŸ” Admin Check:', {
        username: currentUser.username,
        role: currentUser.role,
        hasAdminRole: currentUser.role === 'admin' || currentUser.role === 'owner'
      });
      
      const adminPanelOption = document.getElementById('adminPanelOption');
      const adminTabBtn = document.getElementById('adminTabBtn');
      const adminSubTabAdmins = document.getElementById('adminSubTabAdmins');
      
      if (currentUser && (currentUser.role === 'admin' || currentUser.role === 'owner')) {
        // Show admin option in side panel menu
        if (adminPanelOption) adminPanelOption.style.display = 'flex';
        
        // Show admin tab in settings
        if (adminTabBtn) adminTabBtn.style.display = 'flex';
        
        // Show admins subtab only for owners
        if (currentUser.role === 'owner' && adminSubTabAdmins) {
          adminSubTabAdmins.style.display = 'block';
        }
        
        console.log('âœ… Admin access granted');
      } else {
        // Hide admin options for regular players
        if (adminPanelOption) adminPanelOption.style.display = 'none';
        if (adminTabBtn) adminTabBtn.style.display = 'none';
        console.log('âŒ Admin access denied - not an admin');
      }
      
      // Check for warnings
      if (currentUser && currentUser.status === 'warned' && currentUser.warn_reason) {
        alert(`âš ï¸ WARNING\n\nYou have received a warning:\n${currentUser.warn_reason}\n\nPlease follow the community guidelines to avoid further action.`);
      }
      
      showGameInterface();
    }
    
    function showAuthInterface() {
      document.getElementById('authContainer').style.display = 'flex';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('settingsBtn').style.display = 'none';
    }
    
    function showGameInterface() {
      document.getElementById('authContainer').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'flex';
      
      if (!isAnonymousMode) {
        // Show user menu button (hamburger icon)
        const userMenuBtn = document.getElementById('userMenuBtn');
        if (userMenuBtn) {
          userMenuBtn.style.display = 'flex';
        }
        
        updateProfileDisplay();
      } else {
        document.getElementById('anonymousToggle').style.display = 'block';
      }
    }
    
    function playAnonymously() {
      isAnonymousMode = true;
      currentUser = null;
      userStats = null;
      showGameInterface();
      
      // Hide online multiplayer option for anonymous users
      const multiplayerBtn = document.querySelector('button[onclick="showDeviceSelection()"]');
      if (multiplayerBtn) {
        multiplayerBtn.style.display = 'none';
      }
    }
    
    function showLogin() {
      document.getElementById('loginScreen').style.display = 'block';
      document.getElementById('signupScreen').style.display = 'none';
      document.getElementById('forgotPasswordScreen').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('signupError').style.display = 'none';
    }
    
    function showSignup() {
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('signupScreen').style.display = 'block';
      document.getElementById('forgotPasswordScreen').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('signupError').style.display = 'none';
    }
    
    function showForgotPassword() {
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('signupScreen').style.display = 'none';
      document.getElementById('forgotPasswordScreen').style.display = 'block';
      document.getElementById('resetMessage').style.display = 'none';
    }
    
    // v1.4.2: Toggle password visibility
    function togglePasswordVisibility(inputId) {
      const input = document.getElementById(inputId);
      const button = input.nextElementSibling;
      
      if (input.type === 'password') {
        input.type = 'text';
        button.textContent = 'ðŸ‘ï¸â€ðŸ—¨ï¸'; // Eye with speech bubble (hidden)
      } else {
        input.type = 'password';
        button.textContent = 'ðŸ‘ï¸'; // Regular eye (visible)
      }
    }
    
    async function handleLogin() {
      const email = document.getElementById('loginEmail').value.trim();
      const password = document.getElementById('loginPassword').value;
      const errorDiv = document.getElementById('loginError');
      
      if (!email || !password) {
        errorDiv.textContent = 'Please fill in all fields';
        errorDiv.style.display = 'block';
        return;
      }
      
      try {
        const { data, error } = await supabase.auth.signInWithPassword({
          email,
          password
        });
        
        if (error) {
          // Check if error is due to unconfirmed email
          if (error.message.includes('Email not confirmed')) {
            errorDiv.textContent = 'âš ï¸ Please check your email and click the confirmation link before logging in.';
            errorDiv.style.color = '#f39c12';
            errorDiv.style.display = 'block';
            return;
          }
          throw error;
        }
        
        // Check if user has database record
        const { data: userData, error: dbError } = await supabase
          .from('users')
          .select('username')
          .eq('id', data.user.id)
          .single();
        
        if (dbError || !userData) {
          // User confirmed email but no database record - create it now
          console.log('Creating database record for confirmed user...');
          
          const username = data.user.user_metadata?.username || 'Player' + Date.now();
          
          const { error: insertError } = await supabase
            .from('users')
            .insert({
              id: data.user.id,
              email: data.user.email,
              username: username,
              games_played: 0,
              wins: 0,
              losses: 0,
              rating: 1000
            });
          
          if (insertError) {
            console.error('Failed to create user record:', insertError);
          }
        }
        
        console.log('âœ… Login successful');
        // onAuthStateChange will handle the rest
      } catch (error) {
        console.error('Login error:', error);
        errorDiv.textContent = getSupabaseErrorMessage(error.message);
        errorDiv.style.display = 'block';
      }
    }
    
    async function handleSignup() {
      const username = document.getElementById('signupUsername').value.trim();
      const email = document.getElementById('signupEmail').value.trim();
      const password = document.getElementById('signupPassword').value;
      const errorDiv = document.getElementById('signupError');
      
      // Validation
      if (!username || !email || !password) {
        errorDiv.textContent = 'Please fill in all fields';
        errorDiv.style.color = '#e74c3c';
        errorDiv.style.display = 'block';
        return;
      }
      
      if (username.length < 3 || username.length > 20) {
        errorDiv.textContent = 'Username must be 3-20 characters';
        errorDiv.style.color = '#e74c3c';
        errorDiv.style.display = 'block';
        return;
      }
      
      if (/\s/.test(username)) {
        errorDiv.textContent = 'Username cannot contain spaces';
        errorDiv.style.color = '#e74c3c';
        errorDiv.style.display = 'block';
        return;
      }
      
      if (password.length < 6) {
        errorDiv.textContent = 'Password must be at least 6 characters';
        errorDiv.style.color = '#e74c3c';
        errorDiv.style.display = 'block';
        return;
      }
      
      try {
        // Check if username already exists
        const { data: existingUser } = await supabase
          .from('users')
          .select('username')
          .eq('username', username)
          .single();
        
        if (existingUser) {
          errorDiv.textContent = 'Username already taken';
          errorDiv.style.color = '#e74c3c';
          errorDiv.style.display = 'block';
          return;
        }
        
        // Create auth user with options to skip email confirmation
        const { data: authData, error: authError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            data: {
              username: username
            },
            emailRedirectTo: window.location.href
          }
        });
        
        if (authError) throw authError;
        
        console.log('âœ… Signup response:', authData);
        
        // Check if email confirmation is required
        const needsConfirmation = authData.user && !authData.session;
        
        if (needsConfirmation) {
          // Email confirmation required
          errorDiv.textContent = 'âš ï¸ Account created! Please check your email to confirm, then login.';
          errorDiv.style.color = '#f39c12';
          errorDiv.style.display = 'block';
          
          console.log('âš ï¸ Email confirmation required');
          
          // Clear form
          document.getElementById('signupUsername').value = '';
          document.getElementById('signupEmail').value = '';
          document.getElementById('signupPassword').value = '';
          
          // Don't create database record yet - wait for confirmation
          return;
        }
        
        // User is auto-confirmed (confirmation disabled) - create database record
        const { error: dbError } = await supabase
          .from('users')
          .insert({
            id: authData.user.id,
            email: email,
            username: username,
            games_played: 0,
            wins: 0,
            losses: 0,
            rating: 1000
          });
        
        if (dbError) {
          console.error('Database insert error:', dbError);
          throw dbError;
        }
        
        console.log('âœ… Account created and logged in, user ID:', authData.user.id);
        
        // Show success message
        errorDiv.textContent = 'âœ… Account created! Logging you in...';
        errorDiv.style.color = '#27ae60';
        errorDiv.style.display = 'block';
        
        // onAuthStateChange will automatically log them in
      } catch (error) {
        console.error('Signup error:', error);
        errorDiv.textContent = getSupabaseErrorMessage(error.message);
        errorDiv.style.color = '#e74c3c';
        errorDiv.style.display = 'block';
      }
    }
    
    async function handlePasswordReset() {
      const email = document.getElementById('resetEmail').value.trim();
      const messageDiv = document.getElementById('resetMessage');
      
      if (!email) {
        messageDiv.textContent = 'Please enter your email';
        messageDiv.style.color = '#e74c3c';
        messageDiv.style.display = 'block';
        return;
      }
      
      try {
        const { error } = await supabase.auth.resetPasswordForEmail(email, {
          redirectTo: window.location.href
        });
        
        if (error) throw error;
        
        messageDiv.textContent = 'Password reset link sent! Check your email.';
        messageDiv.style.color = '#27ae60';
        messageDiv.style.display = 'block';
      } catch (error) {
        console.error('Password reset error:', error);
        messageDiv.textContent = getSupabaseErrorMessage(error.message);
        messageDiv.style.color = '#e74c3c';
        messageDiv.style.display = 'block';
      }
    }
    
    async function handleLogout() {
      try {
        // Close user panel first
        const panel = document.getElementById('userSidePanel');
        const overlay = document.getElementById('panelOverlay');
        if (panel) panel.style.left = '-350px';
        if (overlay) overlay.style.display = 'none';
        
        // Sign out from Supabase
        await window.supabase.auth.signOut();
        
        console.log('âœ… Logged out');
        // onAuthStateChange will handle showing login screen
      } catch (error) {
        console.error('Logout error:', error);
      }
    }
    
    // v1.5.0: Supabase - No separate createUserDocument needed, done in handleSignup
    
    async function loadUserData() {
      try {
        // Load user data from Supabase
        const { data: userData, error } = await window.supabase
          .from('users')
          .select('*')
          .eq('id', currentUser.id)
          .single();
        
        if (error && error.code === 'PGRST116') {
          // User doesn't exist in database - create record (first-time Google OAuth user)
          console.log('ðŸ†• Creating database record for new Google user...');
          
          // Generate username from email or name
          let username = 'Player' + Date.now();
          if (currentUser.user_metadata?.full_name) {
            username = currentUser.user_metadata.full_name.replace(/\s+/g, '');
          } else if (currentUser.email) {
            username = currentUser.email.split('@')[0];
          }
          
          // Create database record
          const { data: newUser, error: insertError } = await window.supabase
            .from('users')
            .insert({
              id: currentUser.id,
              email: currentUser.email,
              username: username,
              games_played: 0,
              wins: 0,
              losses: 0,
              rating: 1000,
              highest_score: 0,
              total_points: 0
            })
            .select()
            .single();
          
          if (insertError) {
            console.error('âŒ Failed to create user record:', insertError);
            return;
          }
          
          console.log('âœ… Database record created');
          
          // Use the newly created record
          currentUser.username = newUser.username;
          currentUser.role = newUser.role || 'player';
          currentUser.status = newUser.status || 'active';
          currentUser.games_played = 0;
          currentUser.wins = 0;
          currentUser.losses = 0;
          currentUser.rating = 1000;
          currentUser.highest_score = 0;
          currentUser.total_points = 0;
          
          userStats = {
            username: newUser.username,
            stats: {
              gamesPlayed: 0,
              wins: 0,
              losses: 0,
              highestScore: 0,
              totalPoints: 0
            }
          };
          
          return;
        } else if (error) {
          console.error('Error loading user data:', error);
          return;
        }
        
        if (userData) {
          // Merge database data into currentUser
          currentUser.username = userData.username;
          currentUser.role = userData.role || 'player';
          currentUser.status = userData.status || 'active';
          currentUser.games_played = userData.games_played || 0;
          currentUser.wins = userData.wins || 0;
          currentUser.losses = userData.losses || 0;
          currentUser.rating = userData.rating || 1000;
          currentUser.highest_score = userData.highest_score || 0;
          currentUser.total_points = userData.total_points || 0;
          
          // Ban info
          currentUser.ban_reason = userData.ban_reason;
          currentUser.ban_expires_at = userData.ban_expires_at;
          currentUser.ban_permanent = userData.ban_permanent;
          currentUser.banned_at = userData.banned_at;
          
          // Warn info
          currentUser.warn_reason = userData.warn_reason;
          currentUser.warned_at = userData.warned_at;
          
          // Set userStats for compatibility
          userStats = {
            username: userData.username,
            stats: {
              gamesPlayed: userData.games_played || 0,
              wins: userData.wins || 0,
              losses: userData.losses || 0,
              highestScore: userData.highest_score || 0,
              totalPoints: userData.total_points || 0
            }
          };
          
          console.log('ðŸ‘¤ User loaded:', {
            username: currentUser.username,
            role: currentUser.role,
            status: currentUser.status
          });
        }
      } catch (error) {
        console.error('Error loading user data:', error);
      }
    }
    
    function updateProfileDisplay() {
      if (!currentUser || !userStats) return;
      
      document.getElementById('profileUsername').textContent = currentUser.username || 'Player';
      document.getElementById('profileEmail').textContent = currentUser.email;
      
      const stats = userStats.stats;
      document.getElementById('statsGamesPlayed').textContent = stats.gamesPlayed || 0;
      document.getElementById('statsWins').textContent = stats.wins || 0;
      document.getElementById('statsLosses').textContent = stats.losses || 0;
      document.getElementById('statsHighScore').textContent = stats.highestScore || 0;
      
      // Average score
      const avgScore = stats.gamesPlayed > 0 ? Math.round((stats.totalPoints || 0) / stats.gamesPlayed) : 0;
      document.getElementById('statsAvgScore').textContent = avgScore;
      
      // Total points (format with commas)
      document.getElementById('statsTotalPoints').textContent = (stats.totalPoints || 0).toLocaleString();
      
      // Win rate
      const winRate = stats.gamesPlayed > 0 ? Math.round((stats.wins / stats.gamesPlayed) * 100) : 0;
      document.getElementById('statsWinRate').textContent = winRate + '%';
      
      // Win streak
      document.getElementById('statsWinStreak').textContent = stats.winStreak || 0;
      
      // Best word
      const bestWord = stats.bestWord && stats.bestWord.word ? 
        `${stats.bestWord.word} (${stats.bestWord.points} pts)` : 'â€”';
      document.getElementById('statsBestWord').textContent = bestWord;
    }
    
    // User Side Panel Functions
    function toggleUserPanel() {
      const panel = document.getElementById('userSidePanel');
      const overlay = document.getElementById('panelOverlay');
      const isOpen = panel.style.left === '0px';
      
      if (isOpen) {
        // Close panel
        panel.style.left = '-350px';
        overlay.style.display = 'none';
      } else {
        // Open panel
        panel.style.left = '0px';
        overlay.style.display = 'block';
        
        // Update user info in header
        if (currentUser) {
          document.getElementById('panelUsername').textContent = currentUser.username || 'Player';
          document.getElementById('panelEmail').textContent = currentUser.email || '';
          document.getElementById('panelGamesPlayed').textContent = currentUser.games_played || 0;
          document.getElementById('panelWins').textContent = currentUser.wins || 0;
        }
        
        // Update stats in expandable section
        if (userStats && userStats.stats) {
          document.getElementById('menuStatsGamesPlayed').textContent = userStats.stats.gamesPlayed || 0;
          document.getElementById('menuStatsWins').textContent = userStats.stats.wins || 0;
          document.getElementById('menuStatsLosses').textContent = userStats.stats.losses || 0;
          document.getElementById('menuStatsHighScore').textContent = userStats.stats.highestScore || 0;
          
          const gamesPlayed = userStats.stats.gamesPlayed || 0;
          const wins = userStats.stats.wins || 0;
          const winRate = gamesPlayed > 0 ? Math.round((wins / gamesPlayed) * 100) : 0;
          document.getElementById('menuStatsWinRate').textContent = winRate + '%';
        }
      }
    }
    
    // Toggle expandable sections in left panel
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      const toggleIcon = document.getElementById(sectionId.replace('Content', 'Toggle'));
      
      if (section.style.display === 'none' || section.style.display === '') {
        // Open section
        section.style.display = 'block';
        if (toggleIcon) toggleIcon.textContent = 'â–²';
      } else {
        // Close section
        section.style.display = 'none';
        if (toggleIcon) toggleIcon.textContent = 'â–¼';
      }
    }
    
    // Open settings panel from left menu
    function openSettingsPanel() {
      // Close left panel
      toggleUserPanel();
      
      // Open right settings panel to general tab (has themes)
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('general');
    }
    
    // Switch theme from menu (stays in menu, doesn't close)
    function switchThemeInMenu(themeName) {
      // Update body class
      document.body.className = 'theme-' + themeName;
      
      // Save preference
      localStorage.setItem('scrabble_theme', themeName);
      currentTheme = themeName;
      
      // Update active state in menu
      const menuButtons = document.querySelectorAll('.theme-option-menu');
      menuButtons.forEach(btn => {
        const isActive = btn.getAttribute('data-theme') === themeName;
        btn.style.border = isActive ? '2px solid var(--accent)' : '2px solid #ddd';
        
        const checkMark = btn.querySelector('.theme-check-menu');
        if (checkMark) {
          checkMark.style.color = isActive ? 'var(--accent)' : '#ddd';
        }
        
        if (isActive) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      console.log('âœ¨ Theme changed to:', themeName);
    }
    
    function showPanelAdmin() {
      // Close side panel
      toggleUserPanel();
      
      // Open settings panel to admin tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('admin');
    }
    
    function showAdvancedStats() {
      // Close dropdown
      document.getElementById('userDropdownMenu').style.display = 'none';
      
      // Open settings panel to profile tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('profile');
    }
    
    function showSettingsMenu() {
      // Close dropdown
      document.getElementById('userDropdownMenu').style.display = 'none';
      
      // Open settings panel to general tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('general');
    }
    
    function showAdminPanel() {
      // Close dropdown
      document.getElementById('userDropdownMenu').style.display = 'none';
      
      // Open settings panel to admin tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('admin');
    }
    
    function toggleSettingsPanel() {
      const panel = document.getElementById('settingsPanel');
      const settingsBtn = document.getElementById('settingsBtn');
      const isOpen = panel.style.right === '0px';
      
      panel.style.right = isOpen ? '-450px' : '0px';
      
      // v1.3.2 Fix: Hide settings button when panel is open, show when closed
      settingsBtn.style.display = isOpen ? 'block' : 'none';
      
      if (!isOpen) {
        updateProfileDisplay();
        switchSettingsTab('profile'); // Default to profile tab
      }
    }
    
    function switchSettingsTab(tabName) {
      // Hide all tab contents
      document.getElementById('profileTabContent').style.display = 'none';
      document.getElementById('generalTabContent').style.display = 'none';
      document.getElementById('adminTabContent').style.display = 'none';
      
      // Remove active class from all tabs
      const tabs = document.querySelectorAll('.settings-tab');
      tabs.forEach(tab => {
        tab.style.background = 'transparent';
        tab.style.borderBottom = '3px solid transparent';
        tab.style.color = '#7f8c8d';
      });
      
      // Show selected tab content and activate tab
      if (tabName === 'profile') {
        document.getElementById('profileTabContent').style.display = 'block';
        const tab = document.getElementById('profileTab');
        tab.style.background = 'white';
        tab.style.borderBottom = '3px solid var(--accent)';
        tab.style.color = 'var(--accent)';
      } else if (tabName === 'general') {
        document.getElementById('generalTabContent').style.display = 'block';
        const tab = document.getElementById('generalTab');
        tab.style.background = 'white';
        tab.style.borderBottom = '3px solid var(--accent)';
        tab.style.color = 'var(--accent)';
      } else if (tabName === 'admin') {
        document.getElementById('adminTabContent').style.display = 'block';
        const tab = document.getElementById('adminTabBtn');
        tab.style.background = 'white';
        tab.style.borderBottom = '3px solid var(--accent)';
        tab.style.color = 'var(--accent)';
        
        // Load admin data when tab is opened
        switchAdminSubTab('players');
      }
    }
    
    function switchAdminSubTab(subtabName) {
      // Hide all subtab contents
      const subtabContents = document.querySelectorAll('.admin-subtab-content');
      subtabContents.forEach(content => content.style.display = 'none');
      
      // Reset all subtab buttons
      const subtabs = document.querySelectorAll('.admin-subtab');
      subtabs.forEach(btn => {
        btn.style.background = '#f8f9fa';
        btn.style.color = '#7f8c8d';
      });
      
      // Show selected subtab
      if (subtabName === 'players') {
        document.getElementById('adminSubTabPlayersContent').style.display = 'block';
        document.getElementById('adminSubTabPlayers').style.background = 'var(--accent)';
        document.getElementById('adminSubTabPlayers').style.color = 'white';
      } else if (subtabName === 'banned') {
        document.getElementById('adminSubTabBannedContent').style.display = 'block';
        document.getElementById('adminSubTabBanned').style.background = 'var(--accent)';
        document.getElementById('adminSubTabBanned').style.color = 'white';
        loadBannedPlayers();
      } else if (subtabName === 'warnings') {
        document.getElementById('adminSubTabWarningsContent').style.display = 'block';
        document.getElementById('adminSubTabWarnings').style.background = 'var(--accent)';
        document.getElementById('adminSubTabWarnings').style.color = 'white';
        loadWarnings();
      } else if (subtabName === 'admins') {
        document.getElementById('adminSubTabAdminsContent').style.display = 'block';
        document.getElementById('adminSubTabAdmins').style.background = 'var(--accent)';
        document.getElementById('adminSubTabAdmins').style.color = 'white';
        loadAdmins();
      }
    }
    
    function switchThemeFromSettings(themeName) {
      // Call existing switchTheme function
      switchTheme(themeName);
      
      // Update active state in settings
      const options = document.querySelectorAll('.theme-option-settings');
      options.forEach(option => {
        const isActive = option.dataset.theme === themeName;
        option.style.border = isActive ? '2px solid var(--accent)' : '2px solid #ddd';
        const check = option.querySelector('.theme-check-settings');
        check.style.color = isActive ? 'var(--accent)' : '#ddd';
        
        if (isActive) {
          option.classList.add('active');
        } else {
          option.classList.remove('active');
        }
      });
    }
    
    function toggleSound(enabled) {
      if (typeof SFX !== 'undefined') {
        SFX.enabled = enabled;
      }
    }
    
    async function showLeaderboard() {
      document.getElementById('leaderboardModal').style.display = 'flex';
      const content = document.getElementById('leaderboardContent');
      content.innerHTML = '<div style="text-align: center; padding: 20px;">Loading...</div>';
      
      try {
        const { query, collection, orderBy, limit, getDocs } = window.firebaseDBFunctions;
        const leaderboardQuery = query(
          collection(window.firebaseDB, 'leaderboard'),
          orderBy('wins', 'desc'),
          limit(100)
        );
        
        const snapshot = await getDocs(leaderboardQuery);
        
        if (snapshot.empty) {
          content.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">No players yet. Be the first!</div>';
          return;
        }
        
        let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
        let rank = 1;
        
        snapshot.forEach((doc) => {
          const data = doc.data();
          const isCurrentUser = currentUser && doc.id === currentUser.uid;
          
          html += `
            <div style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: ${isCurrentUser ? '#fff3cd' : '#f8f9fa'};
              border-radius: 8px;
              border-left: 4px solid ${rank <= 3 ? '#f39c12' : '#dee2e6'};
            ">
              <div style="font-size: 20px; font-weight: bold; min-width: 40px; color: ${rank <= 3 ? '#f39c12' : '#7f8c8d'};">
                ${rank <= 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][rank - 1] : rank}
              </div>
              <div style="flex: 1;">
                <div style="font-weight: bold;">${data.username}${isCurrentUser ? ' (You)' : ''}</div>
                <div style="font-size: 12px; color: #7f8c8d;">
                  ${data.gamesPlayed} games â€¢ ${data.winRate}% win rate â€¢ High: ${data.highestScore}
                </div>
              </div>
              <div style="font-size: 24px; font-weight: bold; color: #27ae60;">
                ${data.wins}
              </div>
            </div>
          `;
          rank++;
        });
        
        html += '</div>';
        content.innerHTML = html;
      } catch (error) {
        console.error('Leaderboard error:', error);
        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #e74c3c;">Error loading leaderboard</div>';
      }
    }
    
    function closeLeaderboard() {
      document.getElementById('leaderboardModal').style.display = 'none';
    }
    
    async function saveGameResult(playerWon, playerScore, aiScore) {
      // Skip saving for anonymous users
      if (isAnonymousMode || !currentUser || !userStats) return;
      
      const { doc, updateDoc } = window.firebaseDBFunctions;
      const userRef = doc(window.firebaseDB, 'users', currentUser.uid);
      const leaderboardRef = doc(window.firebaseDB, 'leaderboard', currentUser.uid);
      
      // Calculate new win streak
      const newWinStreak = playerWon ? (userStats.stats.winStreak || 0) + 1 : 0;
      const longestWinStreak = Math.max(userStats.stats.longestWinStreak || 0, newWinStreak);
      
      // Update stats
      const newStats = {
        gamesPlayed: userStats.stats.gamesPlayed + 1,
        wins: userStats.stats.wins + (playerWon ? 1 : 0),
        losses: userStats.stats.losses + (playerWon ? 0 : 1),
        highestScore: Math.max(userStats.stats.highestScore, playerScore),
        lowestScore: userStats.stats.lowestScore === null ? playerScore : Math.min(userStats.stats.lowestScore, playerScore),
        totalPoints: userStats.stats.totalPoints + playerScore,
        averageScore: Math.round((userStats.stats.totalPoints + playerScore) / (userStats.stats.gamesPlayed + 1)),
        winStreak: newWinStreak,
        longestWinStreak: longestWinStreak
      };
      
      // Track bots beaten
      const botName = currentBotPersonality ? currentBotPersonality.name : 'AI';
      const botsBeaten = userStats.stats.botsBeaten || {};
      if (playerWon && currentBotPersonality) {
        botsBeaten[botName] = (botsBeaten[botName] || 0) + 1;
      }
      
      // Add to game history
      const gameRecord = {
        date: new Date().toISOString(),
        won: playerWon,
        playerScore: playerScore,
        opponentScore: aiScore,
        opponent: botName,
        botRating: currentBotPersonality ? currentBotPersonality.rating : null
      };
      
      const newHistory = [gameRecord, ...(userStats.gameHistory || [])].slice(0, 10);
      
      try {
        // Update user document
        await updateDoc(userRef, {
          'stats.gamesPlayed': newStats.gamesPlayed,
          'stats.wins': newStats.wins,
          'stats.losses': newStats.losses,
          'stats.highestScore': newStats.highestScore,
          'stats.lowestScore': newStats.lowestScore,
          'stats.totalPoints': newStats.totalPoints,
          'stats.averageScore': newStats.averageScore,
          'stats.winStreak': newStats.winStreak,
          'stats.longestWinStreak': newStats.longestWinStreak,
          'stats.botsBeaten': botsBeaten,
          gameHistory: newHistory
        });
        
        // Update leaderboard
        const winRate = Math.round((newStats.wins / newStats.gamesPlayed) * 100);
        await updateDoc(leaderboardRef, {
          wins: newStats.wins,
          gamesPlayed: newStats.gamesPlayed,
          highestScore: newStats.highestScore,
          winRate: winRate,
          averageScore: newStats.averageScore
        });
        
        // Reload user data
        await loadUserData();
      } catch (error) {
        console.error('Error saving game result:', error);
      }
    }
    
    function getErrorMessage(errorCode) {
      const messages = {
        'auth/email-already-in-use': 'Email already in use',
        'auth/invalid-email': 'Invalid email address',
        'auth/weak-password': 'Password is too weak',
        'auth/user-not-found': 'No account found with this email',
        'auth/wrong-password': 'Incorrect password',
        'auth/too-many-requests': 'Too many attempts. Try again later',
        'auth/network-request-failed': 'Network error. Check your connection'
      };
      return messages[errorCode] || 'An error occurred. Please try again';
    }
    
    // v1.5.0: Supabase error messages
    function getSupabaseErrorMessage(errorMessage) {
      if (errorMessage.includes('Invalid login credentials')) {
        return 'Invalid email or password';
      }
      if (errorMessage.includes('User already registered')) {
        return 'Email already in use';
      }
      if (errorMessage.includes('Password should be at least')) {
        return 'Password must be at least 6 characters';
      }
      if (errorMessage.includes('Unable to validate email address')) {
        return 'Invalid email address';
      }
      if (errorMessage.includes('Email rate limit exceeded')) {
        return 'Too many attempts. Try again later';
      }
      return errorMessage || 'An error occurred. Please try again';
    }
    
    // ========================================
    // END AUTHENTICATION SYSTEM
    // ========================================
    
    let gameMode = null; // 'ai' or 'human' or 'online'
    let aiDifficulty = 5; // 1-10 difficulty scale
    let player1Name = 'Player 1';
    let player2Name = 'Player 2';
    let player1Code = null;
    let player2Code = null;
    let usePasscodes = false;
    let game = null; // Global game instance
    
    // Online multiplayer variables
    let peer = null;
    let connection = null;
    let isHost = false;
    let myGameCode = null;
    let onlinePlayerRole = null; // 'player' or 'ai' (which side we control)
    let myOnlineName = 'Player';
    let opponentName = 'Opponent';
    let startingPlayer = null; // Will be randomized

    // Sound Effects System
    const SFX = {
      enabled: true,
      context: null,
      
      init() {
        if (!this.context) {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
        }
      },
      
      // Play tile click sound
      tileClick() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.value = 800;
        osc.type = 'sine';
        
        gain.gain.setValueAtTime(0.1, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.1);
      },
      
      // Play tile placement sound
      tilePlaced() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.value = 600;
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.15, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.15);
      },
      
      // Play word validation success
      wordSuccess() {
        if (!this.enabled) return;
        this.init();
        
        // Play chord of notes
        const frequencies = [523.25, 659.25, 783.99]; // C, E, G
        frequencies.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          
          osc.connect(gain);
          gain.connect(this.context.destination);
          
          osc.frequency.value = freq;
          osc.type = 'sine';
          
          const startTime = this.context.currentTime + (i * 0.05);
          gain.gain.setValueAtTime(0.1, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);
          
          osc.start(startTime);
          osc.stop(startTime + 0.3);
        });
      },
      
      // Play word validation failure
      wordFail() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.value = 200;
        osc.type = 'sawtooth';
        
        gain.gain.setValueAtTime(0.2, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.3);
      },
      
      // Play shuffle sound
      shuffle() {
        if (!this.enabled) return;
        this.init();
        
        for (let i = 0; i < 5; i++) {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          
          osc.connect(gain);
          gain.connect(this.context.destination);
          
          osc.frequency.value = 300 + Math.random() * 200;
          osc.type = 'square';
          
          const startTime = this.context.currentTime + (i * 0.05);
          gain.gain.setValueAtTime(0.05, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.08);
          
          osc.start(startTime);
          osc.stop(startTime + 0.08);
        }
      },
      
      // Play turn change sound
      turnChange() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.setValueAtTime(400, this.context.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, this.context.currentTime + 0.2);
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.15, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.3);
      },
      
      // Play game over sound
      gameOver() {
        if (!this.enabled) return;
        this.init();
        
        // Descending notes
        const frequencies = [659.25, 587.33, 523.25, 440.00]; // E, D, C, A
        frequencies.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          
          osc.connect(gain);
          gain.connect(this.context.destination);
          
          osc.frequency.value = freq;
          osc.type = 'sine';
          
          const startTime = this.context.currentTime + (i * 0.15);
          gain.gain.setValueAtTime(0.15, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);
          
          osc.start(startTime);
          osc.stop(startTime + 0.4);
        });
      }
    };

    // ========================================
    // BOT PERSONALITY SYSTEM
    // ========================================
    const BOT_PERSONALITIES = [
      {
        id: 1,
        name: 'Bot 1',
        rating: 800,
        stars: 1,
        strategy: 'Random word placement, no strategy',
        behavior: 'random',
        icon: 'ðŸ£'
      },
      {
        id: 2,
        name: 'Bot 2',
        rating: 1200,
        stars: 2,
        strategy: 'Always seeks double/triple word scores',
        behavior: 'bonus_hunter',
        icon: 'ðŸ’Ž'
      },
      {
        id: 3,
        name: 'Bot 3',
        rating: 1500,
        stars: 3,
        strategy: 'Prefers long words (5+ letters)',
        behavior: 'word_wizard',
        icon: 'ðŸ“š'
      },
      {
        id: 4,
        name: 'Bot 4',
        rating: 1600,
        stars: 3,
        strategy: 'Holds tiles for better opportunities',
        behavior: 'patient',
        icon: 'â³'
      },
      {
        id: 5,
        name: 'Bot 5',
        rating: 1800,
        stars: 4,
        strategy: 'Balanced approach, considers all factors',
        behavior: 'opportunist',
        icon: 'ðŸŽ¯'
      },
      {
        id: 6,
        name: 'Bot 6',
        rating: 2000,
        stars: 4,
        strategy: 'Blocks opponent, opens bonuses strategically',
        behavior: 'tactical',
        icon: 'ðŸ§ '
      },
      {
        id: 7,
        name: 'Bot 7',
        rating: 2200,
        stars: 5,
        strategy: '2-move lookahead, tournament level',
        behavior: 'master',
        icon: 'ðŸ†'
      }
    ];
    
    function showDifficulty() {
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'flex';
      
      // Generate bot selection grid
      const botGrid = document.getElementById('botGrid');
      botGrid.innerHTML = '';
      
      BOT_PERSONALITIES.forEach(bot => {
        const botCard = document.createElement('button');
        botCard.className = 'bot-card';
        botCard.onclick = () => startGameWithBot(bot.id);
        
        const stars = 'â­'.repeat(bot.stars);
        
        botCard.innerHTML = `
          <div class="bot-icon">${bot.icon}</div>
          <div class="bot-name">${bot.name}</div>
          <div class="bot-stars">${stars}</div>
          <div class="bot-rating">Rating: ${bot.rating}</div>
          <div class="bot-strategy">${bot.strategy}</div>
        `;
        
        botGrid.appendChild(botCard);
      });
    }
    
    function startGameWithBot(botId) {
      const bot = BOT_PERSONALITIES.find(b => b.id === botId);
      // Map bot ID to old difficulty level for now (will update AI logic later)
      const difficultyMapping = {
        1: 1,   // Random
        2: 3,   // Bonus hunter
        3: 5,   // Word wizard
        4: 6,   // Patient
        5: 7,   // Opportunist (lookahead)
        6: 9,   // Tactical (lookahead)
        7: 10   // Master (lookahead)
      };
      
      currentBotPersonality = bot;
      startGame('ai', difficultyMapping[botId]);
    }
    
    let currentBotPersonality = null;
    
    // Old function for compatibility
    function startGameWithSlider() {
      startGameWithBot(5); // Default to Bot 5
    }
    
    function showDeviceSelection() {
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'flex';
    }

    function showPlayerNames() {
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('playerNames').style.display = 'flex';
    }

    async function showMultiplayerSetup() {
      document.getElementById('deviceSelection').style.display = 'none';
      
      // Check for rejoinable game first
      if (currentUser) {
        const rejoinableGame = await checkForRejoinableGame();
        
        if (rejoinableGame) {
          // Show rejoin prompt
          const rejoinPrompt = confirm(
            `You have an active game in progress!\n\n` +
            `Do you want to rejoin your game?\n\n` +
            `(It will expire in 5 minutes if you don't rejoin)`
          );
          
          if (rejoinPrompt) {
            const success = await rejoinGame(rejoinableGame);
            if (success) {
              // Successfully rejoined, game will resume
              return;
            }
          }
        }
      }
      
      // No rejoinable game or user declined - show normal setup
      document.getElementById('multiplayerSetup').style.display = 'flex';
    }

    function showJoinGame() {
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'flex';
      document.getElementById('joinGameCode').value = '';
      document.getElementById('joinStatus').textContent = '';
    }

    function backToModeSelection() {
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'flex';
    }

    function backToDeviceSelection() {
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'flex';
    }

    function backToMultiplayerSetup() {
      document.getElementById('joinGameScreen').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'flex';
    }

    function cancelOnlineGame() {
      if (peer) {
        peer.destroy();
        peer = null;
      }
      if (connection) {
        connection.close();
        connection = null;
      }
      backToMultiplayerSetup();
    }

    // Helper function to capitalize names properly
    function capitalizeName(name) {
      return name
        .trim()
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    }

    function createOnlineGame() {
      const nameInput = document.getElementById('onlinePlayerName').value.trim();
      if (!nameInput) {
        alert('Please enter your name');
        return;
      }
      
      // Use username if logged in, otherwise use entered name
      myOnlineName = currentUser && currentUser.displayName ? currentUser.displayName : capitalizeName(nameInput);
      
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'flex';
      
      isHost = true;
      
      // Randomize starting player (50/50 chance)
      startingPlayer = Math.random() < 0.5 ? 'player' : 'ai';
      
      // Host will be one side based on random
      if (startingPlayer === 'player') {
        onlinePlayerRole = 'player'; // Host goes first
      } else {
        onlinePlayerRole = 'ai'; // Joiner goes first
      }
      
      // Generate random 6-digit code
      myGameCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      
      // Initialize PeerJS
      peer = new Peer(myGameCode);
      
      peer.on('open', async (id) => {
        document.getElementById('connectionStatus').innerHTML = '<div style="font-size: 1.1rem; color: #4CAF50;">âœ“ Connected! Ready to receive opponent.</div>';
        document.getElementById('gameCodeDisplay').style.display = 'block';
        document.getElementById('gameCode').textContent = myGameCode;
        
        // Create game record in database
        await createGameRecord();
      });
      
      peer.on('connection', async (conn) => {
        connection = conn;
        setupConnection();
        
        connection.on('open', () => {
          // Send game setup to joiner (who starts and names)
          connection.send({
            type: 'setup',
            hostName: myOnlineName,
            startingPlayer: startingPlayer,
            gameId: currentGameId
          });
        });
      });
      
      peer.on('error', (err) => {
        document.getElementById('connectionStatus').innerHTML = '<div style="color: #ff6b6b;">âŒ Connection error. Please try again.</div>';
        console.error('Peer error:', err);
      });
    }

    function joinOnlineGame() {
      const code = document.getElementById('joinGameCode').value.trim().toUpperCase();
      const nameInput = document.getElementById('onlinePlayerName').value.trim();
      
      if (!nameInput) {
        alert('Please enter your name');
        return;
      }
      
      if (code.length !== 6) {
        document.getElementById('joinStatus').textContent = 'Please enter a 6-character code';
        return;
      }
      
      // Use username if logged in, otherwise use entered name
      myOnlineName = currentUser && currentUser.displayName ? currentUser.displayName : capitalizeName(nameInput);
      
      document.getElementById('joinStatus').textContent = 'Connecting...';
      
      isHost = false;
      
      // Initialize PeerJS
      peer = new Peer();
      
      peer.on('open', (id) => {
        // Connect to host
        connection = peer.connect(code);
        
        connection.on('open', () => {
          document.getElementById('joinStatus').innerHTML = '<div style="color: #4CAF50;">âœ“ Connected!</div>';
          setupConnection();
          
          // Send our name to host
          connection.send({
            type: 'joinerName',
            name: myOnlineName,
            userId: currentUser ? currentUser.id : null,
            peerId: id
          });
        });
        
        connection.on('error', (err) => {
          document.getElementById('joinStatus').textContent = 'âŒ Failed to connect. Check the code.';
          console.error('Connection error:', err);
        });
      });
      
      peer.on('error', (err) => {
        document.getElementById('joinStatus').textContent = 'âŒ Connection error. Please try again.';
        console.error('Peer error:', err);
      });
    }

    function setupConnection() {
      connection.on('data', (data) => {
        handleRemoteMove(data);
      });
      
      connection.on('close', async () => {
        console.log('ðŸ”Œ Connection closed - opponent disconnected');
        
        // Mark opponent as disconnected in database
        const playerRole = isHost ? 'guest' : 'host';
        await markDisconnected(playerRole);
        
        // Show reconnection UI
        const reconnectDiv = document.createElement('div');
        reconnectDiv.id = 'reconnectNotice';
        reconnectDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          padding: 30px;
          border-radius: 15px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.3);
          z-index: 10000;
          text-align: center;
          max-width: 400px;
        `;
        reconnectDiv.innerHTML = `
          <h3 style="margin: 0 0 15px 0; color: #e74c3c;">âš ï¸ Opponent Disconnected</h3>
          <p style="margin-bottom: 20px; color: #7f8c8d;">
            They have 5 minutes to rejoin.<br>
            If they don't return, you'll win automatically.
          </p>
          <div id="reconnectTimer" style="font-size: 24px; font-weight: bold; color: var(--accent); margin-bottom: 20px;">5:00</div>
          <button onclick="document.getElementById('reconnectNotice').remove(); backToMenu();" style="
            padding: 12px 24px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
          ">Leave Game</button>
        `;
        
        document.body.appendChild(reconnectDiv);
        
        // Start 5-minute countdown
        let timeRemaining = 300; // 5 minutes in seconds
        const timerInterval = setInterval(() => {
          timeRemaining--;
          const minutes = Math.floor(timeRemaining / 60);
          const seconds = timeRemaining % 60;
          const timerEl = document.getElementById('reconnectTimer');
          
          if (timerEl) {
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }
          
          if (timeRemaining <= 0) {
            clearInterval(timerInterval);
            if (reconnectDiv.parentNode) {
              reconnectDiv.remove();
            }
            // Auto-forfeit handled by database function
            alert('Opponent did not rejoin. You win!');
            if (game) game.endGame();
          }
        }, 1000);
      });
      
      connection.on('error', (err) => {
        console.error('Connection error:', err);
      });
    }

    function handleRemoteMove(data) {
      if (!game) {
        // Handle setup messages before game starts
        if (data.type === 'setup' && !isHost) {
          // Joiner receives setup from host
          opponentName = data.hostName;
          startingPlayer = data.startingPlayer;
          currentGameId = data.gameId; // Receive game ID from host
          
          // Determine joiner's role based on who starts
          if (startingPlayer === 'player') {
            onlinePlayerRole = 'ai'; // Host starts, joiner is second
          } else {
            onlinePlayerRole = 'player'; // Joiner starts, joiner is first
          }
          
          // Start the game
          if (onlinePlayerRole === 'player') {
            player1Name = myOnlineName;
            player2Name = opponentName;
          } else {
            player1Name = opponentName;
            player2Name = myOnlineName;
          }
          
          startGame('online', null);
          return;
        }
        
        if (data.type === 'joinerName' && isHost) {
          // Host receives joiner's name
          opponentName = data.name;
          
          // Update game record with guest info
          if (currentGameId && currentUser) {
            updateGameRecord({
              guest_id: data.userId || null,
              guest_peer_id: data.peerId || null,
              status: 'active'
            });
          }
          
          // Start the game
          if (onlinePlayerRole === 'player') {
            player1Name = myOnlineName;
            player2Name = opponentName;
          } else {
            player1Name = opponentName;
            player2Name = myOnlineName;
          }
          
          startGame('online', null);
          return;
        }
        
        return;
      }
      
      if (data.type === 'move') {
        // Opponent played a word
        game.applyRemoteMove(data);
      } else if (data.type === 'pass') {
        // Opponent passed
        game.applyRemotePass();
      } else if (data.type === 'chat') {
        // Received chat message
        addChatMessage(data.sender, data.message, false);
      } else if (data.type === 'tilePlacement') {
        // Opponent placed a tile (preview)
        game.addOpponentPreviewTile(data);
      } else if (data.type === 'tileRecall') {
        // Opponent recalled tiles
        game.clearOpponentPreviewTiles(data.positions);
      } else if (data.type === 'reconnect') {
        // Opponent reconnected!
        console.log('âœ… Opponent reconnected');
        
        const reconnectNotice = document.getElementById('reconnectNotice');
        if (reconnectNotice) {
          reconnectNotice.remove();
        }
        
        // Update database
        const playerRole = data.playerRole;
        const updates = { status: 'active', disconnected_player: null, disconnect_timestamp: null };
        if (playerRole === 'host') {
          updates.host_connected = true;
        } else {
          updates.guest_connected = true;
        }
        updateGameRecord(updates);
        
        // Resync game state
        if (game) {
          game.saveGameState();
          // Send current game state to reconnected opponent
          connection.send({
            type: 'gameStateSync',
            gameId: currentGameId
          });
        }
      } else if (data.type === 'gameStateSync') {
        // Load game state from database
        if (game && data.gameId) {
          game.loadGameState(data.gameId);
        }
      }
    }

    function sendMove(moveData) {
      if (connection && connection.open) {
        connection.send(moveData);
      }
    }

    // Chat functions
    let chatOpen = false;

    function toggleChat() {
      chatOpen = !chatOpen;
      const chatPanel = document.getElementById('chatPanel');
      const chatToggle = document.getElementById('chatToggle');
      
      if (chatOpen) {
        chatPanel.style.display = 'block';
        chatToggle.style.display = 'none';
        
        // Scroll to bottom
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // Focus input
        document.getElementById('chatInput').focus();
      } else {
        chatPanel.style.display = 'none';
        chatToggle.style.display = 'block';
      }
    }

    function sendChatMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      if (connection && connection.open) {
        connection.send({
          type: 'chat',
          message: message,
          sender: myOnlineName
        });
        
        // Add to our own chat
        addChatMessage(myOnlineName, message, true);
        
        input.value = '';
      }
    }

    function addChatMessage(sender, message, isMe) {
      const chatMessages = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      
      messageDiv.style.cssText = `
        padding: 10px;
        border-radius: 8px;
        max-width: 80%;
        word-wrap: break-word;
        ${isMe ? 'background: var(--accent); color: white; margin-left: auto; text-align: right;' : 'background: rgba(139, 90, 43, 0.15);'}
      `;
      
      if (!isMe) {
        messageDiv.innerHTML = `
          <div style="font-weight: bold; font-size: 0.85rem; margin-bottom: 4px; color: var(--accent);">${sender}</div>
          <div>${message}</div>
        `;
      } else {
        messageDiv.innerHTML = `<div>${message}</div>`;
      }
      
      chatMessages.appendChild(messageDiv);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // Show notification if chat is closed
      if (!chatOpen && !isMe) {
        const chatToggle = document.getElementById('chatToggle');
        chatToggle.textContent = 'ðŸ’¬ !';
        chatToggle.style.animation = 'pulse 1s ease-in-out 3';
        
        setTimeout(() => {
          chatToggle.textContent = 'ðŸ’¬';
          chatToggle.style.animation = '';
        }, 3000);
      }
    }

    function startGameWithNames() {
      const p1 = document.getElementById('player1Name').value.trim();
      const p2 = document.getElementById('player2Name').value.trim();
      
      player1Name = p1 ? capitalizeName(p1) : 'Player 1';
      player2Name = p2 ? capitalizeName(p2) : 'Player 2';
      
      startGame('human', null);
    }

    function startGame(mode, difficulty) {
      gameMode = mode;
      if (difficulty) {
        aiDifficulty = difficulty;
      }
      
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'none';
      document.getElementById('gameBoard').style.display = 'flex';
      
      // Show chat toggle for online mode
      if (mode === 'online') {
        document.getElementById('chatToggle').style.display = 'block';
      }
      
      if (mode === 'human') {
        document.getElementById('player1Label').textContent = player1Name;
        document.getElementById('player2Label').textContent = player2Name;
      } else if (mode === 'online') {
        document.getElementById('player1Label').textContent = player1Name;
        document.getElementById('player2Label').textContent = player2Name;
      } else {
        document.getElementById('player1Label').textContent = 'You';
        // Show bot name and rating if available
        if (currentBotPersonality) {
          document.getElementById('player2Label').textContent = `${currentBotPersonality.name} (${currentBotPersonality.rating})`;
        } else {
          document.getElementById('player2Label').textContent = 'AI';
        }
      }
      
      // Initialize game and store globally
      game = new ScrabbleGame(mode, aiDifficulty);
    }

    // Letter distribution and points
    const LETTER_DIST = {
      'A': {count: 9, points: 1}, 'B': {count: 2, points: 3}, 'C': {count: 2, points: 3},
      'D': {count: 4, points: 2}, 'E': {count: 12, points: 1}, 'F': {count: 2, points: 4},
      'G': {count: 3, points: 2}, 'H': {count: 2, points: 4}, 'I': {count: 9, points: 1},
      'J': {count: 1, points: 8}, 'K': {count: 1, points: 5}, 'L': {count: 4, points: 1},
      'M': {count: 2, points: 3}, 'N': {count: 6, points: 1}, 'O': {count: 8, points: 1},
      'P': {count: 2, points: 3}, 'Q': {count: 1, points: 10}, 'R': {count: 6, points: 1},
      'S': {count: 4, points: 1}, 'T': {count: 6, points: 1}, 'U': {count: 4, points: 1},
      'V': {count: 2, points: 4}, 'W': {count: 2, points: 4}, 'X': {count: 1, points: 8},
      'Y': {count: 2, points: 4}, 'Z': {count: 1, points: 10}, '_': {count: 2, points: 0}
    };

    // Premium squares
    const PREMIUM_SQUARES = {
      tws: [[0,0], [0,7], [0,14], [7,0], [7,14], [14,0], [14,7], [14,14]],
      dws: [[1,1], [2,2], [3,3], [4,4], [1,13], [2,12], [3,11], [4,10], 
             [13,1], [12,2], [11,3], [10,4], [13,13], [12,12], [11,11], [10,10]],
      tls: [[1,5], [1,9], [5,1], [5,5], [5,9], [5,13], [9,1], [9,5], [9,9], 
             [9,13], [13,5], [13,9]],
      dls: [[0,3], [0,11], [2,6], [2,8], [3,0], [3,7], [3,14], [6,2], [6,6], 
             [6,8], [6,12], [7,3], [7,11], [8,2], [8,6], [8,8], [8,12], [11,0], 
             [11,7], [11,14], [12,6], [12,8], [14,3], [14,11]]
    };

    // Word validation cache
    const wordCache = new Map();
    
    // Basic common words for offline validation
    // Dictionary will be loaded from GitHub on first run
    let offlineWords = new Set();
    let dictionaryLoaded = false;
    
    async function loadDictionary() {
      const statusEl = document.getElementById('dict-status');
      
      // Check localStorage cache first
      try {
        const cached = localStorage.getItem('sowpods_dict');
        const cacheTime = localStorage.getItem('sowpods_time');
        const age = Date.now() - (parseInt(cacheTime) || 0);
        
        if (cached && age < 7 * 24 * 60 * 60 * 1000) { // 7 days cache
          console.log('Loading cached dictionary...');
          offlineWords = new Set(JSON.parse(cached));
          dictionaryLoaded = true;
          if (statusEl) statusEl.style.display = 'none';
          console.log(`âœ… Loaded ${offlineWords.size} words from cache`);
          return;
        }
      } catch (e) {
        console.warn('Cache load failed:', e);
      }
      
      // Multiple fallback URLs for SOWPODS dictionary
      const dictionaryUrls = [
        'https://raw.githubusercontent.com/jesstess/Scrabble/master/scrabble/sowpods.txt',
        'https://raw.githubusercontent.com/redbo/scrabble/master/dictionary.txt',
        'https://cdn.jsdelivr.net/gh/jesstess/Scrabble@master/scrabble/sowpods.txt'
      ];
      
      // Try each URL until one works
      for (const url of dictionaryUrls) {
        try {
          console.log(`Fetching dictionary from ${url}...`);
          
          const response = await fetch(url, {
            mode: 'cors',
            cache: 'default'
          });
          
          if (!response.ok) {
            console.warn(`Failed to fetch from ${url}: HTTP ${response.status}`);
            continue; // Try next URL
          }
          
          const text = await response.text();
          const words = text.split('\n')
            .map(w => w.trim().toUpperCase())
            .filter(w => w.length > 0 && /^[A-Z]+$/.test(w));
          
          if (words.length < 1000) {
            console.warn(`Dictionary too small (${words.length} words), trying next source...`);
            continue;
          }
          
          offlineWords = new Set(words);
          dictionaryLoaded = true;
          
          // Cache for next time
          try {
            localStorage.setItem('sowpods_dict', JSON.stringify(words));
            localStorage.setItem('sowpods_time', Date.now());
          } catch (e) {
            console.warn('Cache save failed:', e);
          }
          
          if (statusEl) statusEl.style.display = 'none';
          console.log(`âœ… Loaded ${words.length} words from ${url}`);
          return; // Success! Exit function
          
        } catch (error) {
          console.error(`Failed to load from ${url}:`, error);
          // Continue to next URL
        }
      }
      
      // All URLs failed - use embedded basic dictionary
      console.error('All dictionary sources failed, using embedded basic dictionary');
      
      // Basic embedded dictionary (most common words)
      offlineWords = new Set([
        'AA', 'AB', 'AD', 'AE', 'AG', 'AH', 'AI', 'AL', 'AM', 'AN', 'AR', 'AS', 'AT', 'AW', 'AX', 'AY',
        'BA', 'BE', 'BI', 'BO', 'BY', 'DA', 'DE', 'DO', 'ED', 'EF', 'EH', 'EL', 'EM', 'EN', 'ER', 'ES', 'ET', 'EX',
        'FA', 'FE', 'GO', 'HA', 'HE', 'HI', 'HM', 'HO', 'ID', 'IF', 'IN', 'IS', 'IT',
        'JO', 'KA', 'KI', 'LA', 'LI', 'LO', 'MA', 'ME', 'MI', 'MM', 'MO', 'MU', 'MY',
        'NA', 'NE', 'NO', 'NU', 'OD', 'OE', 'OF', 'OH', 'OI', 'OM', 'ON', 'OP', 'OR', 'OS', 'OW', 'OX', 'OY',
        'PA', 'PE', 'PI', 'PO', 'QI', 'RE', 'SH', 'SI', 'SO', 'TA', 'TI', 'TO',
        'UH', 'UM', 'UN', 'UP', 'US', 'UT', 'WE', 'WO', 'XI', 'XU', 'YA', 'YE', 'YO', 'YU', 'ZA',
        'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE', 'OUR', 'OUT', 'DAY', 'GET', 'HAS', 'HIM', 'HIS', 'HOW', 'MAN', 'NEW', 'NOW', 'OLD', 'SEE', 'TWO', 'WAY', 'WHO', 'BOY', 'DID', 'ITS', 'LET', 'PUT', 'SAY', 'SHE', 'TOO', 'USE',
        'CAT', 'DOG', 'RUN', 'SIT', 'EAT', 'BIG', 'RED', 'HOT', 'SUN', 'FUN', 'PLAY', 'WORD', 'GOOD', 'MAKE', 'HELP', 'LOOK', 'CALL', 'FIND', 'GIVE', 'TELL', 'WORK', 'SEEM', 'FEEL', 'HAND', 'TURN', 'SHOW', 'PART', 'EVEN', 'LAND', 'WELL', 'BACK', 'ONLY', 'COME', 'MADE', 'FIND', 'YEAR', 'WORK', 'OVER', 'VERY', 'ALSO', 'WELL', 'DOWN', 'HIGH', 'JUST', 'LIFE', 'LONG', 'MUCH', 'SAME', 'TAKE', 'WANT', 'KNOW', 'MOVE', 'LIKE', 'FACE', 'LIVE', 'AREA', 'CITY', 'BOOK', 'FORM', 'IDEA', 'LOVE', 'FOOD', 'GAME', 'HOME', 'WORD', 'CASE', 'TIME', 'NAME', 'LINE', 'SIDE', 'HEAD', 'ROAD', 'MILE', 'FIRE', 'TREE', 'BIRD', 'FISH',
        'QUIZ', 'JAZZ', 'FIZZ', 'BUZZ'
      ]);
      
      dictionaryLoaded = true;
      
      if (statusEl) {
        statusEl.innerHTML = `
          âš ï¸ Could not load full dictionary (network issue)<br>
          <small>Using ${offlineWords.size} basic words - <a href="#" onclick="location.reload()" style="color: inherit; text-decoration: underline;">Retry</a></small>
        `;
        statusEl.style.background = '#fff3cd';
        statusEl.style.color = '#856404';
        statusEl.style.padding = '12px';
        statusEl.style.fontSize = '14px';
      }
      
      console.log(`âš ï¸ Using embedded dictionary (${offlineWords.size} words)`);
    }
    
    // Start loading immediately
    loadDictionary();
    
    // ========================================
    // VERSION CHECK SYSTEM - DISABLED FOR NOW
    // ========================================
    /*
    const CURRENT_VERSION = '1.0.0'; // Update this when releasing new version
    const VERSION_CHECK_URL = 'https://raw.githubusercontent.com/ThitiKhacharoen/Scrabble/main/version.txt';
    
    async function checkForUpdates() {
      try {
        // Check on every page load for latest version
        const now = Date.now();
        
        // Fetch latest version
        const response = await fetch(VERSION_CHECK_URL, {
          cache: 'no-cache'
        });
        
        if (!response.ok) {
          console.log('Version check failed (server issue)');
          return;
        }
        
        const latestVersion = (await response.text()).trim();
        
        // Save check time
        localStorage.setItem('last_version_check', now.toString());
        
        // Compare versions
        if (latestVersion !== CURRENT_VERSION && isNewerVersion(latestVersion, CURRENT_VERSION)) {
          // Check if user already dismissed this version
          const dismissedVersion = localStorage.getItem('dismissed_version');
          if (dismissedVersion !== latestVersion) {
            showUpdateNotification(latestVersion);
          }
        }
        
      } catch (error) {
        console.log('Version check failed:', error.message);
        // Silently fail - don't bother user
      }
    }
    
    function isNewerVersion(latest, current) {
      const latestParts = latest.split('.').map(Number);
      const currentParts = current.split('.').map(Number);
      
      for (let i = 0; i < 3; i++) {
        if (latestParts[i] > currentParts[i]) return true;
        if (latestParts[i] < currentParts[i]) return false;
      }
      return false;
    }
    
    function showUpdateNotification(newVersion) {
      const banner = document.createElement('div');
      banner.id = 'update-banner';
      banner.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        z-index: 10001;
        display: flex;
        align-items: center;
        gap: 16px;
        font-size: 14px;
        font-weight: 600;
        animation: slideUp 0.3s ease-out;
      `;
      
      banner.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <span style="font-size: 24px;">ðŸŽ‰</span>
          <div>
            <div style="font-size: 16px; margin-bottom: 4px;">New Version Available!</div>
            <div style="font-size: 12px; opacity: 0.9;">v${newVersion} is ready</div>
          </div>
        </div>
        <button onclick="
          // Hard refresh to clear cache and get latest version
          localStorage.removeItem('last_version_check');
          localStorage.removeItem('dictionary_cache');
          location.reload(true);
        " style="
          background: white;
          color: #27ae60;
          border: none;
          padding: 10px 20px;
          border-radius: 8px;
          font-weight: 700;
          cursor: pointer;
          font-size: 14px;
          transition: transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          Update Now
        </button>
        <button onclick="
          localStorage.setItem('dismissed_version', '${newVersion}');
          this.parentElement.remove();
        " style="
          background: transparent;
          color: white;
          border: 1px solid rgba(255,255,255,0.5);
          padding: 10px 16px;
          border-radius: 8px;
          font-weight: 600;
          cursor: pointer;
          font-size: 14px;
        ">
          Later
        </button>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideUp {
          from {
            transform: translateX(-50%) translateY(100px);
            opacity: 0;
          }
          to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
          }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(banner);
      
      // Auto-hide after 30 seconds
      setTimeout(() => {
        if (banner.parentElement) {
          banner.style.animation = 'slideUp 0.3s ease-out reverse';
          setTimeout(() => banner.remove(), 300);
        }
      }, 30000);
    }
    
    // Check for updates on load (after 3 seconds to not interfere with game loading)
    setTimeout(checkForUpdates, 3000);
    */
    // ========================================
    // END VERSION CHECK SYSTEM
    // ========================================

    async function validateWord(word) {
      word = word.toUpperCase();
      
      // Handle blank tiles (_) - try all possible letters
      if (word.includes('_')) {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        
        // Try replacing each blank with each letter
        for (const letter of alphabet) {
          const testWord = word.replace('_', letter);
          
          // If still has blanks, recursively validate
          if (testWord.includes('_')) {
            const isValid = await validateWord(testWord);
            if (isValid) {
              wordCache.set(word, true);
              return true;
            }
          } else {
            // Check if this combination is valid
            if (offlineWords.has(testWord)) {
              wordCache.set(word, true);
              return true;
            }
          }
        }
        
        // None of the combinations were valid
        wordCache.set(word, false);
        return false;
      }
      
      if (wordCache.has(word)) {
        return wordCache.get(word);
      }

      // Try offline validation first
      if (offlineWords.has(word)) {
        wordCache.set(word, true);
        return true;
      }

      // Try online API
      try {
        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`, {
          signal: AbortSignal.timeout(5000) // 5 second timeout
        });
        const isValid = response.ok;
        wordCache.set(word, isValid);
        return isValid;
      } catch (error) {
        // If offline or API fails, reject unknown words
        console.log('Dictionary API unavailable, rejecting unknown word:', word);
        wordCache.set(word, false);
        return false;
      }
    }

    class ScrabbleGame {
      constructor(mode, difficulty) {
        this.gameMode = mode; // 'ai' or 'human'
        this.aiDifficulty = difficulty || 5; // 1-10 scale (1=easiest, 10=hardest)
        this.board = Array(15).fill(null).map(() => Array(15).fill(null));
        this.tileBag = this.initializeTileBag();
        this.playerRack = [];
        this.aiRack = [];
        this.playerScore = 0;
        this.aiScore = 0;
        
        // Set starting turn based on mode
        if (this.gameMode === 'online' && startingPlayer) {
          this.currentTurn = startingPlayer; // Use randomized starting player
        } else {
          this.currentTurn = 'player'; // Default for other modes
        }
        
        this.placedTiles = [];
        this.selectedTile = null;
        this.selectedTileIndex = null;
        this.direction = 'horizontal';
        this.firstMove = true;
        this.consecutivePasses = 0;
        this.pendingTransition = false; // Track if waiting for player to confirm turn
        this.opponentPreviewTiles = []; // Track opponent's tile placements in real-time
        // CHEATING PENALTY DISABLED
        // this.tilesRevealed = false; // Track if tiles have been revealed this turn
        // this.cheatingPenalty = 0; // Track cheating penalty points
        
        this.initializeGame();
      }

      showTurnTransition() {
        if (this.gameMode !== 'human') return; // Only for 2-player mode
        
        this.pendingTransition = true;
        // this.tilesRevealed = false; // CHEATING PENALTY DISABLED
        const currentPlayerName = this.currentTurn === 'player' ? player1Name : player2Name;
        
        // Animate the transition screen entrance
        const transitionEl = document.getElementById('turnTransition');
        transitionEl.style.display = 'flex';
        transitionEl.style.animation = 'none';
        void transitionEl.offsetWidth; // Force reflow
        transitionEl.style.animation = 'fadeIn 0.3s ease-in-out';
        
        document.getElementById('transitionPlayerName').textContent = currentPlayerName + "'s Turn";
        document.getElementById('transitionNextPlayer').textContent = currentPlayerName;
        
        // v1.3.2 Fix: Hide the rack with blur (defensive check)
        const rack = document.getElementById('rack');
        if (rack) {
          rack.style.filter = 'blur(20px)';
          rack.style.pointerEvents = 'none';
          rack.style.visibility = 'visible'; // Keep visible but blurred
        }
        
        // CHEATING PENALTY DISABLED
        // this.setupCheatingDetector();
      }

      /* CHEATING PENALTY SYSTEM - DISABLED BUT KEPT FOR REFERENCE
      setupCheatingDetector() {
        const rack = document.getElementById('rack');
        
        // Remove old detector if exists
        if (this.cheatingDetectorHandler) {
          rack.removeEventListener('click', this.cheatingDetectorHandler);
        }
        
        // Add new detector
        this.cheatingDetectorHandler = (e) => {
          // If tiles are blurred and not revealed yet, they're trying to cheat
          if (rack.style.filter === 'blur(20px)' && !this.tilesRevealed) {
            this.applyCheatingPenalty();
            e.stopPropagation();
            e.preventDefault();
          }
        };
        
        rack.addEventListener('click', this.cheatingDetectorHandler);
      }

      applyCheatingPenalty() {
        const PENALTY = 10;
        
        // Apply penalty to current player
        if (this.currentTurn === 'player') {
          this.playerScore = Math.max(0, this.playerScore - PENALTY);
        } else {
          this.aiScore = Math.max(0, this.aiScore - PENALTY);
        }
        
        this.cheatingPenalty += PENALTY;
        
        // Show warning
        const warning = document.getElementById('cheatingWarning');
        warning.style.display = 'block';
        
        // Flash animation
        warning.style.animation = 'none';
        void warning.offsetWidth;
        warning.style.animation = 'pulse 0.5s ease-in-out 3';
        
        // Update scores
        this.updateScores();
        
        // Show message
        const currentPlayerName = this.currentTurn === 'player' ? player1Name : player2Name;
        this.showMessage(`ðŸš¨ ${currentPlayerName} caught cheating! -${PENALTY} points!`);
        
        // Auto-hide warning after 5 seconds
        setTimeout(() => {
          warning.style.display = 'none';
        }, 5000);
      }
      */

      confirmTurnTransition() {
        // CHEATING PENALTY DISABLED
        // this.tilesRevealed = true;
        
        // Fade out transition
        this.pendingTransition = false;
        const transitionEl = document.getElementById('turnTransition');
        transitionEl.style.animation = 'fadeOut 0.3s ease-in-out';
        
        setTimeout(() => {
          transitionEl.style.display = 'none';
          
          // v1.3.2 Fix: Show rack unblurred with defensive clearing
          const rack = document.getElementById('rack');
          if (rack) {
            rack.style.filter = 'none';
            rack.style.pointerEvents = 'auto';
            rack.style.visibility = 'visible';
            rack.style.opacity = '1';
          }
          
          this.renderRack();
        }, 300);
      }

      initializeTileBag() {
        const bag = [];
        for (const [letter, {count, points}] of Object.entries(LETTER_DIST)) {
          for (let i = 0; i < count; i++) {
            bag.push({letter, points});
          }
        }
        return this.shuffle(bag);
      }

      shuffle(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      drawTiles(count) {
        const tiles = [];
        for (let i = 0; i < count && this.tileBag.length > 0; i++) {
          const tile = this.tileBag.pop();
          tile._isNew = true; // Mark as new for animation
          tiles.push(tile);
        }
        return tiles;
      }

      initializeGame() {
        this.playerRack = this.drawTiles(7);
        this.aiRack = this.drawTiles(7);
        this.renderBoard();
        this.renderRack();
        this.updateScores();
        this.updateInfo();
        this.setupEventListeners();
        
        // Show starting message based on mode
        if (this.gameMode === 'online') {
          if (this.currentTurn === onlinePlayerRole) {
            this.showMessage(`You go first! First word must cover the center â˜…`);
          } else {
            const opponentDisplayName = this.currentTurn === 'player' ? player1Name : player2Name;
            this.showMessage(`${opponentDisplayName} goes first. Wait for their turn...`);
          }
        } else {
          const playerName = this.gameMode === 'human' ? player1Name : 'You';
          const message = playerName === 'You' 
            ? 'Your turn. First word must cover the center â˜…'
            : `${playerName}'s turn. First word must cover the center â˜…`;
          this.showMessage(message);
        }
      }

      renderBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row;
            cell.dataset.col = col;

            // Add premium square styling
            if (row === 7 && col === 7) {
              cell.className += ' star';
              cell.textContent = 'â˜…';
            } else if (PREMIUM_SQUARES.tws.some(([r, c]) => r === row && c === col)) {
              cell.className += ' tws';
              cell.textContent = '3W';
            } else if (PREMIUM_SQUARES.dws.some(([r, c]) => r === row && c === col)) {
              cell.className += ' dws';
              cell.textContent = '2W';
            } else if (PREMIUM_SQUARES.tls.some(([r, c]) => r === row && c === col)) {
              cell.className += ' tls';
              cell.textContent = '3L';
            } else if (PREMIUM_SQUARES.dls.some(([r, c]) => r === row && c === col)) {
              cell.className += ' dls';
              cell.textContent = '2L';
            }

            // Add existing tile
            if (this.board[row][col]) {
              cell.textContent = ''; // Clear premium square text
              const tile = document.createElement('div');
              tile.className = 'tile';
              tile.innerHTML = `${this.board[row][col].letter}<span class="points">${this.board[row][col].points}</span>`;
              cell.appendChild(tile);
              cell.className += ' occupied';
            }

            // Add preview for placed tiles
            const placedHere = this.placedTiles.find(t => t.row === row && t.col === col);
            if (placedHere) {
              cell.textContent = ''; // Clear premium square text
              const tile = document.createElement('div');
              tile.className = 'tile tile-placed';
              tile.innerHTML = `${placedHere.tile.letter}<span class="points">${placedHere.tile.points}</span>`;
              cell.appendChild(tile);
              cell.className += ' preview';
            }

            // Add opponent preview tiles (online mode only)
            if (this.gameMode === 'online') {
              const opponentTileHere = this.opponentPreviewTiles.find(t => t.row === row && t.col === col);
              if (opponentTileHere && !this.board[row][col] && !placedHere) {
                cell.textContent = ''; // Clear premium square text
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.opacity = '0.6';
                tile.innerHTML = `${opponentTileHere.letter}<span class="points">${opponentTileHere.points}</span>`;
                cell.appendChild(tile);
                cell.className += ' opponent-preview';
              }
            }

            cell.addEventListener('click', () => this.handleCellClick(row, col));
            boardEl.appendChild(cell);
          }
        }
      }

      renderRack() {
        const rackEl = document.getElementById('rack');
        
        // v1.3.2 Fix: Force clear any lingering filters/styles
        rackEl.style.filter = 'none';
        rackEl.style.pointerEvents = 'auto';
        rackEl.style.visibility = 'visible';
        rackEl.style.opacity = '1';
        
        rackEl.innerHTML = '';
        
        // In 2-player mode, show the current player's rack
        const currentRack = this.currentTurn === 'player' ? this.playerRack : this.aiRack;
        
        currentRack.forEach((tile, index) => {
          // v1.3.2 Fix: Defensive check for undefined/null tiles
          if (!tile) return;
          if (tile.placed) return;
          
          if (tile) {
            const tileEl = document.createElement('div');
            tileEl.className = 'rack-tile';
            
            // Check if this is a new tile (just drawn)
            if (tile._isNew) {
              tileEl.classList.add('tile-entering');
              // Clear the flag after animation
              setTimeout(() => {
                tile._isNew = false;
                // Add flip animation after entering
                tileEl.classList.remove('tile-entering');
                tileEl.classList.add('tile-flip');
              }, 600);
            }
            
            tileEl.innerHTML = `${tile.letter}<span class="points">${tile.points}</span>`;
            // Store the actual tile object reference, not just index
            tileEl._tileRef = tile;
            tileEl._tileIndex = index;
            tileEl.addEventListener('click', () => this.selectTile(tile, index));
            rackEl.appendChild(tileEl);
          }
        });
      }

      selectTile(tile, index) {
        this.selectedTile = tile;
        this.selectedTileIndex = index;
        
        // Play tile click sound
        SFX.tileClick();
        
        // Update UI to show selection
        document.querySelectorAll('.rack-tile').forEach((el) => {
          if (el._tileRef === tile) {
            el.classList.add('selected');
          } else {
            el.classList.remove('selected');
          }
        });
      }

      handleCellClick(row, col) {
        // Prevent placing tiles when not your turn in online mode
        if (this.gameMode === 'online' && this.currentTurn !== onlinePlayerRole) {
          return;
        }
        
        if (this.board[row][col]) return;
        if (this.selectedTile === null) return;

        const tile = this.selectedTile;
        if (!tile || tile.placed) return;

        // Place tile
        tile.placed = true;
        tile.row = row;
        tile.col = col;
        this.placedTiles.push({tile, row, col, index: this.selectedTileIndex});
        
        // Play tile placement sound
        SFX.tilePlaced();
        
        // Send tile placement to opponent in real-time (online mode)
        if (this.gameMode === 'online') {
          sendMove({
            type: 'tilePlacement',
            letter: tile.letter,
            points: tile.points,
            row: row,
            col: col
          });
        }
        
        this.selectedTile = null;
        this.selectedTileIndex = null;
        this.renderBoard();
        this.renderRack();
        this.calculateCurrentScore();
      }

      recallTiles() {
        // Send recall notification to opponent in online mode
        if (this.gameMode === 'online' && this.placedTiles.length > 0) {
          sendMove({
            type: 'tileRecall',
            positions: this.placedTiles.map(pt => ({ row: pt.row, col: pt.col }))
          });
        }
        
        this.placedTiles.forEach(({tile, index}) => {
          tile.placed = false;
          delete tile.row;
          delete tile.col;
        });
        this.placedTiles = [];
        this.renderBoard();
        this.renderRack();
        this.calculateCurrentScore();
      }

      calculateCurrentScore() {
        if (this.placedTiles.length === 0) {
          document.getElementById('currentScore').textContent = '0';
          return 0;
        }

        const tiles = this.placedTiles.map(t => ({...t}));
        tiles.sort((a, b) => {
          if (this.direction === 'horizontal') {
            return a.col - b.col;
          }
          return a.row - b.row;
        });

        let score = 0;
        let wordMultiplier = 1;

        tiles.forEach(({tile, row, col}) => {
          let letterScore = tile.points;
          
          // Apply letter multipliers
          if (PREMIUM_SQUARES.dls.some(([r, c]) => r === row && c === col)) {
            letterScore *= 2;
          } else if (PREMIUM_SQUARES.tls.some(([r, c]) => r === row && c === col)) {
            letterScore *= 3;
          }

          score += letterScore;

          // Apply word multipliers
          if (PREMIUM_SQUARES.dws.some(([r, c]) => r === row && c === col)) {
            wordMultiplier *= 2;
          } else if (PREMIUM_SQUARES.tws.some(([r, c]) => r === row && c === col)) {
            wordMultiplier *= 3;
          }
        });

        score *= wordMultiplier;

        // Bonus for using all 7 tiles
        if (this.placedTiles.length === 7) {
          score += 50;
        }

        document.getElementById('currentScore').textContent = score;
        return score;
      }

      async playWord() {
        // Check if it's our turn in online mode
        if (this.gameMode === 'online' && this.currentTurn !== onlinePlayerRole) {
          this.showMessage("Wait for opponent's turn");
          return;
        }
        
        if (this.placedTiles.length === 0) {
          this.showMessage('Please place at least one tile');
          return;
        }

        // Validate placement
        if (!this.validatePlacement()) {
          this.showMessage('Invalid placement. Tiles must form a continuous line and connect to existing words.');
          return;
        }

        if (this.firstMove) {
          const centerCovered = this.placedTiles.some(({row, col}) => row === 7 && col === 7);
          if (!centerCovered) {
            this.showMessage('First word must cover the center â˜…');
            return;
          }
        }

        // Get the word formed
        const word = this.getFormedWord();
        
        // Validate word with dictionary
        this.showMessage('Validating word...');
        const isValid = await validateWord(word);
        
        if (!isValid) {
          SFX.wordFail();
          this.showMessage(`"${word}" is not a valid English word. Try again.`);
          return;
        }

        // Calculate score
        const score = this.calculateCurrentScore();
        
        // Play success sound
        SFX.wordSuccess();
        
        // Commit tiles to board
        this.placedTiles.forEach(({tile, row, col}) => {
          this.board[row][col] = tile;
        });

        // Update score for current player
        if (this.currentTurn === 'player') {
          this.playerScore += score;
        } else {
          this.aiScore += score;
        }
        
        this.firstMove = false;
        const tilesUsedData = this.placedTiles.map(pt => ({
          letter: pt.tile.letter,
          points: pt.tile.points,
          row: pt.row,
          col: pt.col
        }));
        this.placedTiles = [];
        this.consecutivePasses = 0;

        // Refill rack for current player
        const currentRack = this.currentTurn === 'player' ? this.playerRack : this.aiRack;
        const tilesUsed = currentRack.filter(t => t && t.placed).length;
        const remainingTiles = currentRack.filter(t => !t || !t.placed);
        const newTiles = this.drawTiles(tilesUsed);
        
        if (this.currentTurn === 'player') {
          this.playerRack = [...remainingTiles, ...newTiles];
        } else {
          this.aiRack = [...remainingTiles, ...newTiles];
        }

        // Send move to opponent in online mode
        if (this.gameMode === 'online') {
          sendMove({
            type: 'move',
            tiles: tilesUsedData,
            score: score,
            word: word,
            newTilesCount: tilesUsed
          });
        }

        this.updateScores();
        this.renderBoard();
        this.renderRack();
        this.updateInfo();

        // Switch turn
        this.currentTurn = this.currentTurn === 'player' ? 'ai' : 'player';
        this.updateTurnIndicator();
        
        // Play turn change sound
        SFX.turnChange();
        
        if (this.gameMode === 'ai' && this.currentTurn === 'ai') {
          this.showMessage('AI is thinking...');
          setTimeout(() => this.aiTurn(), 1500);
        } else if (this.gameMode === 'human') {
          // 2-player local mode
          const playerName = this.currentTurn === 'player' ? player1Name : player2Name;
          const message = playerName === 'You' ? 'Your turn' : `${playerName}'s turn`;
          this.showMessage(message);
          this.showTurnTransition();
        } else if (this.gameMode === 'online') {
          // Online multiplayer mode
          if (this.currentTurn === onlinePlayerRole) {
            this.showMessage('Your turn!');
            this.renderRack();
          } else {
            this.showMessage("Opponent's turn...");
          }
        } else {
          // Fallback
          this.renderRack();
        }
      }

      getFormedWord() {
        const tiles = [...this.placedTiles];
        tiles.sort((a, b) => {
          if (this.direction === 'horizontal') {
            return a.col - b.col;
          }
          return a.row - b.row;
        });

        // Get the complete word including existing tiles
        if (this.direction === 'horizontal') {
          const row = tiles[0].row;
          let startCol = tiles[0].col;
          let endCol = tiles[tiles.length - 1].col;
          
          // Extend to beginning
          while (startCol > 0 && this.board[row][startCol - 1]) {
            startCol--;
          }
          
          // Extend to end
          while (endCol < 14 && this.board[row][endCol + 1]) {
            endCol++;
          }
          
          let word = '';
          for (let col = startCol; col <= endCol; col++) {
            if (this.board[row][col]) {
              word += this.board[row][col].letter;
            } else {
              const placed = this.placedTiles.find(t => t.row === row && t.col === col);
              if (placed) {
                word += placed.tile.letter;
              }
            }
          }
          return word;
        } else {
          const col = tiles[0].col;
          let startRow = tiles[0].row;
          let endRow = tiles[tiles.length - 1].row;
          
          while (startRow > 0 && this.board[startRow - 1][col]) {
            startRow--;
          }
          
          while (endRow < 14 && this.board[endRow + 1][col]) {
            endRow++;
          }
          
          let word = '';
          for (let row = startRow; row <= endRow; row++) {
            if (this.board[row][col]) {
              word += this.board[row][col].letter;
            } else {
              const placed = this.placedTiles.find(t => t.row === row && t.col === col);
              if (placed) {
                word += placed.tile.letter;
              }
            }
          }
          return word;
        }
      }

      validatePlacement() {
        if (this.placedTiles.length === 0) return false;
        
        // Auto-detect direction from placed tiles
        if (this.placedTiles.length === 1) {
          // Single tile - check if it extends an existing word
          const {row, col} = this.placedTiles[0];
          const hasHorizontalNeighbor = (col > 0 && this.board[row][col-1]) || (col < 14 && this.board[row][col+1]);
          const hasVerticalNeighbor = (row > 0 && this.board[row-1][col]) || (row < 14 && this.board[row+1][col]);
          
          if (hasHorizontalNeighbor && !hasVerticalNeighbor) {
            this.direction = 'horizontal';
          } else if (hasVerticalNeighbor && !hasHorizontalNeighbor) {
            this.direction = 'vertical';
          } else if (this.firstMove) {
            // First move, single tile - default to horizontal
            this.direction = 'horizontal';
          }
          // If both or neither, keep current direction
        } else {
          // Multiple tiles - detect from their arrangement
          const rows = this.placedTiles.map(t => t.row);
          const cols = this.placedTiles.map(t => t.col);
          const sameRow = rows.every(r => r === rows[0]);
          const sameCol = cols.every(c => c === cols[0]);
          
          if (sameRow) {
            this.direction = 'horizontal';
          } else if (sameCol) {
            this.direction = 'vertical';
          } else {
            // Tiles not in a line
            return false;
          }
        }
        
        const tiles = [...this.placedTiles];
        tiles.sort((a, b) => {
          if (this.direction === 'horizontal') {
            return a.col - b.col;
          }
          return a.row - b.row;
        });

        // Check if tiles are in a line
        if (this.direction === 'horizontal') {
          const row = tiles[0].row;
          if (!tiles.every(t => t.row === row)) return false;
          
          // Check continuity
          for (let i = 0; i < tiles.length - 1; i++) {
            const gap = tiles[i + 1].col - tiles[i].col;
            if (gap > 1) {
              // Check if gap is filled with existing tiles
              for (let col = tiles[i].col + 1; col < tiles[i + 1].col; col++) {
                if (!this.board[row][col]) return false;
              }
            }
          }
        } else {
          const col = tiles[0].col;
          if (!tiles.every(t => t.col === col)) return false;
          
          for (let i = 0; i < tiles.length - 1; i++) {
            const gap = tiles[i + 1].row - tiles[i].row;
            if (gap > 1) {
              for (let row = tiles[i].row + 1; row < tiles[i + 1].row; row++) {
                if (!this.board[row][col]) return false;
              }
            }
          }
        }

        // If not first move, check connection to existing tiles
        if (!this.firstMove) {
          let connected = false;
          for (const {row, col} of tiles) {
            const adjacent = [
              [row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]
            ];
            for (const [r, c] of adjacent) {
              if (r >= 0 && r < 15 && c >= 0 && c < 15 && this.board[r][c]) {
                connected = true;
                break;
              }
            }
            if (connected) break;
          }
          if (!connected) return false;
        }

        return true;
      }

      async aiTurn() {
        // Add thinking animation to AI score value
        const aiCard = document.getElementById('aiScoreCard');
        const aiScoreValue = aiCard.querySelector('.score-value');
        if (aiScoreValue) {
          aiScoreValue.style.animation = 'letterPulse 0.8s ease-in-out infinite';
        }
        
        // Try to find and play a valid word
        const aiMove = await this.findBestAiMove();
        
        // Remove thinking animation
        if (aiScoreValue) {
          aiScoreValue.style.animation = '';
        }
        
        if (aiMove) {
          const {tiles, startRow, startCol, direction, score, word} = aiMove;
          
          // Place tiles
          for (let i = 0; i < tiles.length; i++) {
            const row = direction === 'horizontal' ? startRow : startRow + i;
            const col = direction === 'horizontal' ? startCol + i : startCol;
            this.board[row][col] = tiles[i];
          }

          this.aiScore += score;
          this.aiRack = this.aiRack.filter(t => !tiles.includes(t));
          this.aiRack.push(...this.drawTiles(tiles.length));
          
          this.showMessage(`AI played "${word}" for ${score} points!`);
          this.firstMove = false;
          this.consecutivePasses = 0;
        } else {
          this.showMessage('AI passed their turn');
          this.consecutivePasses++;
        }

        this.renderBoard();
        this.updateScores();
        this.updateInfo();
        
        if (this.consecutivePasses >= 4) {
          this.endGame();
          return;
        }

        this.currentTurn = 'player';
        this.updateTurnIndicator();
      }

      async findBestAiMove() {
        let allPossibleMoves = [];
        
        if (this.firstMove) {
          // First move - try to place word horizontally at center
          allPossibleMoves = await this.findFirstMove();
        } else {
          // Find all possible moves on the board
          allPossibleMoves = await this.findAllPossibleMoves();
        }

        // If still no moves, try a desperation strategy with 2-letter words
        if (allPossibleMoves.length === 0 && !this.firstMove) {
          allPossibleMoves = await this.findDesperationMoves();
        }

        if (allPossibleMoves.length === 0) {
          return null; // No valid moves - will pass
        }

        // Sort by score
        allPossibleMoves.sort((a, b) => b.score - a.score);

        // Select move based on difficulty (1-10 scale)
        let selectedMove;
        const difficultyLevel = this.aiDifficulty;
        
        // Levels 1-6: Move selection based on score ranking (no lookahead)
        if (difficultyLevel === 1) {
          // Level 1: Completely random
          selectedMove = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
          
        } else if (difficultyLevel === 2) {
          // Level 2: Bottom 80%
          const moves = allPossibleMoves.slice(Math.floor(allPossibleMoves.length * 0.2));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 3) {
          // Level 3: Bottom 60%
          const moves = allPossibleMoves.slice(Math.floor(allPossibleMoves.length * 0.4));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 4) {
          // Level 4: Middle 60%
          const start = Math.floor(allPossibleMoves.length * 0.2);
          const end = Math.floor(allPossibleMoves.length * 0.8);
          const moves = allPossibleMoves.slice(start, end);
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 5) {
          // Level 5: Top 60%
          const moves = allPossibleMoves.slice(0, Math.ceil(allPossibleMoves.length * 0.6));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 6) {
          // Level 6: Top 40%
          const moves = allPossibleMoves.slice(0, Math.ceil(allPossibleMoves.length * 0.4));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else {
          // Levels 7-10: Use lookahead simulation
          const lookaheadDepth = difficultyLevel - 6; // 7->1, 8->2, 9->3, 10->4
          const topMoves = allPossibleMoves.slice(0, Math.min(5, allPossibleMoves.length)); // Consider top 5 moves
          
          let bestMoveWithLookahead = topMoves[0];
          let bestScore = -Infinity;
          
          for (const move of topMoves) {
            // Simulate this move and evaluate opponent's best response
            const evaluationScore = await this.evaluateMoveWithLookahead(move, lookaheadDepth);
            
            if (evaluationScore > bestScore) {
              bestScore = evaluationScore;
              bestMoveWithLookahead = move;
            }
          }
          
          selectedMove = bestMoveWithLookahead;
        }

        return selectedMove;
      }

      async evaluateMoveWithLookahead(move, depth) {
        if (depth === 0) {
          return move.score; // Base case: just return the immediate score
        }
        
        // Make a temporary copy of the board state
        const originalBoard = this.board.map(row => row.slice());
        const originalAiRack = [...this.aiRack];
        const originalPlayerRack = [...this.playerRack];
        
        // Simulate playing this move
        const {tiles, startRow, startCol, direction} = move;
        for (let i = 0; i < tiles.length; i++) {
          const row = direction === 'horizontal' ? startRow : startRow + i;
          const col = direction === 'horizontal' ? startCol + i : startCol;
          this.board[row][col] = tiles[i];
        }
        
        // Remove used tiles from AI rack (simulate)
        this.aiRack = this.aiRack.filter(t => !tiles.includes(t));
        
        // Simulate opponent's best counter-move
        let opponentBestScore = 0;
        
        // Quick simulation - just check top 3 opponent moves
        const opponentMoves = await this.findAllPossibleMoves();
        if (opponentMoves.length > 0) {
          opponentMoves.sort((a, b) => b.score - a.score);
          const topOpponentMove = opponentMoves[0];
          opponentBestScore = topOpponentMove.score;
          
          // Recursive lookahead if depth > 1
          if (depth > 1) {
            // Simulate opponent's move
            const {tiles: oppTiles, startRow: oppRow, startCol: oppCol, direction: oppDir} = topOpponentMove;
            for (let i = 0; i < oppTiles.length; i++) {
              const r = oppDir === 'horizontal' ? oppRow : oppRow + i;
              const c = oppDir === 'horizontal' ? oppCol + i : oppCol;
              this.board[r][c] = oppTiles[i];
            }
            
            // Recursively evaluate AI's next move
            const aiNextMoves = await this.findAllPossibleMoves();
            if (aiNextMoves.length > 0) {
              aiNextMoves.sort((a, b) => b.score - a.score);
              const futureScore = await this.evaluateMoveWithLookahead(aiNextMoves[0], depth - 1);
              opponentBestScore = futureScore; // Use the recursive evaluation
            }
          }
        }
        
        // Restore original board state
        this.board = originalBoard;
        this.aiRack = originalAiRack;
        this.playerRack = originalPlayerRack;
        
        // Evaluation: My score - Opponent's best response
        // Higher difficulty means we care more about denying opponent points
        return move.score - (opponentBestScore * 0.5);
      }

      async findDesperationMoves() {
        const moves = [];
        
        // Try all 2-letter combinations everywhere on board
        const twoLetterPerms = this.getPermutations(this.aiRack, 2);
        
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 14; col++) {
            // Check if this position or adjacent has a tile
            const hasNearbyTile = 
              this.board[row][col] ||
              this.board[row][col+1] ||
              (row > 0 && (this.board[row-1][col] || this.board[row-1][col+1])) ||
              (row < 14 && (this.board[row+1][col] || this.board[row+1][col+1])) ||
              (col > 0 && this.board[row][col-1]) ||
              (col < 13 && this.board[row][col+2]);
            
            if (!hasNearbyTile && !this.firstMove) continue;
            
            // Try horizontal 2-letter words
            if (!this.board[row][col] && !this.board[row][col+1]) {
              for (const tiles of twoLetterPerms) {
                const word = tiles.map(t => t.letter).join('');
                if (offlineWords.has(word)) {
                  // Validate all cross-words
                  if (this.validateAllFormedWords(tiles, row, col, 'horizontal')) {
                    const score = this.calculateAiScore(tiles, row, col, 'horizontal');
                    moves.push({
                      tiles: tiles.slice(),
                      startRow: row,
                      startCol: col,
                      direction: 'horizontal',
                      score: score,
                      word: word
                    });
                  }
                }
              }
            }
          }
        }
        
        // Try vertical 2-letter words
        for (let row = 0; row < 14; row++) {
          for (let col = 0; col < 15; col++) {
            const hasNearbyTile = 
              this.board[row][col] ||
              this.board[row+1][col] ||
              (row > 0 && this.board[row-1][col]) ||
              (row < 13 && this.board[row+2][col]) ||
              (col > 0 && (this.board[row][col-1] || this.board[row+1][col-1])) ||
              (col < 14 && (this.board[row][col+1] || this.board[row+1][col+1]));
            
            if (!hasNearbyTile && !this.firstMove) continue;
            
            if (!this.board[row][col] && !this.board[row+1][col]) {
              for (const tiles of twoLetterPerms) {
                const word = tiles.map(t => t.letter).join('');
                if (offlineWords.has(word)) {
                  // Validate all cross-words
                  if (this.validateAllFormedWords(tiles, row, col, 'vertical')) {
                    const score = this.calculateAiScore(tiles, row, col, 'vertical');
                    moves.push({
                      tiles: tiles.slice(),
                      startRow: row,
                      startCol: col,
                      direction: 'vertical',
                      score: score,
                      word: word
                    });
                  }
                }
              }
            }
          }
        }
        
        return moves;
      }

      async findFirstMove() {
        const moves = [];
        
        // Difficulty controls search depth - how many permutations to check
        let maxLength = 7;
        let maxPermsToCheck = Infinity;
        
        if (this.aiDifficulty === 'easy') {
          maxLength = 4; // Try shorter words only
          maxPermsToCheck = 50; // Check fewer permutations
        } else if (this.aiDifficulty === 'medium') {
          maxLength = 6;
          maxPermsToCheck = 200;
        }
        // Hard: tries all lengths up to 7, all permutations
        
        // Try different word lengths from rack
        for (let len = 2; len <= Math.min(maxLength, this.aiRack.length); len++) {
          // Get all permutations of tiles
          const permutations = this.getPermutations(this.aiRack, len);
          const permsToCheck = Math.min(maxPermsToCheck, permutations.length);
          
          for (let i = 0; i < permsToCheck; i++) {
            const tiles = permutations[i];
            const word = tiles.map(t => t.letter).join('');
            
            // Check if it's a valid word
            if (offlineWords.has(word)) {
              const startCol = 7 - Math.floor(len / 2);
              if (startCol >= 0 && startCol + len <= 15) {
                // First move has no cross-words to check, so it's always valid
                const score = this.calculateAiScore(tiles, 7, startCol, 'horizontal');
                moves.push({
                  tiles: tiles.slice(), // Clone array
                  startRow: 7,
                  startCol: startCol,
                  direction: 'horizontal',
                  score: score,
                  word: word
                });
              }
            }
          }
        }
        
        return moves;
      }

      async findAllPossibleMoves() {
        const moves = [];
        
        // Difficulty controls search thoroughness
        let searchEveryNthCell = 1;
        let maxWordLength = 7;
        let stopEarlyThreshold = Infinity;
        
        if (this.aiDifficulty === 'easy') {
          searchEveryNthCell = 2; // Skip some cells (less thorough)
          maxWordLength = 4; // Try shorter words
          stopEarlyThreshold = 30; // Stop after finding 30 moves
        } else if (this.aiDifficulty === 'medium') {
          searchEveryNthCell = 1;
          maxWordLength = 6;
          stopEarlyThreshold = 100; // Stop after finding 100 moves
        }
        // Hard: search every cell, all word lengths, find all moves
        
        // For each empty cell adjacent to an occupied cell
        for (let row = 0; row < 15; row += searchEveryNthCell) {
          for (let col = 0; col < 15; col += searchEveryNthCell) {
            if (!this.board[row][col]) {
              // Check if adjacent to an occupied cell
              const hasAdjacentTile = 
                (row > 0 && this.board[row-1][col]) ||
                (row < 14 && this.board[row+1][col]) ||
                (col > 0 && this.board[row][col-1]) ||
                (col < 14 && this.board[row][col+1]);
              
              if (hasAdjacentTile) {
                // Try both horizontal and vertical
                const hMoves = await this.findMovesAt(row, col, 'horizontal', maxWordLength);
                const vMoves = await this.findMovesAt(row, col, 'vertical', maxWordLength);
                moves.push(...hMoves, ...vMoves);
                
                // Stop early based on difficulty
                if (moves.length >= stopEarlyThreshold) {
                  return moves;
                }
              }
            }
          }
        }
        
        return moves;
      }

      async findMovesAt(row, col, direction, maxWordLength = 7) {
        const moves = [];
        
        // Limit permutations based on difficulty
        let maxPermsPerLength = Infinity;
        if (this.aiDifficulty === 'easy') {
          maxPermsPerLength = 30; // Check fewer permutations
        } else if (this.aiDifficulty === 'medium') {
          maxPermsPerLength = 100;
        }
        // Hard: check all permutations
        
        // Try different word lengths
        for (let len = 2; len <= Math.min(maxWordLength, this.aiRack.length); len++) {
          // Get all permutations
          const permutations = this.getPermutations(this.aiRack, len);
          const permsToCheck = Math.min(maxPermsPerLength, permutations.length);
          
          for (let i = 0; i < permsToCheck; i++) {
            const tiles = permutations[i];
            // Try different starting positions for this word
            for (let offset = 0; offset < len; offset++) {
              const startRow = direction === 'vertical' ? row - offset : row;
              const startCol = direction === 'horizontal' ? col - offset : col;
              
              if (startRow < 0 || startCol < 0) continue;
              
              const endRow = direction === 'vertical' ? startRow + len - 1 : startRow;
              const endCol = direction === 'horizontal' ? startCol + len - 1 : startCol;
              
              if (endRow >= 15 || endCol >= 15) continue;
              
              // Check if placement is valid (all cells empty or one matches existing)
              let canPlace = true;
              let touchesExisting = false;
              
              for (let i = 0; i < len; i++) {
                const r = direction === 'vertical' ? startRow + i : startRow;
                const c = direction === 'horizontal' ? startCol + i : startCol;
                
                if (this.board[r][c]) {
                  canPlace = false;
                  break;
                }
                
                // Check if adjacent to existing tile
                const adjacent = 
                  (r > 0 && this.board[r-1][c]) ||
                  (r < 14 && this.board[r+1][c]) ||
                  (c > 0 && this.board[r][c-1]) ||
                  (c < 14 && this.board[r][c+1]);
                
                if (adjacent) touchesExisting = true;
              }
              
              if (canPlace && touchesExisting) {
                const word = tiles.map(t => t.letter).join('');
                
                // Check if main word is valid
                if (offlineWords.has(word)) {
                  // CRITICAL: Check all cross-words formed
                  const allWordsValid = this.validateAllFormedWords(tiles, startRow, startCol, direction);
                  
                  if (allWordsValid) {
                    const score = this.calculateAiScore(tiles, startRow, startCol, direction);
                    moves.push({
                      tiles: tiles.slice(), // Clone array
                      startRow: startRow,
                      startCol: startCol,
                      direction: direction,
                      score: score,
                      word: word
                    });
                  }
                }
              }
            }
          }
        }
        
        return moves;
      }

      validateAllFormedWords(tiles, startRow, startCol, direction) {
        // Temporarily place tiles to check all formed words
        const tempPlacements = [];
        
        for (let i = 0; i < tiles.length; i++) {
          const r = direction === 'vertical' ? startRow + i : startRow;
          const c = direction === 'horizontal' ? startCol + i : startCol;
          this.board[r][c] = tiles[i];
          tempPlacements.push({r, c});
        }
        
        let allValid = true;
        
        // FIRST: Check the main word (including any tiles it connects to in-line)
        let mainWord = '';
        if (direction === 'horizontal') {
          let startC = startCol;
          let endC = startCol + tiles.length - 1;
          
          // Extend to beginning of existing word
          while (startC > 0 && this.board[startRow][startC - 1]) {
            startC--;
          }
          
          // Extend to end of existing word
          while (endC < 14 && this.board[startRow][endC + 1]) {
            endC++;
          }
          
          // Build complete word
          for (let col = startC; col <= endC; col++) {
            mainWord += this.board[startRow][col].letter;
          }
        } else {
          let startR = startRow;
          let endR = startRow + tiles.length - 1;
          
          // Extend to beginning of existing word
          while (startR > 0 && this.board[startR - 1][startCol]) {
            startR--;
          }
          
          // Extend to end of existing word
          while (endR < 14 && this.board[endR + 1][startCol]) {
            endR++;
          }
          
          // Build complete word
          for (let row = startR; row <= endR; row++) {
            mainWord += this.board[row][startCol].letter;
          }
        }
        
        // Validate main word (if longer than just the placed tiles, it's extending an existing word)
        if (mainWord.length > tiles.length && !offlineWords.has(mainWord)) {
          allValid = false;
        }
        
        // SECOND: Check each placed tile for cross-words (perpendicular)
        if (allValid) {
          for (let i = 0; i < tiles.length; i++) {
            const r = direction === 'vertical' ? startRow + i : startRow;
            const c = direction === 'horizontal' ? startCol + i : startCol;
            
            // Check perpendicular direction
            let crossWord = '';
            if (direction === 'horizontal') {
              // Check vertical cross-word
              let startR = r;
              let endR = r;
              
              // Find start of word
              while (startR > 0 && this.board[startR - 1][c]) {
                startR--;
              }
              
              // Find end of word
              while (endR < 14 && this.board[endR + 1][c]) {
                endR++;
              }
              
              // Build word
              if (startR !== endR) { // There's a cross-word
                for (let row = startR; row <= endR; row++) {
                  crossWord += this.board[row][c].letter;
                }
              }
            } else {
              // Check horizontal cross-word
              let startC = c;
              let endC = c;
              
              // Find start of word
              while (startC > 0 && this.board[r][startC - 1]) {
                startC--;
              }
              
              // Find end of word
              while (endC < 14 && this.board[r][endC + 1]) {
                endC++;
              }
              
              // Build word
              if (startC !== endC) { // There's a cross-word
                for (let col = startC; col <= endC; col++) {
                  crossWord += this.board[r][col].letter;
                }
              }
            }
            
            // Validate cross-word if it exists and is more than 1 letter
            if (crossWord.length > 1 && !offlineWords.has(crossWord)) {
              allValid = false;
              break;
            }
          }
        }
        
        // Remove temporary placements
        for (const {r, c} of tempPlacements) {
          this.board[r][c] = null;
        }
        
        return allValid;
      }

      getPermutations(tiles, length) {
        if (length === 0) return [[]];
        if (tiles.length === 0) return [];
        if (length > tiles.length) return [];
        
        const result = [];
        
        for (let i = 0; i < tiles.length; i++) {
          const current = tiles[i];
          const remaining = [...tiles.slice(0, i), ...tiles.slice(i + 1)];
          const perms = this.getPermutations(remaining, length - 1);
          
          for (const perm of perms) {
            result.push([current, ...perm]);
          }
        }
        
        return result;
      }

      calculateAiScore(tiles, row, col, direction) {
        let score = 0;
        let wordMultiplier = 1;

        tiles.forEach((tile, i) => {
          const r = direction === 'vertical' ? row + i : row;
          const c = direction === 'horizontal' ? col + i : col;
          
          let letterScore = tile.points;
          
          if (PREMIUM_SQUARES.dls.some(([pr, pc]) => pr === r && pc === c)) {
            letterScore *= 2;
          } else if (PREMIUM_SQUARES.tls.some(([pr, pc]) => pr === r && pc === c)) {
            letterScore *= 3;
          }

          score += letterScore;

          if (PREMIUM_SQUARES.dws.some(([pr, pc]) => pr === r && pc === c)) {
            wordMultiplier *= 2;
          } else if (PREMIUM_SQUARES.tws.some(([pr, pc]) => pr === r && pc === c)) {
            wordMultiplier *= 3;
          }
        });

        score *= wordMultiplier;

        if (tiles.length === 7) {
          score += 50;
        }

        return score;
      }

      passTurn() {
        // Check if it's our turn in online mode
        if (this.gameMode === 'online' && this.currentTurn !== onlinePlayerRole) {
          this.showMessage("Wait for opponent's turn");
          return;
        }
        
        // Recall any placed tiles before passing
        this.recallTiles();
        
        this.consecutivePasses++;
        
        // Send pass to opponent in online mode
        if (this.gameMode === 'online') {
          sendMove({ type: 'pass' });
        }
        
        const playerName = this.currentTurn === 'player' ? 
          (this.gameMode === 'human' ? player1Name : this.gameMode === 'online' ? 'You' : 'You') : 
          (this.gameMode === 'human' ? player2Name : this.gameMode === 'online' ? 'You' : 'AI');
        this.showMessage(`${playerName} passed their turn`);
        
        if (this.consecutivePasses >= 4) {
          this.endGame();
          return;
        }

        this.currentTurn = this.currentTurn === 'player' ? 'ai' : 'player';
        this.updateTurnIndicator();
        
        if (this.gameMode === 'ai' && this.currentTurn === 'ai') {
          setTimeout(() => this.aiTurn(), 1500);
        } else if (this.gameMode === 'human') {
          const nextPlayer = this.currentTurn === 'player' ? player1Name : player2Name;
          const message = nextPlayer === 'You' ? 'Your turn' : `${nextPlayer}'s turn`;
          this.showMessage(message);
          this.showTurnTransition();
        } else if (this.gameMode === 'online') {
          if (this.currentTurn === onlinePlayerRole) {
            this.showMessage('Your turn!');
            this.renderRack();
          } else {
            this.showMessage("Opponent's turn...");
          }
        }
      }

      endGame() {
        // Play game over sound
        SFX.gameOver();
        
        let winner;
        let p1Name, p2Name;
        
        if (this.gameMode === 'human') {
          p1Name = player1Name;
          p2Name = player2Name;
          winner = this.playerScore > this.aiScore ? `${p1Name} wins!` : 
                  this.aiScore > this.playerScore ? `${p2Name} wins!` : 
                  'It\'s a tie!';
        } else {
          p1Name = 'You';
          p2Name = 'AI';
          winner = this.playerScore > this.aiScore ? 'You win!' : 
                  this.aiScore > this.playerScore ? 'AI wins!' : 
                  'It\'s a tie!';
        }
        
        this.showMessage(`Game Over! ${winner} Final scores - ${p1Name}: ${this.playerScore}, ${p2Name}: ${this.aiScore}`);
        
        // Save game result to Firebase (only for AI games)
        if (this.mode === 'ai' && currentUser) {
          const playerWon = this.playerScore > this.aiScore;
          saveGameResult(playerWon, this.playerScore, this.aiScore);
        }
        
        // Show play again button
        const playAgainBtn = document.createElement('button');
        playAgainBtn.className = 'btn-primary';
        playAgainBtn.textContent = 'Play Again';
        playAgainBtn.style.marginTop = '20px';
        playAgainBtn.onclick = () => location.reload();
        
        const messageEl = document.getElementById('message');
        messageEl.appendChild(document.createElement('br'));
        messageEl.appendChild(playAgainBtn);
        
        // Disable game controls
        document.getElementById('playBtn').disabled = true;
        document.getElementById('shuffleBtn').disabled = true;
        document.getElementById('recallBtn').disabled = true;
        document.getElementById('passBtn').disabled = true;
      }

      shuffleRack() {
        SFX.shuffle();
        this.playerRack = this.shuffle(this.playerRack);
        this.renderRack();
      }

      updateScores() {
        document.getElementById('playerScore').textContent = this.playerScore;
        document.getElementById('aiScore').textContent = this.aiScore;
      }

      updateInfo() {
        document.getElementById('tilesRemaining').textContent = this.tileBag.length;
      }

      updateTurnIndicator() {
        document.getElementById('turnIndicator').textContent = this.currentTurn === 'player' ? 'âœ“' : 'âœ—';
        
        const playerCard = document.getElementById('playerScoreCard');
        const aiCard = document.getElementById('aiScoreCard');
        
        // Remove all animation classes first
        playerCard.classList.remove('active', 'inactive', 'turn-flip');
        aiCard.classList.remove('active', 'inactive', 'turn-flip');
        
        // Force reflow to restart animation
        void playerCard.offsetWidth;
        void aiCard.offsetWidth;
        
        // Add classes with animation
        if (this.currentTurn === 'player') {
          playerCard.classList.add('active', 'turn-flip');
          aiCard.classList.add('inactive');
        } else {
          aiCard.classList.add('active', 'turn-flip');
          playerCard.classList.add('inactive');
        }
      }

      showMessage(text) {
        document.getElementById('message').textContent = text;
      }

      setupEventListeners() {
        document.getElementById('playBtn').addEventListener('click', () => this.playWord());
        document.getElementById('shuffleBtn').addEventListener('click', () => this.shuffleRack());
        document.getElementById('recallBtn').addEventListener('click', () => this.recallTiles());
        document.getElementById('passBtn').addEventListener('click', () => this.passTurn());
      }

      // Online multiplayer methods
      applyRemoteMove(data) {
        // Clear opponent preview tiles since they're now playing
        this.opponentPreviewTiles = [];
        
        // Apply opponent's move to our board
        data.tiles.forEach(({letter, points, row, col}) => {
          this.board[row][col] = {letter, points};
        });

        // Update opponent's score
        if (this.currentTurn === 'player') {
          this.playerScore += data.score;
        } else {
          this.aiScore += data.score;
        }

        // Draw new tiles for opponent (but we don't know what they are)
        // Just track that opponent drew some tiles
        const tilesDrawn = data.newTilesCount || 0;

        this.firstMove = false;
        this.consecutivePasses = 0;
        
        this.showMessage(`Opponent played "${data.word}" for ${data.score} points!`);
        
        // Switch turn FIRST
        this.currentTurn = this.currentTurn === 'player' ? 'ai' : 'player';
        
        // Update UI - CRITICAL: Force re-render
        this.updateScores();
        this.renderBoard(); // Render board with opponent's tiles
        this.updateTurnIndicator();
        
        if (this.currentTurn === onlinePlayerRole) {
          this.showMessage('Your turn!');
          this.renderRack(); // Render our rack
        } else {
          this.showMessage("Opponent's turn...");
        }
        
        // Save game state to database
        this.saveGameState();
      }

      applyRemotePass() {
        this.consecutivePasses++;
        this.showMessage('Opponent passed their turn');
        
        if (this.consecutivePasses >= 4) {
          this.endGame();
          return;
        }
        
        // Switch turn
        this.currentTurn = this.currentTurn === 'player' ? 'ai' : 'player';
        
        // Update UI - CRITICAL: Force re-render after pass
        this.updateScores();
        this.renderBoard(); // Re-render board
        this.updateTurnIndicator();
        
        if (this.currentTurn === onlinePlayerRole) {
          this.showMessage('Your turn!');
          this.renderRack(); // Render our rack
        } else {
          this.showMessage("Opponent's turn...");
        }
        
        // Save game state to database
        this.saveGameState();
      }

      // Handle opponent tile placement preview
      addOpponentPreviewTile(data) {
        this.opponentPreviewTiles.push({
          letter: data.letter,
          points: data.points,
          row: data.row,
          col: data.col
        });
        this.renderBoard();
      }

      // Handle opponent recalling tiles
      clearOpponentPreviewTiles(positions) {
        if (positions && positions.length > 0) {
          // Remove specific positions
          this.opponentPreviewTiles = this.opponentPreviewTiles.filter(tile => {
            return !positions.some(pos => pos.row === tile.row && pos.col === tile.col);
          });
        } else {
          // Clear all
          this.opponentPreviewTiles = [];
        }
        this.renderBoard();
      }
      
      // ============================================
      // GAME STATE MANAGEMENT (v1.6.3 - Rejoin System)
      // ============================================
      
      async saveGameState() {
        if (this.mode !== 'online' || !currentGameId) return;
        
        try {
          const gameState = {
            board: this.board,
            playerScore: this.playerScore,
            aiScore: this.aiScore,
            bag: this.bag,
            firstMove: this.firstMove,
            consecutivePasses: this.consecutivePasses,
            gameOver: this.gameOver,
            // Don't save racks - they're private to each player
            player1Name: player1Name,
            player2Name: player2Name
          };
          
          const currentTurnPlayer = this.currentTurn === 'player' ? 'host' : 'guest';
          
          const { error } = await window.supabase
            .from('games')
            .update({
              game_state: gameState,
              current_turn: currentTurnPlayer,
              last_update: new Date().toISOString()
            })
            .eq('id', currentGameId);
          
          if (error) {
            console.error('Error saving game state:', error);
          }
        } catch (error) {
          console.error('Error saving game state:', error);
        }
      }
      
      async loadGameState(gameId) {
        try {
          const { data, error } = await window.supabase
            .from('games')
            .select('*')
            .eq('id', gameId)
            .single();
          
          if (error) throw error;
          
          if (data && data.game_state) {
            const state = data.game_state;
            this.board = state.board || this.board;
            this.playerScore = state.playerScore || 0;
            this.aiScore = state.aiScore || 0;
            this.bag = state.bag || this.bag;
            this.firstMove = state.firstMove !== undefined ? state.firstMove : true;
            this.consecutivePasses = state.consecutivePasses || 0;
            this.gameOver = state.gameOver || false;
            
            // Restore turn
            this.currentTurn = data.current_turn === 'host' ? 'player' : 'ai';
            
            // Re-render everything
            this.renderBoard();
            this.updateScores();
            this.updateTurnIndicator();
            this.renderRack();
            
            console.log('âœ… Game state loaded');
            return true;
          }
          
          return false;
        } catch (error) {
          console.error('Error loading game state:', error);
          return false;
        }
      }
    }

    // ============================================
    // GAME RECONNECTION SYSTEM (v1.6.3)
    // ============================================
    
    let currentGameId = null;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 3;
    
    async function createGameRecord() {
      if (!currentUser) return null;
      
      try {
        const { data, error } = await window.supabase
          .from('games')
          .insert({
            host_id: currentUser.id,
            host_peer_id: myGameCode,
            status: 'waiting',
            host_connected: true,
            game_state: {}
          })
          .select()
          .single();
        
        if (error) throw error;
        
        currentGameId = data.id;
        console.log('âœ… Game record created:', currentGameId);
        return data.id;
      } catch (error) {
        console.error('Error creating game record:', error);
        return null;
      }
    }
    
    async function updateGameRecord(updates) {
      if (!currentGameId) return;
      
      try {
        const { error } = await window.supabase
          .from('games')
          .update({
            ...updates,
            last_update: new Date().toISOString()
          })
          .eq('id', currentGameId);
        
        if (error) throw error;
      } catch (error) {
        console.error('Error updating game record:', error);
      }
    }
    
    async function markDisconnected(playerRole) {
      if (!currentGameId) return;
      
      try {
        const updates = {
          status: 'disconnected',
          disconnected_player: playerRole,
          disconnect_timestamp: new Date().toISOString()
        };
        
        if (playerRole === 'host') {
          updates.host_connected = false;
        } else {
          updates.guest_connected = false;
        }
        
        await updateGameRecord(updates);
        console.log('ðŸ”Œ Marked as disconnected:', playerRole);
      } catch (error) {
        console.error('Error marking disconnected:', error);
      }
    }
    
    async function checkForRejoinableGame() {
      if (!currentUser) return null;
      
      try {
        // Look for active or disconnected games where user is a player
        const { data, error } = await window.supabase
          .from('games')
          .select('*')
          .or(`host_id.eq.${currentUser.id},guest_id.eq.${currentUser.id}`)
          .in('status', ['active', 'disconnected'])
          .order('last_update', { ascending: false })
          .limit(1);
        
        if (error) throw error;
        
        if (data && data.length > 0) {
          const game = data[0];
          
          // Check if within 5-minute rejoin window
          const disconnectTime = new Date(game.disconnect_timestamp || game.last_update);
          const now = new Date();
          const minutesElapsed = (now - disconnectTime) / 1000 / 60;
          
          if (minutesElapsed < 5) {
            return game;
          } else {
            // Game expired, mark as forfeited
            await window.supabase
              .from('games')
              .update({ status: 'forfeited' })
              .eq('id', game.id);
            
            return null;
          }
        }
        
        return null;
      } catch (error) {
        console.error('Error checking for rejoinable game:', error);
        return null;
      }
    }
    
    async function rejoinGame(gameData) {
      try {
        currentGameId = gameData.id;
        const isHost = gameData.host_id === currentUser.id;
        const playerRole = isHost ? 'host' : 'guest';
        
        // Update connection status
        const updates = {
          status: 'active',
          disconnected_player: null,
          disconnect_timestamp: null
        };
        
        if (isHost) {
          updates.host_connected = true;
        } else {
          updates.guest_connected = true;
        }
        
        await updateGameRecord(updates);
        
        // Reconnect to peer
        const opponentPeerId = isHost ? gameData.guest_peer_id : gameData.host_peer_id;
        
        if (opponentPeerId) {
          // Initialize new peer
          peer = new Peer();
          
          peer.on('open', (newId) => {
            // Update our peer ID in database
            const peerUpdate = isHost ? { host_peer_id: newId } : { guest_peer_id: newId };
            updateGameRecord(peerUpdate);
            
            // Try to connect to opponent
            connection = peer.connect(opponentPeerId);
            
            connection.on('open', () => {
              console.log('âœ… Reconnected to opponent');
              setupConnection();
              
              // Notify opponent of reconnection
              connection.send({
                type: 'reconnect',
                playerRole: playerRole
              });
              
              // Load game state and resume
              if (game) {
                game.loadGameState(currentGameId);
              }
            });
          });
        }
        
        console.log('âœ… Rejoined game:', currentGameId);
        return true;
      } catch (error) {
        console.error('Error rejoining game:', error);
        return false;
      }
    }

    // ============================================
    // ADMIN PANEL FUNCTIONS (v1.4.0)
    // ============================================
    
    let currentBanUserId = null;
    let currentBanUsername = null;

    function openAdminPanel() {
      const panel = document.getElementById('adminPanel');
      panel.style.display = 'flex';
      
      // Show admins tab only for super admin
      if (currentUser && currentUser.role === 'super_admin') {
        document.getElementById('tabAdmins').style.display = 'block';
      }
      
      // Load data for current tab
      switchAdminTab('players');
    }

    function closeAdminPanel() {
      document.getElementById('adminPanel').style.display = 'none';
    }

    function switchAdminTab(tab) {
      // Update tab buttons
      document.querySelectorAll('.admin-tab').forEach(btn => {
        btn.classList.remove('active-admin-tab');
      });
      document.getElementById('tab' + tab.charAt(0).toUpperCase() + tab.slice(1)).classList.add('active-admin-tab');
      
      // Update content
      document.querySelectorAll('.admin-tab-content').forEach(content => {
        content.style.display = 'none';
      });
      document.getElementById('adminTab' + tab.charAt(0).toUpperCase() + tab.slice(1)).style.display = 'block';
      
      // Load data for the tab
      if (tab === 'banned') {
        loadBannedPlayers();
      } else if (tab === 'warnings') {
        loadWarnings();
      } else if (tab === 'admins') {
        loadAdmins();
      }
    }

    async function searchPlayers() {
      const searchTerm = document.getElementById('adminSearchInput').value.trim().toLowerCase();
      const resultsDiv = document.getElementById('adminSearchResults');
      
      if (!searchTerm) {
        resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">Enter a username or email to search</div>';
        return;
      }
      
      resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">Searching...</div>';
      
      try {
        const usersRef = firebase.database().ref('users');
        const snapshot = await usersRef.once('value');
        const users = snapshot.val();
        
        if (!users) {
          resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">No players found</div>';
          return;
        }
        
        // Filter users by search term (client-side)
        const matchedUsers = Object.entries(users).filter(([uid, user]) => {
          const username = (user.username || '').toLowerCase();
          const email = (user.email || '').toLowerCase();
          return username.includes(searchTerm) || email.includes(searchTerm);
        });
        
        if (matchedUsers.length === 0) {
          resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">No players found matching "' + searchTerm + '"</div>';
          return;
        }
        
        // Display results
        let html = '';
        for (const [uid, user] of matchedUsers) {
          const isBanned = user.status === 'banned';
          const isWarned = user.status === 'warned';
          const isAdmin = user.role === 'admin' || user.role === 'super_admin';
          const isSuperAdmin = user.role === 'super_admin';
          const isCurrentUser = uid === currentUser.uid;
          
          let statusIcon = 'âœ…';
          let cardClass = 'player-card';
          if (isBanned) {
            statusIcon = 'ðŸš«';
            cardClass += ' banned';
          } else if (isWarned) {
            statusIcon = 'âš ï¸';
            cardClass += ' warned';
          }
          
          html += `
            <div class="${cardClass}">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                <div style="flex: 1;">
                  <div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 5px;">
                    ${statusIcon} ${user.username || 'Unknown'}
                    ${isSuperAdmin ? '<span style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">SUPER ADMIN</span>' : ''}
                    ${isAdmin && !isSuperAdmin ? '<span style="background: #9b59b6; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">ADMIN</span>' : ''}
                  </div>
                  <div style="color: #7f8c8d; font-size: 13px;">
                    ${user.email || 'No email'}
                  </div>
                  <div style="color: #7f8c8d; font-size: 13px; margin-top: 5px;">
                    Games: ${user.gamesPlayed || 0} | Wins: ${user.wins || 0} | Rating: ${user.rating || 1000}
                  </div>
                </div>
              </div>
              
              ${isBanned && user.banReason ? `
                <div style="background: #ffebee; border-left: 4px solid #e74c3c; padding: 12px; margin-bottom: 12px; border-radius: 4px;">
                  <strong style="color: #c0392b;">Ban Reason:</strong> ${user.banReason}
                  <br>
                  <strong style="color: #c0392b;">Duration:</strong> ${user.banPermanent ? 'Permanent' : formatDuration(user.banDuration)}
                </div>
              ` : ''}
              
              ${isWarned && user.warnReason ? `
                <div style="background: #fff3cd; border-left: 4px solid #f39c12; padding: 12px; margin-bottom: 12px; border-radius: 4px;">
                  <strong style="color: #e67e22;">Warning:</strong> ${user.warnReason}
                </div>
              ` : ''}
              
              <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                ${!isBanned && !isCurrentUser ? '<button class="admin-action-btn btn-warn" onclick="warnPlayer(\'' + uid + '\', \'' + (user.username || 'Unknown') + '\')">âš ï¸ Warn</button>' : ''}
                ${!isBanned && !isCurrentUser ? '<button class="admin-action-btn btn-ban" onclick="showBanDialog(\'' + uid + '\', \'' + (user.username || 'Unknown') + '\')">ðŸš« Ban</button>' : ''}
                ${isBanned ? '<button class="admin-action-btn btn-unban" onclick="unbanPlayer(\'' + uid + '\', \'' + (user.username || 'Unknown') + '\')">âœ… Unban</button>' : ''}
                ${!isAdmin && !isCurrentUser && currentUser.role === 'super_admin' ? '<button class="admin-action-btn btn-make-admin" onclick="makeAdmin(\'' + uid + '\', \'' + (user.username || 'Unknown') + '\')">ðŸ‘® Make Admin</button>' : ''}
                ${isAdmin && !isSuperAdmin && currentUser.role === 'super_admin' ? '<button class="admin-action-btn btn-remove-admin" onclick="removeAdmin(\'' + uid + '\', \'' + (user.username || 'Unknown') + '\')">Remove Admin</button>' : ''}
              </div>
            </div>
          `;
        }
        
        resultsDiv.innerHTML = html;
        
      } catch (error) {
        console.error('Search error:', error);
        resultsDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #e74c3c;">Error searching players</div>';
      }
    }

    function formatDuration(ms) {
      const hours = Math.floor(ms / (1000 * 60 * 60));
      const days = Math.floor(hours / 24);
      
      if (days > 0) return days + ' day' + (days > 1 ? 's' : '');
      if (hours > 0) return hours + ' hour' + (hours > 1 ? 's' : '');
      return 'Less than 1 hour';
    }

    function formatTimeRemaining(expiresAt) {
      const now = Date.now();
      const remaining = expiresAt - now;
      
      if (remaining <= 0) return 'Expired';
      
      const days = Math.floor(remaining / (1000 * 60 * 60 * 24));
      const hours = Math.floor((remaining % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
      
      if (days > 0) return `${days}d ${hours}h remaining`;
      if (hours > 0) return `${hours}h ${minutes}m remaining`;
      return `${minutes}m remaining`;
    }

    async function warnPlayer(userId, username) {
      const reason = prompt(`Enter warning reason for ${username}:`);
      if (!reason || !reason.trim()) return;
      
      try {
        const timestamp = Date.now();
        
        // Update user status
        await firebase.database().ref(`users/${userId}`).update({
          status: 'warned',
          warnReason: reason,
          warnedAt: timestamp,
          warnedBy: currentUser.uid
        });
        
        // Log warning in moderation
        await firebase.database().ref('moderation/warnings').push({
          userId: userId,
          username: username,
          reason: reason,
          warnedBy: currentUser.uid,
          warnedByName: currentUser.username,
          timestamp: timestamp
        });
        
        // Log admin action
        await logAdminAction('warn', userId, username, reason);
        
        alert(`${username} has been warned.`);
        searchPlayers(); // Refresh results
        
      } catch (error) {
        console.error('Warn error:', error);
        alert('Error warning player: ' + error.message);
      }
    }

    function showBanDialog(userId, username) {
      currentBanUserId = userId;
      currentBanUsername = username;
      
      document.getElementById('banPlayerName').textContent = username;
      document.getElementById('banReason').value = '';
      document.getElementById('banDuration').value = '604800000'; // Default 7 days
      document.getElementById('banDialog').style.display = 'flex';
    }

    function closeBanDialog() {
      document.getElementById('banDialog').style.display = 'none';
      currentBanUserId = null;
      currentBanUsername = null;
    }

    async function confirmBanFromDialog() {
      const reason = document.getElementById('banReason').value.trim();
      const durationValue = document.getElementById('banDuration').value;
      
      if (!reason) {
        alert('Please enter a reason for the ban.');
        return;
      }
      
      const isPermanent = durationValue === 'permanent';
      const duration = isPermanent ? null : parseInt(durationValue);
      
      try {
        const timestamp = Date.now();
        const expiresAt = isPermanent ? null : timestamp + duration;
        
        // Update user status
        const updates = {
          status: 'banned',
          banReason: reason,
          bannedAt: timestamp,
          bannedBy: currentUser.uid,
          banPermanent: isPermanent
        };
        
        if (!isPermanent) {
          updates.banDuration = duration;
          updates.banExpiresAt = expiresAt;
        }
        
        await firebase.database().ref(`users/${currentBanUserId}`).update(updates);
        
        // Log ban in moderation
        const banData = {
          userId: currentBanUserId,
          username: currentBanUsername,
          reason: reason,
          bannedBy: currentUser.uid,
          bannedByName: currentUser.username,
          timestamp: timestamp,
          permanent: isPermanent
        };
        
        if (!isPermanent) {
          banData.duration = duration;
          banData.expiresAt = expiresAt;
        }
        
        await firebase.database().ref(`moderation/bans/${currentBanUserId}`).set(banData);
        
        // Log admin action
        await logAdminAction('ban', currentBanUserId, currentBanUsername, reason);
        
        alert(`${currentBanUsername} has been banned.`);
        closeBanDialog();
        searchPlayers(); // Refresh results
        
      } catch (error) {
        console.error('Ban error:', error);
        alert('Error banning player: ' + error.message);
      }
    }

    async function unbanPlayer(userId, username) {
      if (!confirm(`Are you sure you want to unban ${username}?`)) return;
      
      try {
        // Update user status
        await firebase.database().ref(`users/${userId}`).update({
          status: 'active',
          banReason: null,
          bannedAt: null,
          bannedBy: null,
          banDuration: null,
          banExpiresAt: null,
          banPermanent: null
        });
        
        // Remove from moderation/bans
        await firebase.database().ref(`moderation/bans/${userId}`).remove();
        
        // Log admin action
        await logAdminAction('unban', userId, username, 'Unbanned by admin');
        
        alert(`${username} has been unbanned.`);
        searchPlayers(); // Refresh results
        loadBannedPlayers(); // Refresh banned list if on that tab
        
      } catch (error) {
        console.error('Unban error:', error);
        alert('Error unbanning player: ' + error.message);
      }
    }

    async function makeAdmin(userId, username) {
      if (!confirm(`Make ${username} an admin? They will have moderation powers.`)) return;
      
      try {
        // Update user role
        await firebase.database().ref(`users/${userId}`).update({
          role: 'admin'
        });
        
        // Add to admins collection
        await firebase.database().ref(`admins/${userId}`).set({
          userId: userId,
          username: username,
          role: 'admin',
          madeAdminBy: currentUser.uid,
          timestamp: Date.now()
        });
        
        // Log admin action
        await logAdminAction('make_admin', userId, username, 'Made admin');
        
        alert(`${username} is now an admin.`);
        searchPlayers(); // Refresh results
        
      } catch (error) {
        console.error('Make admin error:', error);
        alert('Error making admin: ' + error.message);
      }
    }

    async function removeAdmin(userId, username) {
      if (!confirm(`Remove admin status from ${username}?`)) return;
      
      try {
        // Update user role
        await firebase.database().ref(`users/${userId}`).update({
          role: 'player'
        });
        
        // Remove from admins collection
        await firebase.database().ref(`admins/${userId}`).remove();
        
        // Log admin action
        await logAdminAction('remove_admin', userId, username, 'Removed admin status');
        
        alert(`${username} is no longer an admin.`);
        searchPlayers(); // Refresh results
        loadAdmins(); // Refresh admins list
        
      } catch (error) {
        console.error('Remove admin error:', error);
        alert('Error removing admin: ' + error.message);
      }
    }

    async function loadBannedPlayers() {
      const listDiv = document.getElementById('bannedPlayersList');
      listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">Loading...</div>';
      
      try {
        const snapshot = await firebase.database().ref('moderation/bans').once('value');
        const bans = snapshot.val();
        
        if (!bans || Object.keys(bans).length === 0) {
          listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">No banned players</div>';
          return;
        }
        
        let html = '';
        const now = Date.now();
        
        for (const [userId, ban] of Object.entries(bans)) {
          const isExpired = !ban.permanent && ban.expiresAt && ban.expiresAt < now;
          const remainingTime = !ban.permanent && ban.expiresAt ? formatTimeRemaining(ban.expiresAt) : null;
          
          let durationBadge = '';
          if (ban.permanent) {
            durationBadge = '<span style="background: #e74c3c; color: white; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600;">âˆž PERMANENT</span>';
          } else if (isExpired) {
            durationBadge = '<span style="background: #27ae60; color: white; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600;">âœ“ EXPIRED</span>';
          } else {
            durationBadge = `<span style="background: #f39c12; color: white; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600;">${formatDuration(ban.duration)}</span>`;
          }
          
          html += `
            <div class="player-card banned">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                <div style="flex: 1;">
                  <div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 8px;">
                    ðŸš« ${ban.username}
                  </div>
                  <div style="color: #7f8c8d; font-size: 13px; margin-bottom: 5px;">
                    Banned by: ${ban.bannedByName || 'Unknown'}
                  </div>
                  <div style="color: #7f8c8d; font-size: 13px; margin-bottom: 8px;">
                    Date: ${new Date(ban.timestamp).toLocaleDateString()}
                  </div>
                  <div style="margin-bottom: 8px;">
                    ${durationBadge}
                  </div>
                  ${remainingTime && !isExpired ? `
                    <div style="background: #fff3cd; padding: 8px 12px; border-radius: 6px; font-size: 13px; margin-bottom: 10px;">
                      â±ï¸ <strong>${remainingTime}</strong>
                    </div>
                  ` : ''}
                  ${isExpired ? `
                    <div style="background: #d4edda; padding: 8px 12px; border-radius: 6px; font-size: 13px; margin-bottom: 10px; color: #155724;">
                      âœ“ Ban expired - will auto-unban on next login
                    </div>
                  ` : ''}
                </div>
              </div>
              
              <div style="background: #fff; border-left: 4px solid #e74c3c; padding: 12px; margin-bottom: 12px; border-radius: 4px;">
                <strong style="color: #c0392b;">Reason:</strong> ${ban.reason}
              </div>
              
              <button class="admin-action-btn btn-unban" onclick="unbanPlayer('${userId}', '${ban.username}')">
                âœ… Unban Player
              </button>
            </div>
          `;
        }
        
        listDiv.innerHTML = html;
        
      } catch (error) {
        console.error('Load banned players error:', error);
        listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #e74c3c;">Error loading banned players</div>';
      }
    }

    async function loadWarnings() {
      const listDiv = document.getElementById('warningsList');
      listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">Loading...</div>';
      
      try {
        const snapshot = await firebase.database().ref('moderation/warnings').once('value');
        const warnings = snapshot.val();
        
        if (!warnings || Object.keys(warnings).length === 0) {
          listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">No warnings issued</div>';
          return;
        }
        
        let html = '';
        
        // Convert to array and sort by timestamp (newest first)
        const warningsArray = Object.entries(warnings).map(([id, warning]) => ({id, ...warning}));
        warningsArray.sort((a, b) => b.timestamp - a.timestamp);
        
        for (const warning of warningsArray) {
          html += `
            <div style="
              background: #fff3cd;
              padding: 20px;
              border-radius: 12px;
              margin-bottom: 15px;
              border-left: 4px solid #f39c12;
            ">
              <div style="font-size: 18px; font-weight: 600; color: #e67e22; margin-bottom: 8px;">
                âš ï¸ ${warning.username}
              </div>
              <div style="color: #7f8c8d; font-size: 13px; margin-bottom: 5px;">
                Warned by: ${warning.warnedByName || 'Unknown'}
              </div>
              <div style="color: #7f8c8d; font-size: 13px; margin-bottom: 12px;">
                Date: ${new Date(warning.timestamp).toLocaleString()}
              </div>
              <div style="background: #fff; border-left: 4px solid #f39c12; padding: 12px; border-radius: 4px;">
                <strong style="color: #e67e22;">Reason:</strong> ${warning.reason}
              </div>
            </div>
          `;
        }
        
        listDiv.innerHTML = html;
        
      } catch (error) {
        console.error('Load warnings error:', error);
        listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #e74c3c;">Error loading warnings</div>';
      }
    }

    async function loadAdmins() {
      const listDiv = document.getElementById('adminsList');
      listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;">Loading...</div>';
      
      try {
        const snapshot = await firebase.database().ref('admins').once('value');
        const admins = snapshot.val();
        
        let html = '';
        
        // Show Super Admin first (permanent)
        html += `
          <div class="player-card" style="border-left-color: #e74c3c;">
            <div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 8px;">
              ðŸ‘® Admin (Super Admin)
              <span style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">PERMANENT</span>
            </div>
            <div style="color: #7f8c8d; font-size: 13px;">
              Cannot be removed - System Administrator
            </div>
          </div>
        `;
        
        // Show other admins
        if (admins && Object.keys(admins).length > 0) {
          for (const [userId, admin] of Object.entries(admins)) {
            if (admin.role === 'super_admin') continue; // Skip super admin, already shown
            
            html += `
              <div class="player-card" style="border-left-color: #9b59b6;">
                <div style="display: flex; justify-content: space-between; align-items: start;">
                  <div style="flex: 1;">
                    <div style="font-size: 18px; font-weight: 600; color: #2c3e50; margin-bottom: 8px;">
                      ðŸ‘® ${admin.username}
                      <span style="background: #9b59b6; color: white; padding: 3px 8px; border-radius: 4px; font-size: 11px; margin-left: 8px;">ADMIN</span>
                    </div>
                    <div style="color: #7f8c8d; font-size: 13px;">
                      Made admin: ${new Date(admin.timestamp).toLocaleDateString()}
                    </div>
                  </div>
                </div>
                <div style="margin-top: 12px;">
                  <button class="admin-action-btn btn-remove-admin" onclick="removeAdmin('${userId}', '${admin.username}')">
                    Remove Admin Status
                  </button>
                </div>
              </div>
            `;
          }
        } else {
          html += '<div style="text-align: center; padding: 20px; color: #7f8c8d;">No other admins</div>';
        }
        
        listDiv.innerHTML = html;
        
      } catch (error) {
        console.error('Load admins error:', error);
        listDiv.innerHTML = '<div style="text-align: center; padding: 40px; color: #e74c3c;">Error loading admins</div>';
      }
    }

    async function logAdminAction(action, targetUserId, targetUsername, reason) {
      try {
        await firebase.database().ref('moderation/adminActions').push({
          adminId: currentUser.uid,
          adminName: currentUser.username,
          action: action,
          targetUserId: targetUserId,
          targetUsername: targetUsername,
          reason: reason,
          timestamp: Date.now()
        });
      } catch (error) {
        console.error('Log admin action error:', error);
      }
    }

    async function checkBanStatus() {
      if (!currentUser) return true; // Allow if no user
      
      try {
        const { data: userData, error } = await supabase
          .from('users')
          .select('*')
          .eq('id', currentUser.id)
          .single();
        
        if (error || !userData || userData.status !== 'banned') {
          return true; // Not banned, allow access
        }
        
        // Check if temporary ban has expired
        if (!userData.ban_permanent && userData.ban_expires_at) {
          if (Date.now() >= userData.ban_expires_at) {
            // Ban expired, auto-unban
            await supabase
              .from('users')
              .update({
                status: 'active',
                ban_reason: null,
                banned_at: null,
                banned_by: null,
                ban_duration: null,
                ban_expires_at: null,
                ban_permanent: null
              })
              .eq('id', currentUser.id);
            
            // Remove from bans table
            await supabase
              .from('bans')
              .delete()
              .eq('user_id', currentUser.id);
            
            alert('Your ban has expired. Welcome back!');
            return true; // Allow access
          }
        }
        
        // User is banned, show ban screen
        showBanScreen(userData);
        return false;
        
      } catch (error) {
        console.error('Check ban status error:', error);
        return true; // Allow on error
      }
    }

    function showBanScreen(userData) {
      // Hide all other interfaces
      document.getElementById('authContainer').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('gameBoard').style.display = 'none';
      document.getElementById('settingsBtn').style.display = 'none';
      document.getElementById('adminPanelBtn').style.display = 'none';
      
      // Create and show ban screen
      let banScreen = document.getElementById('banScreen');
      if (!banScreen) {
        banScreen = document.createElement('div');
        banScreen.id = 'banScreen';
        document.body.appendChild(banScreen);
      }
      
      const isPermanent = userData.ban_permanent;
      const remainingTime = !isPermanent && userData.ban_expires_at ? formatTimeRemaining(userData.ban_expires_at) : null;
      
      banScreen.innerHTML = `
        <div style="
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 20000;
        ">
          <div style="
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          ">
            <div style="font-size: 80px; margin-bottom: 20px;">ðŸš«</div>
            <h2 style="margin: 0 0 20px 0; color: #e74c3c; font-size: 28px;">
              Account ${isPermanent ? 'Permanently ' : 'Temporarily '}Banned
            </h2>
            
            <div style="background: #ffebee; border-left: 4px solid #e74c3c; padding: 20px; margin: 20px 0; border-radius: 8px; text-align: left;">
              <strong style="color: #c0392b; display: block; margin-bottom: 10px;">Reason:</strong>
              <div style="color: #2c3e50;">${userData.ban_reason || 'No reason provided'}</div>
            </div>
            
            ${!isPermanent && remainingTime ? `
              <div style="background: #fff3cd; border-left: 4px solid #f39c12; padding: 20px; margin: 20px 0; border-radius: 8px;">
                <strong style="color: #e67e22; display: block; margin-bottom: 10px;">Time Remaining:</strong>
                <div style="font-size: 24px; font-weight: 600; color: #2c3e50;">${remainingTime}</div>
              </div>
            ` : ''}
            
            ${isPermanent ? `
              <p style="color: #7f8c8d; margin: 20px 0;">
                This ban is permanent. If you believe this is a mistake, please contact support.
              </p>
            ` : ''}
            
            <button onclick="handleLogout()" style="
              background: #95a5a6;
              color: white;
              border: none;
              padding: 15px 40px;
              border-radius: 8px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              margin-top: 20px;
              font-family: Georgia, 'Times New Roman', serif;
            ">
              Logout
            </button>
          </div>
        </div>
      `;
      
      banScreen.style.display = 'block';
    }

    // ============================================
    // END ADMIN PANEL FUNCTIONS
    // ============================================

    // ============================================
    // AUTH INITIALIZATION (at end so all functions exist)
    // ============================================
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('ðŸ” Initializing auth...');
      
      try {
        // Get initial session
        const { data: { session }, error } = await window.supabase.auth.getSession();
        
        console.log('ðŸ“¦ Session check:', session ? 'Found' : 'None', error ? 'Error: ' + error.message : '');
        
        if (session) {
          console.log('âœ… Existing session found for:', session.user.email);
          await handleAuthChange(session);
        } else {
          console.log('âŒ No session, showing auth');
          showAuthInterface();
        }
        
        // Listen for auth changes
        window.supabase.auth.onAuthStateChange(async (event, session) => {
          console.log('ðŸ” Auth event:', event, session ? session.user.email : 'no session');
          
          if (session) {
            await handleAuthChange(session);
          } else {
            currentUser = null;
            userStats = null;
            showAuthInterface();
          }
        });
        
        console.log('âœ… Auth initialization complete');
      } catch (error) {
        console.error('âŒ Auth initialization error:', error);
        showAuthInterface();
      }
    });

  </script>
  
  <!-- Theme Switcher UI (Hidden - now in Settings) -->
  <div class="theme-selector" style="display: none;">
    <button class="theme-toggle-btn" onclick="toggleThemeMenu()">
      <span class="theme-icon">ðŸŽ¨</span>
      <span class="theme-label">Themes</span>
    </button>
    <div class="theme-menu" id="theme-menu" style="display: none;">
      <div class="theme-menu-header">Choose Theme</div>
      <button class="theme-option active" onclick="switchTheme('light-luxury')">
        <span class="theme-option-icon">âœ¨</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Light Luxury</div>
          <div class="theme-option-desc">Clean white, gold accents, elegant</div>
        </div>
        <span class="theme-check">âœ“</span>
      </button>
      <button class="theme-option" onclick="switchTheme('dark-modern')">
        <span class="theme-option-icon">ðŸŒ™</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Dark Modern</div>
          <div class="theme-option-desc">Dark gradients, glowing tiles, futuristic</div>
        </div>
      </button>
      <button class="theme-option" onclick="switchTheme('classic-wood')">
        <span class="theme-option-icon">ðŸŽ¨</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Classic Wood</div>
          <div class="theme-option-desc">Wooden board, traditional aesthetic</div>
        </div>
      </button>
      <button class="theme-option" onclick="switchTheme('neon-gaming')">
        <span class="theme-option-icon">âš¡</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Neon Gaming</div>
          <div class="theme-option-desc">Cyberpunk neon, vibrant colors</div>
        </div>
      </button>
    </div>
  </div>
  
  <!-- Theme Switcher JavaScript -->
  <script>
    let currentTheme = localStorage.getItem('scrabble_theme') || 'light-luxury';
    
    // Apply saved theme on load
    document.body.className = 'theme-' + currentTheme;
    
    function toggleThemeMenu() {
      const menu = document.getElementById('theme-menu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
    
    function switchTheme(themeId) {
      // Update body class
      document.body.className = 'theme-' + themeId;
      
      // Save preference
      localStorage.setItem('scrabble_theme', themeId);
      currentTheme = themeId;
      
      // Update UI
      document.querySelectorAll('.theme-option').forEach(option => {
        option.classList.remove('active');
        const check = option.querySelector('.theme-check');
        if (check) check.remove();
      });
      
      const activeOption = event.target.closest('.theme-option');
      activeOption.classList.add('active');
      const checkmark = document.createElement('span');
      checkmark.className = 'theme-check';
      checkmark.textContent = 'âœ“';
      activeOption.appendChild(checkmark);
      
      // Close menu
      toggleThemeMenu();
      
      // Show message
      const messageEl = document.getElementById('message');
      if (messageEl) {
        const oldText = messageEl.textContent;
        const themeName = activeOptio
