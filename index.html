<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>Scrabble Game v3.0.1</title>
  <!-- Version: 3.0.1 | Date: December 27, 2025 | PATCH: Admin ELO testing tools -->
  <!-- Cache Buster: 20251227-0001 -->
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="Play Scrabble online with AI opponents or friends. Features 4 beautiful themes, multiplayer modes, and full SOWPODS dictionary.">
  <meta name="theme-color" content="#d4af37">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Scrabble">
  
  <style>
    :root {
      --board-bg: #e8d5b7;
      --tile-bg: #f4e8d0;
      --tile-shadow: rgba(139, 90, 43, 0.15);
      --text-dark: #3d2817;
      --accent: #8b5a2b;
      --star: #d4af37;
      --dls: #b8d4e8;
      --tls: #4a7ba7;
      --dws: #e8b8b8;
      --tws: #c85a54;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Georgia, 'Times New Roman', serif;
      background: linear-gradient(135deg, #f5ebe0 0%, #e3d5ca 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: var(--text-dark);
    }

    h1 {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 3.5rem;
      color: var(--accent);
      margin-bottom: 10px;
      letter-spacing: 2px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }

    .game-container {
      max-width: 1400px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 30px;
    }

    .scores {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      margin-bottom: 10px;
    }

    .score-card {
      background: var(--tile-bg);
      padding: 20px 40px;
      border-radius: 12px;
      box-shadow: 0 4px 12px var(--tile-shadow);
      transition: all 0.3s ease;
      text-align: center;
      border: 3px solid transparent;
    }

    .score-card.active {
      border: 3px solid var(--accent);
      background: linear-gradient(135deg, var(--tile-bg) 0%, rgba(244, 232, 208, 0.95) 100%);
      animation: highlightPlayer 1s ease-in-out;
    }

    .score-card.inactive {
      opacity: 0.6;
    }

    .score-label {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      opacity: 0.7;
      margin-bottom: 5px;
    }

    .score-value {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--accent);
      transition: all 0.3s ease;
    }

    .score-card.active .score-value {
      animation: letterPulse 1.5s ease-in-out infinite;
    }

    .board-container {
      display: flex;
      justify-content: center;
      gap: 30px;
      flex-wrap: wrap;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(15, 40px);
      grid-template-rows: repeat(15, 40px);
      gap: 2px;
      background: var(--accent);
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }

    .cell {
      width: 40px;
      height: 40px;
      background: var(--board-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      border-radius: 2px;
      color: rgba(0, 0, 0, 0.3); /* Default text color for empty cells */
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .cell:hover:not(.occupied) {
      background: #f0e0c8;
      transform: scale(1.05);
    }

    .cell.occupied {
      cursor: default;
    }

    .cell.preview {
      background: #d4e8d4;
    }

    .cell.star {
      background: var(--star);
      color: white;
    }

    .cell.dls {
      background: var(--dls);
      color: var(--text-dark);
    }

    .cell.tls {
      background: var(--tls);
      color: white;
    }

    .cell.dws {
      background: var(--dws);
      color: var(--text-dark);
    }

    .cell.tws {
      background: var(--tws);
      color: white;
    }

    .cell.opponent-preview {
      background: rgba(220, 53, 69, 0.15);
      border: 2px dashed rgba(220, 53, 69, 0.5);
      animation: pulse 1.5s ease-in-out infinite;
    }

    .tile {
      width: 38px;
      height: 38px;
      background: var(--tile-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1.4rem;
      font-weight: 700;
      border-radius: 4px;
      box-shadow: 0 2px 6px var(--tile-shadow);
      position: relative;
      cursor: move;
      user-select: none;
      color: #2c3e50; /* Default dark text for tiles */
    }

    .tile .points {
      position: absolute;
      bottom: 2px;
      right: 3px;
      font-size: 0.65rem;
      font-family: Georgia, 'Times New Roman', serif;
      opacity: 0.7;
      color: inherit; /* Inherit from tile */
    }

    .rack-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .rack {
      background: var(--accent);
      padding: 12px;
      border-radius: 8px;
      display: flex;
      gap: 8px;
      justify-content: center;
      box-shadow: 0 4px 12px var(--tile-shadow);
      min-height: 60px;
    }

    .rack-tile {
      width: 45px;
      height: 45px;
      background: var(--tile-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1.6rem;
      font-weight: 700;
      border-radius: 4px;
      box-shadow: 0 2px 8px var(--tile-shadow);
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      user-select: none;
    }

    .rack-tile:hover {
      transform: translateY(-5px);
      box-shadow: 0 4px 12px rgba(139, 90, 43, 0.3);
    }

    .rack-tile.selected {
      background: #ffe4b5;
      transform: translateY(-8px);
    }

    .rack-tile .points {
      position: absolute;
      bottom: 3px;
      right: 4px;
      font-size: 0.7rem;
      font-family: Georgia, 'Times New Roman', serif;
      opacity: 0.7;
    }

    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }

    button {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1rem;
      font-weight: 600;
      padding: 12px 30px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 12px var(--tile-shadow);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(139, 90, 43, 0.25);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-primary {
      background: var(--accent);
      color: white;
    }

    .btn-secondary {
      background: var(--tile-bg);
      color: var(--text-dark);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .numpad-btn {
      padding: 20px;
      font-size: 1.8rem;
      font-weight: bold;
      background: rgba(244, 232, 208, 0.2);
      color: #f4e8d0;
      border: 3px solid #f4e8d0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: Georgia, serif;
      min-width: 80px;
      min-height: 80px;
    }

    .numpad-btn:hover {
      background: rgba(244, 232, 208, 0.4);
      transform: scale(1.05);
    }

    .numpad-btn:active {
      transform: scale(0.95);
      background: rgba(244, 232, 208, 0.6);
    }

    /* Bot Card Styles */
    .bot-card {
      background: white;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 200px;
      justify-content: center;
    }

    .bot-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      border-color: var(--accent);
    }

    .bot-card:active {
      transform: translateY(-2px);
    }

    .bot-icon {
      font-size: 3rem;
      margin-bottom: 5px;
    }

    .bot-name {
      font-size: 1.3rem;
      font-weight: 700;
      color: #2c3e50;
    }

    .bot-stars {
      font-size: 1rem;
      color: #f39c12;
      letter-spacing: 2px;
    }

    .bot-rating {
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent);
    }

    .bot-strategy {
      font-size: 0.9rem;
      color: #7f8c8d;
      line-height: 1.4;
      margin-top: 5px;
    }

    /* Theme-specific bot card styles */
    body.theme-dark-modern .bot-card {
      background: rgba(26, 26, 26, 0.95);
      border-color: rgba(52, 152, 219, 0.3);
    }

    body.theme-dark-modern .bot-card:hover {
      border-color: #3498db;
      box-shadow: 0 8px 24px rgba(52, 152, 219, 0.4);
    }

    body.theme-dark-modern .bot-name {
      color: #ecf0f1;
    }

    body.theme-dark-modern .bot-strategy {
      color: rgba(236, 240, 241, 0.7);
    }

    body.theme-classic-wood .bot-card {
      background: rgba(210, 180, 140, 0.95);
      border-color: #8b7355;
    }

    body.theme-classic-wood .bot-card:hover {
      box-shadow: 0 8px 24px rgba(139, 115, 85, 0.4);
    }

    body.theme-classic-wood .bot-name {
      color: #3d2817;
    }

    body.theme-classic-wood .bot-strategy {
      color: rgba(61, 40, 23, 0.7);
    }

    body.theme-neon-gaming .bot-card {
      background: rgba(10, 14, 39, 0.9);
      border: 2px solid rgba(0, 245, 255, 0.3);
    }

    body.theme-neon-gaming .bot-card:hover {
      border-color: #00f5ff;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.4);
    }

    body.theme-neon-gaming .bot-name {
      color: white;
    }

    body.theme-neon-gaming .bot-strategy {
      color: rgba(255, 255, 255, 0.7);
    }


    @keyframes flashDigit {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }

    .flash {
      animation: flashDigit 0.5s ease-in-out;
    }

    @keyframes flipCard {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(0deg); }
    }

    @keyframes highlightPlayer {
      0%, 100% { 
        transform: scale(1);
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      }
      50% { 
        transform: scale(1.05);
        box-shadow: 0 8px 24px rgba(139, 90, 43, 0.6), 0 0 30px rgba(244, 232, 208, 0.4);
      }
    }

    @keyframes pulse {
      0%, 100% { 
        transform: scale(1);
      }
      50% { 
        transform: scale(1.08);
      }
    }

    @keyframes letterPulse {
      0%, 100% { 
        transform: scale(1);
      }
      50% { 
        transform: scale(1.15);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes tileFromBag {
      0% {
        opacity: 0;
        transform: translateY(-100px) scale(0.5) rotateZ(-20deg);
      }
      60% {
        opacity: 1;
        transform: translateY(10px) scale(1.1) rotateZ(5deg);
      }
      100% {
        opacity: 1;
        transform: translateY(0) scale(1) rotateZ(0deg);
      }
    }

    @keyframes flipIn {
      0% {
        transform: rotateY(90deg);
        opacity: 0;
      }
      100% {
        transform: rotateY(0deg);
        opacity: 1;
      }
    }

    .tile-entering {
      animation: tileFromBag 0.6s ease-out;
    }

    .tile-flip {
      animation: flipIn 0.3s ease-out;
    }

    .score-card.active {
      border: 3px solid var(--accent);
      background: linear-gradient(135deg, var(--tile-bg) 0%, rgba(244, 232, 208, 0.95) 100%);
      animation: highlightPlayer 1s ease-in-out;
    }

    .score-card.inactive {
      opacity: 0.6;
    }

    .rack-tile {
      animation: slideIn 0.3s ease-out;
    }

    #turnTransition {
      animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes turnFlip {
      0% { 
        opacity: 1;
        transform: scale(1) rotateY(0deg);
      }
      50% { 
        opacity: 0.7;
        transform: scale(1.1) rotateY(180deg);
      }
      100% { 
        opacity: 1;
        transform: scale(1) rotateY(360deg);
      }
    }

    .turn-flip {
      animation: turnFlip 0.6s ease-in-out;
    }

    .message {
      text-align: center;
      padding: 15px;
      background: var(--tile-bg);
      border-radius: 8px;
      font-size: 1.1rem;
      box-shadow: 0 2px 8px var(--tile-shadow);
      animation: fadeIn 0.5s ease;
    }

    .info-panel {
      background: var(--tile-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px var(--tile-shadow);
      max-width: 300px;
    }

    .info-title {
      font-family: Georgia, 'Times New Roman', serif;
      font-size: 1.3rem;
      margin-bottom: 15px;
      color: var(--accent);
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(139, 90, 43, 0.1);
    }

    .info-item:last-child {
      border-bottom: none;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeOut {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    @keyframes tilePlace {
      0% {
        transform: scale(0.8) rotate(-5deg);
      }
      60% {
        transform: scale(1.1) rotate(2deg);
      }
      100% {
        transform: scale(1) rotate(0deg);
      }
    }

    .tile-placed {
      animation: tilePlace 0.4s ease;
    }

    /* v1.3.2 Fix: Theme buttons clickable in settings panel */
    .theme-option-settings {
      position: relative !important;
      z-index: 10 !important;
      pointer-events: auto !important;
      cursor: pointer !important;
    }
    
    .theme-option-settings:hover {
      transform: translateX(3px) !important;
    }
    
    .theme-option-settings:active {
      transform: translateX(1px) !important;
    }

    /* v1.3.2 Fix: Sound toggle animation */
    #soundToggle:checked + span {
      background-color: #27ae60;
    }
    
    #soundToggle:checked + span + span {
      transform: translateX(24px);
    }

    /* v1.4.0: Admin Panel Styles */
    .admin-tab {
      flex: 1;
      padding: 15px;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      color: #7f8c8d;
      transition: all 0.2s;
      font-family: Georgia, 'Times New Roman', serif;
    }
    
    .admin-tab:hover {
      background: rgba(231, 76, 60, 0.1);
    }
    
    .active-admin-tab {
      background: white !important;
      border-bottom: 3px solid #e74c3c !important;
      color: #e74c3c !important;
    }
    
    .player-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 15px;
      border-left: 4px solid #3498db;
      transition: all 0.2s ease;
    }
    
    .player-card:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .player-card.banned {
      border-left-color: #e74c3c;
      background: #ffebee;
    }
    
    .player-card.warned {
      border-left-color: #f39c12;
      background: #fff3cd;
    }
    
    .admin-action-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-right: 8px;
      margin-top: 5px;
      transition: all 0.2s;
      font-family: Georgia, 'Times New Roman', serif;
    }
    
    .admin-action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .btn-warn {
      background: #f39c12;
      color: white;
    }
    
    .btn-ban {
      background: #e74c3c;
      color: white;
    }
    
    .btn-unban {
      background: #27ae60;
      color: white;
    }
    
    .btn-make-admin {
      background: #9b59b6;
      color: white;
    }
    
    .btn-remove-admin {
      background: #34495e;
      color: white;
    }

    #adminPanelBtn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(231, 76, 60, 0.5);
    }

  </style>
  
  <!-- Theme System Styles -->
  <link rel="stylesheet" href="data:text/css;base64,LyogVGhlbWUgU2VsZWN0b3IgVUkgKi8KLnRoZW1lLXNlbGVjdG9yIHsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDIwcHg7IHJpZ2h0OiAyMHB4OyB6LWluZGV4OiAxMDAwMDsgfQoudGhlbWUtdG9nZ2xlLWJ0biB7IGRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGdhcDogOHB4OyBwYWRkaW5nOiAxMnB4IDIwcHg7IGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICNmZmZmZmYgMCUsICNmOGY5ZmEgMTAwJSk7IGJvcmRlcjogMnB4IHNvbGlkICNkNGFmMzc7IGJvcmRlci1yYWRpdXM6IDI1cHg7IGN1cnNvcjogcG9pbnRlcjsgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMTUpOyB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlOyBmb250LXdlaWdodDogNjAwOyBjb2xvcjogIzJjM2U1MDsgZm9udC1zaXplOiAwLjlyZW07IH0KLnRoZW1lLXRvZ2dsZS1idG46aG92ZXIgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTJweCk7IGJveC1zaGFkb3c6IDAgNnB4IDIwcHggcmdiYSgyMTIsIDE3NSwgNTUsIDAuMyk7IH0KLnRoZW1lLWljb24geyBmb250LXNpemU6IDEuMnJlbTsgfQoudGhlbWUtbGFiZWwgeyB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyBsZXR0ZXItc3BhY2luZzogMC41cHg7IH0KLnRoZW1lLW1lbnUgeyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNjBweDsgcmlnaHQ6IDA7IHdpZHRoOiAzMjBweDsgYmFja2dyb3VuZDogd2hpdGU7IGJvcmRlci1yYWRpdXM6IDEycHg7IGJveC1zaGFkb3c6IDAgMTBweCA0MHB4IHJnYmEoMCwgMCwgMCwgMC4yKTsgYm9yZGVyOiAycHggc29saWQgI2Q0YWYzNzsgb3ZlcmZsb3c6IGhpZGRlbjsgYW5pbWF0aW9uOiBtZW51U2xpZGVJbiAwLjNzIGVhc2Utb3V0OyB9CkBrZXlmcmFtZXMgbWVudVNsaWRlSW4geyBmcm9tIHsgb3BhY2l0eTogMDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KTsgfSB0byB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfSB9Ci50aGVtZS1tZW51LWhlYWRlciB7IHBhZGRpbmc6IDE2cHggMjBweDsgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgI2Q0YWYzNyAwJSwgI2Y0ZDAzZiAxMDAlKTsgY29sb3I6IHdoaXRlOyBmb250LXdlaWdodDogNzAwOyBmb250LXNpemU6IDEuMXJlbTsgdGV4dC1hbGlnbjogY2VudGVyOyBsZXR0ZXItc3BhY2luZzogMXB4OyB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlOyB9Ci50aGVtZS1vcHRpb24geyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBnYXA6IDEycHg7IHBhZGRpbmc6IDE2cHggMjBweDsgYmFja2dyb3VuZDogd2hpdGU7IGJvcmRlcjogbm9uZTsgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlOWVjZWY7IGN1cnNvcjogcG9pbnRlcjsgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTsgd2lkdGg6IDEwMCU7IHRleHQtYWxpZ246IGxlZnQ7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfQoudGhlbWUtb3B0aW9uOmxhc3QtY2hpbGQgeyBib3JkZXItYm90dG9tOiBub25lOyB9Ci50aGVtZS1vcHRpb246aG92ZXIgeyBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjZjhmOWZhIDAlLCAjZmZmZmZmIDEwMCUpOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoNXB4KTsgfQoudGhlbWUtb3B0aW9uLmFjdGl2ZSB7IGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICNmZmY5ZTYgMCUsICNmZmZlZjcgMTAwJSk7IGJvcmRlci1sZWZ0OiA0cHggc29saWQgI2Q0YWYzNzsgfQoudGhlbWUtb3B0aW9uLWljb24geyBmb250LXNpemU6IDEuOHJlbTsgZmxleC1zaHJpbms6IDA7IH0KLnRoZW1lLW9wdGlvbi1pbmZvIHsgZmxleDogMTsgfQoudGhlbWUtb3B0aW9uLW5hbWUgeyBmb250LXdlaWdodDogNzAwOyBjb2xvcjogIzJjM2U1MDsgZm9udC1zaXplOiAxcmVtOyBtYXJnaW4tYm90dG9tOiA0cHg7IH0KLnRoZW1lLW9wdGlvbi1kZXNjIHsgZm9udC1zaXplOiAwLjhyZW07IGNvbG9yOiAjN2Y4YzhkOyBsaW5lLWhlaWdodDogMS4zOyB9Ci50aGVtZS1jaGVjayB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDIwcHg7IGZvbnQtc2l6ZTogMS4ycmVtOyBjb2xvcjogIzI3YWU2MDsgZm9udC13ZWlnaHQ6IDcwMDsgfQoudGhlbWUtbG9hZGVyIHsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC44KTsgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEwcHgpOyB6LWluZGV4OiAyMDAwMDsgZGlzcGxheTogbm9uZTsgYWxpZ24taXRlbXM6IGNlbnRlcjsganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IH0KLmxvYWRlci1jb250ZW50IHsgdGV4dC1hbGlnbjogY2VudGVyOyBjb2xvcjogd2hpdGU7IH0KLmxvYWRlci1zcGlubmVyIHsgd2lkdGg6IDYwcHg7IGhlaWdodDogNjBweDsgYm9yZGVyOiA0cHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpOyBib3JkZXItdG9wLWNvbG9yOiAjZDRhZjM3OyBib3JkZXItcmFkaXVzOiA1MCU7IGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7IG1hcmdpbjogMCBhdXRvIDIwcHg7IH0KQGtleWZyYW1lcyBzcGluIHsgdG8geyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9IH0KLmxvYWRlci10ZXh0IHsgZm9udC1zaXplOiAxLjJyZW07IGZvbnQtd2VpZ2h0OiA2MDA7IGNvbG9yOiB3aGl0ZTsgfQpAbWVkaWEgKG1heC13aWR0aDogNzY4cHgpIHsgLnRoZW1lLXNlbGVjdG9yIHsgdG9wOiAxMHB4OyByaWdodDogMTBweDsgfSAudGhlbWUtdG9nZ2xlLWJ0biB7IHBhZGRpbmc6IDEwcHggMTZweDsgfSAudGhlbWUtbGFiZWwgeyBkaXNwbGF5OiBub25lOyB9IC50aGVtZS1tZW51IHsgd2lkdGg6IDI4MHB4OyB9IH0=">
  
  <!-- All 4 Themes Embedded -->
  <style id="all-themes">
    /* Light Luxury Theme - Default */
    .theme-light-luxury { --accent: #d4af37; }
    body.theme-light-luxury { background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%) !important; }
    .theme-light-luxury h1 { background: linear-gradient(135deg, #d4af37 0%, #f4d03f 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .theme-light-luxury .cell.tws { background: #ffebee !important; color: #c62828 !important; border-color: #c62828 !important; }
    .theme-light-luxury .cell.dws { background: #fff3e0 !important; color: #ef6c00 !important; border-color: #ef6c00 !important; }
    .theme-light-luxury .cell.tls { background: #e3f2fd !important; color: #1565c0 !important; border-color: #1565c0 !important; }
    .theme-light-luxury .cell.dls { background: #e8f5e9 !important; color: #2e7d32 !important; border-color: #2e7d32 !important; }
    .theme-light-luxury .cell.center { background: #fff9c4 !important; color: #f57f17 !important; border-color: #f57f17 !important; }
    .theme-light-luxury .tile { color: #2c3e50; } /* Dark text on light tiles */
    .theme-light-luxury .rack-tile { 
      background: var(--tile-bg) !important; 
      color: #2c3e50 !important; 
    }
    .theme-light-luxury .rack-tile .points { color: #2c3e50 !important; opacity: 0.7; }
    .theme-light-luxury .cell { color: rgba(100, 100, 100, 0.5); } /* Visible empty cell text */
    .theme-light-luxury .info-item { color: #2c3e50 !important; } /* Dark text for info panel */
    .theme-light-luxury .info-item span { color: #2c3e50 !important; } /* Dark text for all spans */
    .theme-light-luxury .info-title { color: #d4af37 !important; } /* Gold title */
    
    /* Dark Modern Theme */
    body.theme-dark-modern { 
      background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%) !important; 
      color: #ecf0f1 !important; 
    }
    .theme-dark-modern h1 { background: linear-gradient(135deg, #3498db 0%, #2ecc71 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 10px rgba(52, 152, 219, 0.5)); }
    .theme-dark-modern .game-container { background: rgba(26, 26, 26, 0.95); border: 2px solid rgba(52, 152, 219, 0.3); box-shadow: 0 0 40px rgba(52, 152, 219, 0.2); }
    .theme-dark-modern .board { background: #1a1a1a; border: 3px solid #3498db; box-shadow: 0 0 30px rgba(52, 152, 219, 0.3); }
    .theme-dark-modern .cell { background: #2c2c2c; border: 1px solid #3a3a3a; color: rgba(255, 255, 255, 0.3); }
    .theme-dark-modern .cell:hover:not(.occupied) { background: rgba(52, 152, 219, 0.2); border-color: #3498db; box-shadow: 0 0 10px rgba(52, 152, 219, 0.5); }
    .theme-dark-modern .cell.tws { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important; color: white !important; }
    .theme-dark-modern .cell.dws { background: linear-gradient(135deg, #e67e22 0%, #d35400 100%) !important; color: white !important; }
    .theme-dark-modern .cell.tls { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important; color: white !important; }
    .theme-dark-modern .cell.dls { background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%) !important; color: white !important; }
    .theme-dark-modern .cell.center { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%) !important; color: white !important; box-shadow: 0 0 20px rgba(243, 156, 18, 0.6); }
    .theme-dark-modern .message { background: rgba(52, 152, 219, 0.2); border: 2px solid rgba(52, 152, 219, 0.5); color: white; }
    .theme-dark-modern .info-panel { background: rgba(26, 26, 26, 0.95) !important; border: 2px solid rgba(52, 152, 219, 0.3); } /* Dark panel background */
    .theme-dark-modern .info-item { color: #ecf0f1 !important; } /* Light text for info panel */
    .theme-dark-modern .info-item span { color: #ecf0f1 !important; } /* Light text for all spans */
    .theme-dark-modern .info-title { color: #3498db !important; } /* Blue title */
    .theme-dark-modern .score-card { background: linear-gradient(135deg, rgba(52, 152, 219, 0.2) 0%, rgba(41, 128, 185, 0.2) 100%); border: 2px solid rgba(52, 152, 219, 0.4); }
    .theme-dark-modern .score-card.active { border-color: #3498db; box-shadow: 0 0 30px rgba(52, 152, 219, 0.6); }
    .theme-dark-modern .btn-primary { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); }
    .theme-dark-modern .rack { background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(52, 152, 219, 0.4); }
    .theme-dark-modern .tile { color: #2c3e50; } /* Dark text on light tiles */
    .theme-dark-modern .rack-tile { 
      background: var(--tile-bg) !important; 
      color: #2c3e50 !important; 
      border: 1px solid #3498db;
    }
    .theme-dark-modern .rack-tile .points { color: #2c3e50 !important; opacity: 0.7; }
    
    /* Classic Wood Theme */
    body.theme-classic-wood { 
      background: linear-gradient(135deg, #e8d5b7 0%, #d4b896 100%) !important; 
      color: #3d2817 !important; 
    }
    .theme-classic-wood h1 { font-family: Georgia, serif; background: linear-gradient(135deg, #8b4513 0%, #d2691e 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
    .theme-classic-wood .game-container { background: rgba(210, 180, 140, 0.95); border: 4px solid #8b7355; }
    .theme-classic-wood .board { background: #c19a6b; border: 4px solid #8b7355; }
    .theme-classic-wood .cell { background: linear-gradient(145deg, #c8a882 0%, #b8956a 100%); border: 1px solid #8b7355; color: rgba(61, 40, 23, 0.4); font-family: Georgia, serif; }
    .theme-classic-wood .cell.tws { background: #8b2500 !important; color: white !important; }
    .theme-classic-wood .cell.dws { background: #cd853f !important; color: white !important; }
    .theme-classic-wood .cell.tls { background: #4682b4 !important; color: white !important; }
    .theme-classic-wood .cell.dls { background: #87ceeb !important; color: white !important; }
    .theme-classic-wood .cell.center { background: #ffd700 !important; color: #8b7355 !important; }
    .theme-classic-wood .tile { background: linear-gradient(145deg, #fffef7 0%, #f4e8d0 100%); border: 2px solid #8b7355; font-family: Georgia, serif; color: #3d2817; }
    .theme-classic-wood .rack-tile { 
      background: linear-gradient(145deg, #fffef7 0%, #f4e8d0 100%) !important; 
      border: 2px solid #8b7355; 
      font-family: Georgia, serif; 
      color: #3d2817 !important; 
    }
    .theme-classic-wood .rack-tile .points { color: #3d2817 !important; opacity: 0.8; }
    .theme-classic-wood .rack { background: linear-gradient(145deg, #b8956a 0%, #a0826d 100%); border: 3px solid #8b7355; }
    .theme-classic-wood .score-card { background: linear-gradient(135deg, rgba(210, 180, 140, 0.95) 0%, rgba(184, 149, 106, 0.95) 100%); border: 3px solid #8b7355; }
    .theme-classic-wood .btn-primary { background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%); }
    .theme-classic-wood .message { background: rgba(244, 232, 208, 0.98); border: 2px solid #8b7355; color: #3d2817; font-family: Georgia, serif; }
    .theme-classic-wood .info-panel { background: rgba(210, 180, 140, 0.95) !important; } /* Wood panel background */
    .theme-classic-wood .info-item { color: #3d2817 !important; } /* Dark text for info panel */
    .theme-classic-wood .info-item span { color: #3d2817 !important; } /* Dark text for all spans */
    .theme-classic-wood .info-title { color: #8b4513 !important; } /* Brown title */
    
    /* Neon Gaming Theme */
    body.theme-neon-gaming { 
      background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%) !important; 
      color: white !important; 
      position: relative;
    }
    
    /* Neon border effect around entire page */
    body.theme-neon-gaming::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 4px solid #00f5ff;
      box-shadow: 
        inset 0 0 30px rgba(0, 245, 255, 0.3),
        0 0 30px rgba(0, 245, 255, 0.5);
      pointer-events: none;
      z-index: 9999;
      animation: neonBorderPulse 3s ease-in-out infinite;
    }
    
    @keyframes neonBorderPulse {
      0%, 100% { 
        box-shadow: 
          inset 0 0 30px rgba(0, 245, 255, 0.3),
          0 0 30px rgba(0, 245, 255, 0.5);
      }
      50% { 
        box-shadow: 
          inset 0 0 50px rgba(0, 245, 255, 0.5),
          0 0 50px rgba(0, 245, 255, 0.8);
      }
    }
    
    /* Animated starfield background */
    body.theme-neon-gaming::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        radial-gradient(2px 2px at 20px 30px, white, transparent),
        radial-gradient(2px 2px at 60px 70px, white, transparent),
        radial-gradient(1px 1px at 50px 50px, white, transparent),
        radial-gradient(1px 1px at 130px 80px, white, transparent),
        radial-gradient(2px 2px at 90px 10px, white, transparent);
      background-repeat: repeat;
      background-size: 200px 200px;
      opacity: 0.4;
      animation: twinkle 5s linear infinite;
      pointer-events: none;
      z-index: 1;
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.2; }
    }
    
    .theme-neon-gaming h1 { 
      font-family: 'Courier New', monospace; 
      font-weight: 900; 
      background: linear-gradient(135deg, #00f5ff 0%, #ff006e 50%, #8338ec 100%); 
      -webkit-background-clip: text; 
      -webkit-text-fill-color: transparent; 
      filter: drop-shadow(0 0 20px #00f5ff);
      position: relative;
      z-index: 10;
    }
    .theme-neon-gaming .game-container { 
      background: rgba(10, 14, 39, 0.9); 
      border: 2px solid #00f5ff; 
      box-shadow: 0 0 30px #00f5ff;
      position: relative;
      z-index: 10;
    }
    .theme-neon-gaming .board { background: #050814; border: 3px solid #00f5ff; box-shadow: 0 0 40px rgba(0, 245, 255, 0.5); }
    .theme-neon-gaming .cell { background: rgba(10, 14, 39, 0.8); border: 1px solid rgba(0, 245, 255, 0.3); color: rgba(0, 245, 255, 0.4); font-family: 'Courier New', monospace; }
    .theme-neon-gaming .cell:hover:not(.occupied) { background: rgba(0, 245, 255, 0.1); border-color: #00f5ff; box-shadow: 0 0 15px rgba(0, 245, 255, 0.5); }
    .theme-neon-gaming .cell.tws { background: radial-gradient(circle, rgba(255, 0, 110, 0.3) 0%, rgba(139, 0, 76, 0.3) 100%) !important; border-color: #ff006e; color: white !important; box-shadow: 0 0 15px #ff006e; }
    .theme-neon-gaming .cell.dws { background: radial-gradient(circle, rgba(255, 190, 11, 0.3) 0%, rgba(179, 133, 8, 0.3) 100%) !important; border-color: #ffbe0b; color: white !important; box-shadow: 0 0 15px #ffbe0b; }
    .theme-neon-gaming .cell.tls { background: radial-gradient(circle, rgba(131, 56, 236, 0.3) 0%, rgba(91, 39, 165, 0.3) 100%) !important; border-color: #8338ec; color: white !important; box-shadow: 0 0 15px #8338ec; }
    .theme-neon-gaming .cell.dls { background: radial-gradient(circle, rgba(62, 255, 0, 0.3) 0%, rgba(43, 179, 0, 0.3) 100%) !important; border-color: #3eff00; color: white !important; box-shadow: 0 0 15px #3eff00; }
    .theme-neon-gaming .cell.center { background: radial-gradient(circle, rgba(0, 245, 255, 0.4) 0%, rgba(0, 172, 179, 0.4) 100%) !important; border-color: #00f5ff; color: white !important; box-shadow: 0 0 30px #00f5ff; animation: centerPulse 2s ease-in-out infinite; }
    @keyframes centerPulse { 0%, 100% { box-shadow: 0 0 30px #00f5ff; } 50% { box-shadow: 0 0 50px #00f5ff; } }
    .theme-neon-gaming .tile { background: linear-gradient(145deg, #1a1f3a 0%, #0f1228 100%); border: 2px solid #00f5ff; color: white !important; box-shadow: 0 0 15px rgba(0, 245, 255, 0.5); font-family: 'Courier New', monospace; font-weight: 900; }
    .theme-neon-gaming .tile .points { color: white !important; } /* White points number */
    .theme-neon-gaming .rack-tile { 
      background: linear-gradient(145deg, #1a1f3a 0%, #0f1228 100%) !important; 
      border: 2px solid #00f5ff; 
      color: white !important; 
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.5); 
      font-family: 'Courier New', monospace; 
      font-weight: 900; 
    }
    .theme-neon-gaming .rack-tile .points { color: white !important; opacity: 0.9; }
    .theme-neon-gaming .rack-tile:hover { border-color: #ff006e; box-shadow: 0 0 25px #ff006e; }
    .theme-neon-gaming .tile:hover { border-color: #ff006e; box-shadow: 0 0 25px #ff006e; }
    .theme-neon-gaming .rack { background: rgba(10, 14, 39, 0.9); border: 2px solid #8338ec; box-shadow: 0 0 20px rgba(131, 56, 236, 0.4); }
    .theme-neon-gaming .score-card { background: linear-gradient(135deg, rgba(10, 14, 39, 0.95) 0%, rgba(26, 31, 58, 0.95) 100%); border: 2px solid #00f5ff; box-shadow: 0 0 20px rgba(0, 245, 255, 0.4); }
    .theme-neon-gaming .score-card.active { border-color: #ff006e; box-shadow: 0 0 30px #ff006e; }
    .theme-neon-gaming .btn-primary { background: linear-gradient(135deg, #8338ec 0%, #ff006e 100%); border: 2px solid #ff006e; color: white; box-shadow: 0 0 20px rgba(255, 0, 110, 0.5); font-family: 'Courier New', monospace; font-weight: 700; }
    .theme-neon-gaming .message { background: rgba(10, 14, 39, 0.95); border: 2px solid #00f5ff; color: white; font-family: 'Courier New', monospace; box-shadow: 0 0 20px rgba(0, 245, 255, 0.4); }
    .theme-neon-gaming .info-panel { background: rgba(10, 14, 39, 0.95) !important; border: 2px solid #00f5ff; box-shadow: 0 0 20px rgba(0, 245, 255, 0.4); } /* Dark panel background */
    .theme-neon-gaming .info-item { color: white !important; font-family: 'Courier New', monospace; } /* White text for info panel */
    .theme-neon-gaming .info-item span { color: white !important; } /* White text for all spans */
    .theme-neon-gaming .info-title { color: #00f5ff !important; font-family: 'Courier New', monospace; } /* Cyan title */
    
    /* Fix theme selector for neon theme */
    .theme-neon-gaming .theme-selector { z-index: 10000; }
    
    /* ========================================
       MOBILE RESPONSIVE STYLES
       ======================================== */
    
    /* Tablet and smaller */
    @media (max-width: 1024px) {
      h1 {
        font-size: 2.5rem;
        margin-bottom: 15px;
      }
      
      .game-container {
        padding: 20px;
        gap: 15px;
      }
      
      .board {
        max-width: 600px;
      }
      
      .cell {
        font-size: 0.6rem;
      }
    }
    
    /* Mobile landscape and smaller tablets */
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      
      h1 {
        font-size: 2rem;
        margin-bottom: 10px;
      }
      
      .game-container {
        padding: 15px;
        gap: 12px;
      }
      
      /* Smaller board for mobile */
      .board {
        max-width: 100%;
        padding: 4px;
        gap: 1px;
      }
      
      .cell {
        font-size: 0.5rem;
        border-width: 1px;
      }
      
      /* Smaller tiles */
      .tile {
        font-size: 1rem;
      }
      
      .tile .letter {
        font-size: 1.3rem;
      }
      
      .tile .points {
        font-size: 0.6rem;
        bottom: 2px;
        right: 4px;
      }
      
      /* Rack optimization */
      .rack-container {
        padding: 10px;
      }
      
      .rack {
        gap: 4px;
        padding: 10px;
        min-height: 60px;
      }
      
      /* Score cards stack vertically on mobile */
      .scores {
        flex-direction: column;
        gap: 10px;
      }
      
      .score-card {
        padding: 15px;
      }
      
      .score-card .score-value {
        font-size: 2rem;
      }
      
      /* Buttons */
      .controls {
        gap: 8px;
      }
      
      button {
        padding: 10px 18px;
        font-size: 0.9rem;
      }
      
      /* Message */
      .message {
        padding: 12px 18px;
        font-size: 1rem;
      }
      
      /* Info display */
      .info {
        flex-direction: column;
        gap: 8px;
        font-size: 0.85rem;
      }
      
      .info-item {
        padding: 6px 12px;
      }
      
      /* Mode selection buttons */
      #modeSelection button,
      #deviceSelection button {
        font-size: 1rem;
        padding: 18px 24px;
      }
      
      /* Theme selector mobile */
      .theme-selector {
        top: 10px;
        right: 10px;
      }
      
      .theme-toggle-btn {
        padding: 8px 14px;
        font-size: 0.85rem;
      }
      
      .theme-icon {
        font-size: 1rem;
      }
      
      .theme-label {
        display: none; /* Hide "Themes" text on mobile */
      }
      
      .theme-menu {
        width: 280px;
        right: -10px; /* Align with button */
      }
      
      .theme-option {
        padding: 12px 16px;
      }
      
      .theme-option-icon {
        font-size: 1.5rem;
      }
      
      .theme-option-name {
        font-size: 0.9rem;
      }
      
      .theme-option-desc {
        font-size: 0.75rem;
      }
    }
    
    /* Small mobile phones */
    @media (max-width: 480px) {
      body {
        padding: 5px;
      }
      
      h1 {
        font-size: 1.5rem;
        margin-bottom: 8px;
      }
      
      .game-container {
        padding: 10px;
        gap: 10px;
      }
      
      /* Very compact board */
      .board {
        padding: 3px;
        gap: 1px;
      }
      
      .cell {
        font-size: 0.4rem;
        min-height: unset;
      }
      
      /* Even smaller tiles */
      .tile {
        font-size: 0.8rem;
        border-width: 1px;
      }
      
      .tile .letter {
        font-size: 1rem;
      }
      
      .tile .points {
        font-size: 0.5rem;
        bottom: 1px;
        right: 2px;
      }
      
      /* Rack */
      .rack {
        gap: 3px;
        padding: 8px;
        min-height: 50px;
      }
      
      /* Score cards */
      .score-card {
        padding: 12px;
      }
      
      .score-card .label {
        font-size: 0.85rem;
      }
      
      .score-card .score-value {
        font-size: 1.8rem;
      }
      
      /* Buttons smaller */
      button {
        padding: 8px 14px;
        font-size: 0.85rem;
      }
      
      /* Message */
      .message {
        padding: 10px 14px;
        font-size: 0.9rem;
      }
      
      /* Mode selection */
      #modeSelection button,
      #deviceSelection button {
        font-size: 0.9rem;
        padding: 15px 20px;
      }
      
      /* Difficulty slider */
      #difficultySlider {
        height: 10px;
      }
      
      #difficultySlider::-webkit-slider-thumb {
        width: 24px;
        height: 24px;
      }
      
      /* Theme menu even smaller */
      .theme-menu {
        width: 260px;
      }
      
      .theme-option {
        padding: 10px 12px;
      }
      
      .theme-option-icon {
        font-size: 1.3rem;
      }
    }
    
    /* Touch optimization for all mobile devices */
    @media (hover: none) and (pointer: coarse) {
      /* Larger touch targets */
      .cell {
        min-height: 30px;
        min-width: 30px;
      }
      
      .tile {
        cursor: grab;
        touch-action: none;
        min-height: 40px;
        min-width: 40px;
      }
      
      .tile:active {
        cursor: grabbing;
      }
      
      button {
        min-height: 44px; /* iOS recommended touch target */
        cursor: pointer;
      }
      
      /* Prevent text selection during drag */
      .board,
      .rack,
      .tile {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
      }
      
      /* Better touch feedback */
      .tile:active {
        transform: scale(0.95);
      }
      
      .cell:active:not(.occupied) {
        background: rgba(255, 255, 255, 0.1);
      }
    }
    
    /* Landscape mode on mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      .scores {
        flex-direction: row;
      }
      
      .board {
        max-width: 400px;
      }
    }
    
    /* Very small screens - ultra compact */
    @media (max-width: 360px) {
      h1 {
        font-size: 1.3rem;
      }
      
      .board {
        padding: 2px;
      }
      
      .cell {
        font-size: 0.35rem;
      }
      
      .tile .letter {
        font-size: 0.9rem;
      }
      
      .rack {
        gap: 2px;
        padding: 6px;
      }
    }
  </style>
  
  <!-- Supabase SDK -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <script>
    // Wait for page load to ensure Supabase SDK is loaded
    if (!window.supabaseInitialized) {
      window.supabaseInitialized = true;
      
      // Supabase configuration
      const SUPABASE_URL = 'https://bovfmxfdbrmbmybzvuss.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJvdmZteGZkYnJtYm15Ynp2dXNzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ4MDM0MDgsImV4cCI6MjA4MDM3OTQwOH0.558ePBHGLj5Igow2qy5PhB8TTN88snZ_dsv_KYhJAMI';
      
      // Create Supabase client with session storage (clears on tab close)
      const { createClient } = supabase;
      window.supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: {
          storage: window.sessionStorage, // Use sessionStorage instead of localStorage
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true
        }
      });
      
      console.log('âœ… Supabase initialized with session storage:', window.supabase);
    }
  </script>
  
</head>
<body class="theme-light-luxury">
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
  
  <!-- Authentication Screens -->
  <div id="authContainer" class="game-container" style="display: flex; max-width: 450px; margin: 50px auto;">
    <div style="text-align: center; padding: 40px; width: 100%;">
      <h2 style="color: var(--accent); margin-bottom: 30px;">ðŸŽ® Scrabble Game</h2>
      
      <!-- Google Sign-In Screen -->
      <div id="loginScreen">
        <p style="color: #7f8c8d; margin-bottom: 30px; font-size: 15px;">
          Sign in to save your progress, track stats, and play online!
        </p>
        
        <button id="googleSignInBtn" style="
          width: 100%;
          padding: 18px 24px;
          font-size: 16px;
          font-weight: 600;
          border: 2px solid #4285f4;
          border-radius: 12px;
          background: white;
          color: #3c4043;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 12px;
          transition: all 0.2s;
          box-shadow: 0 2px 8px rgba(0,0,0,0.1);
          margin-bottom: 20px;
        " onmouseover="this.style.background='#f8f9fa'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'" onmouseout="this.style.background='white'; this.style.boxShadow='0 2px 8px rgba(0,0,0,0.1)'">
          <svg width="20" height="20" viewBox="0 0 24 24">
            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
          </svg>
          Continue with Google
        </button>
        
        <div style="text-align: center; margin: 25px 0; padding-top: 20px; border-top: 1px solid #ddd;">
          <button id="guestPlayBtn" class="btn-secondary" style="width: 100%; padding: 15px; font-size: 16px;">
            ðŸ‘» Play as Guest
          </button>
          <p style="font-size: 12px; color: #7f8c8d; margin-top: 10px;">No stats tracking â€¢ No online play â€¢ Local only</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Ban Screen (shown when user is banned) -->
  <div id="banScreen" style="display: none;"></div>
  
  <!-- Profile Button (shown when logged in) -->
  <!-- User Menu Button (Hamburger) -->
  <button id="userMenuBtn" onclick="toggleUserPanel()" style="
    position: fixed;
    top: 20px;
    left: 20px;
    background: white;
    border: 2px solid var(--accent);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    cursor: pointer;
    z-index: 10001;
    display: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    transition: all 0.2s ease;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    padding: 0;
    line-height: 1;
  ">
    â˜°
  </button>

  <!-- User Side Panel (Slides from Left) -->
  <div id="userSidePanel" style="
    position: fixed;
    top: 0;
    left: -350px;
    width: 350px;
    height: 100vh;
    background: white;
    box-shadow: 4px 0 20px rgba(0,0,0,0.2);
    z-index: 10002;
    transition: left 0.3s ease;
    overflow-y: auto;
  ">
    <!-- Header with User Info -->
    <div style="
      padding: 30px 20px;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark, #2980b9) 100%);
      color: white;
    ">
      <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
        <div style="flex: 1;">
          <div style="
            width: 70px;
            height: 70px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 35px;
            margin-bottom: 15px;
            border: 3px solid rgba(255,255,255,0.5);
          ">
            ðŸ‘¤
          </div>
          <div id="panelUsername" style="font-size: 20px; font-weight: 600; margin-bottom: 5px;">Username</div>
          <div id="panelEmail" style="font-size: 13px; opacity: 0.9;"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e5ede1e9ecc0e5f8e1edf0ece5aee3efed">[email&#160;protected]</a></div>
        </div>
        <button onclick="toggleUserPanel()" style="
          background: rgba(255,255,255,0.2);
          border: none;
          color: white;
          width: 35px;
          height: 35px;
          border-radius: 50%;
          cursor: pointer;
          font-size: 20px;
          display: flex;
          align-items: center;
          justify-content: center;
        ">Ã—</button>
      </div>
      
      <!-- Quick Stats -->
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px;">
        <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; text-align: center;">
          <div id="panelGamesPlayed" style="font-size: 24px; font-weight: 600;">0</div>
          <div style="font-size: 11px; opacity: 0.9;">Games</div>
        </div>
        <div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; text-align: center;">
          <div id="panelWins" style="font-size: 24px; font-weight: 600;">0</div>
          <div style="font-size: 11px; opacity: 0.9;">Wins</div>
        </div>
      </div>
    </div>

    <!-- Menu Options -->
    <div style="padding: 20px;">
      
      <!-- Stats Section (Expandable) -->
      <div id="statsSection" style="margin-bottom: 10px;">
        <div onclick="toggleSection('statsContent')" style="
          padding: 15px;
          background: #f8f9fa;
          border-radius: 10px;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: space-between;
          transition: all 0.2s;
        " onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
          <div style="display: flex; align-items: center; gap: 15px;">
            <div style="
              width: 45px;
              height: 45px;
              background: var(--accent);
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 22px;
              color: white;
            ">ðŸ“Š</div>
            <div>
              <div style="font-weight: 600; font-size: 15px; color: #2c3e50;">Stats</div>
              <div style="font-size: 12px; color: #7f8c8d;">View your statistics</div>
            </div>
          </div>
          <span id="statsToggle" style="font-size: 18px; color: #7f8c8d;">â–¼</span>
        </div>
        
        <!-- Stats Content (Collapsible) -->
        <div id="statsContent" style="display: none; padding: 15px; background: white; border-radius: 0 0 10px 10px; margin-top: 2px;">
          <!-- ELO Rating (Prominent) -->
          <div style="text-align: center; padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; margin-bottom: 15px;">
            <div id="menuStatsElo" style="font-size: 32px; font-weight: 700; color: white;">1000</div>
            <div style="font-size: 12px; color: rgba(255,255,255,0.9); font-weight: 600;">ELO RATING</div>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsGamesPlayed" style="font-size: 20px; font-weight: 600; color: var(--accent);">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">Games Played</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsWins" style="font-size: 20px; font-weight: 600; color: #27ae60;">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">Wins</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsLosses" style="font-size: 20px; font-weight: 600; color: #e74c3c;">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">Losses</div>
            </div>
            <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
              <div id="menuStatsHighScore" style="font-size: 20px; font-weight: 600; color: #f39c12;">0</div>
              <div style="font-size: 11px; color: #7f8c8d;">High Score</div>
            </div>
          </div>
          <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
            <div id="menuStatsWinRate" style="font-size: 18px; font-weight: 600; color: var(--accent);">0%</div>
            <div style="font-size: 11px; color: #7f8c8d;">Win Rate</div>
          </div>
        </div>
      </div>

      <!-- Settings Section (Expandable) -->
      <div id="settingsSection" style="margin-bottom: 10px;">
        <div onclick="openSettingsPanel()" style="
          padding: 15px;
          background: #f8f9fa;
          border-radius: 10px;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 15px;
          transition: all 0.2s;
        " onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
          <div style="
            width: 45px;
            height: 45px;
            background: #3498db;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            color: white;
          ">âš™ï¸</div>
          <div>
            <div style="font-weight: 600; font-size: 15px; color: #2c3e50;">Settings</div>
            <div style="font-size: 12px; color: #7f8c8d;">Themes & preferences</div>
          </div>
        </div>
      </div>

      <!-- Admin Panel Section (Hidden by default) -->
      <div id="adminPanelOption" onclick="showPanelAdmin()" style="
        padding: 15px;
        margin-bottom: 10px;
        background: #ffebee;
        border-radius: 10px;
        cursor: pointer;
        display: none;
        align-items: center;
        gap: 15px;
        transition: all 0.2s;
      " onmouseover="this.style.background='#ffcdd2'" onmouseout="this.style.background='#ffebee'">
        <div style="
          width: 45px;
          height: 45px;
          background: #e74c3c;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 22px;
          color: white;
        ">ðŸ‘®</div>
        <div>
          <div style="font-weight: 600; font-size: 15px; color: #e74c3c;">Admin Panel</div>
          <div style="font-size: 12px; color: #c0392b;">Manage players & settings</div>
        </div>
      </div>

      <div style="height: 1px; background: #e0e0e0; margin: 20px 0;"></div>

      <!-- Logout -->
      <div onclick="handleLogout()" style="
        padding: 15px;
        background: white;
        border: 2px solid #e74c3c;
        border-radius: 10px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 15px;
        transition: all 0.2s;
      " onmouseover="this.style.background='#ffebee'" onmouseout="this.style.background='white'">
        <div style="
          width: 45px;
          height: 45px;
          background: #e74c3c;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 22px;
          color: white;
        ">ðŸšª</div>
        <div>
          <div style="font-weight: 600; font-size: 15px; color: #e74c3c;">Logout</div>
          <div style="font-size: 12px; color: #c0392b;">Sign out of your account</div>
        </div>
      </div>

    </div>
  </div>

  <!-- Overlay (darkens background when panel open) -->
  <div id="panelOverlay" onclick="toggleUserPanel()" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 10001;
    display: none;
    backdrop-filter: blur(2px);
  "></div>

  <!-- Admin Panel Button (shown for admins only) -->
  <button id="adminPanelBtn" onclick="openAdminPanel()" style="
    position: fixed;
    top: 20px;
    left: 20px;
    background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    z-index: 10001;
    display: none;
    box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
    transition: all 0.3s ease;
  ">
    ðŸ‘® Admin Panel
  </button>
  
  <!-- Anonymous Mode Toggle (shown when not logged in and on mode selection) -->
  <div id="anonymousToggle" style="
    position: fixed;
    top: 20px;
    left: 20px;
    background: #7f8c8d;
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 12px;
    z-index: 1000;
    display: none;
  ">
    ðŸ‘» Anonymous Mode
  </div>
  </button>
  
  <!-- Settings Panel -->
  <div id="settingsPanel" style="
    position: fixed;
    top: 0;
    right: -450px;
    width: 450px;
    height: 100vh;
    background: white;
    box-shadow: -4px 0 20px rgba(0,0,0,0.3);
    z-index: 2000;
    transition: right 0.3s ease;
    overflow-y: auto;
  ">
    <div style="padding: 0;">
      <!-- Header -->
      <div style="padding: 25px 30px; border-bottom: 2px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; background: var(--accent); color: white;">
        <h2 style="margin: 0; font-size: 24px;">âš™ï¸ Settings</h2>
        <button onclick="toggleSettingsPanel()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: white;">Ã—</button>
      </div>
      
      <!-- Tabs -->
      <div style="display: flex; border-bottom: 2px solid #f0f0f0; background: #f8f9fa;">
        <button id="profileTab" class="settings-tab active-tab" onclick="switchSettingsTab('profile')" style="
          flex: 1;
          padding: 15px;
          background: white;
          border: none;
          border-bottom: 3px solid var(--accent);
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          color: var(--accent);
        ">
          ðŸ‘¤ Stats
        </button>
        <button id="generalTab" class="settings-tab" onclick="switchSettingsTab('general')" style="
          flex: 1;
          padding: 15px;
          background: transparent;
          border: none;
          border-bottom: 3px solid transparent;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          color: #7f8c8d;
        ">
          âš™ï¸ Settings
        </button>
        <button id="adminTabBtn" class="settings-tab" onclick="openAdminDashboard()" style="
          flex: 1;
          padding: 15px;
          background: transparent;
          border: none;
          border-bottom: 3px solid transparent;
          cursor: pointer;
          font-size: 14px;
          font-weight: 600;
          color: #7f8c8d;
          display: none;
        ">
          ðŸ‘® Admin Dashboard
        </button>
      </div>
      
      <!-- Profile Tab Content -->
      <div id="profileTabContent" class="settings-tab-content" style="padding: 30px; display: block;">
        <div style="text-align: center; margin-bottom: 30px;">
          <div style="width: 80px; height: 80px; background: var(--accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 15px; font-size: 36px; color: white;">
            ðŸ‘¤
          </div>
          <h3 id="profileUsername" style="margin: 0 0 5px 0;">Username</h3>
          <p id="profileEmail" style="margin: 0; color: #7f8c8d; font-size: 14px;"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8eebe3efe7e2ceebf6efe3fee2eba0ede1e3">[email&#160;protected]</a></p>
        </div>
        
        <!-- ELO Rating (Prominent) -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 25px; border-radius: 12px; margin-bottom: 20px; text-align: center;">
          <div style="font-size: 14px; color: rgba(255,255,255,0.9); font-weight: 600; margin-bottom: 8px;">ELO RATING</div>
          <div style="font-size: 48px; font-weight: 700; color: white;" id="statsEloRating">1000</div>
        </div>
        
        <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
          <h4 style="margin: 0 0 15px 0; color: var(--accent);">ðŸ“Š Stats</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <div style="font-size: 24px; font-weight: bold; color: var(--accent);" id="statsGamesPlayed">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Games Played</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #27ae60;" id="statsWins">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Wins</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #e74c3c;" id="statsLosses">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Losses</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #f39c12;" id="statsHighScore">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">High Score</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #3498db;" id="statsAvgScore">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Avg Score</div>
            </div>
            <div>
              <div style="font-size: 24px; font-weight: bold; color: #9b59b6;" id="statsTotalPoints">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Total Points</div>
            </div>
          </div>
          <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <div style="font-size: 18px; font-weight: bold; color: var(--accent);" id="statsWinRate">0%</div>
              <div style="font-size: 12px; color: #7f8c8d;">Win Rate</div>
            </div>
            <div>
              <div style="font-size: 18px; font-weight: bold; color: #e67e22;" id="statsWinStreak">0</div>
              <div style="font-size: 12px; color: #7f8c8d;">Win Streak</div>
            </div>
          </div>
          <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
            <div style="font-size: 14px; color: #7f8c8d; margin-bottom: 5px;">ðŸ… Best Word</div>
            <div style="font-size: 20px; font-weight: bold; color: var(--accent);" id="statsBestWord">â€”</div>
          </div>
        </div>
        
        <button onclick="showLeaderboard()" class="btn-primary" style="width: 100%; margin-bottom: 10px;">
          ðŸ† View Leaderboard
        </button>
        
        <button onclick="handleLogout()" class="btn-secondary" style="width: 100%;">
          Logout
        </button>
      </div>
      
      <!-- General Tab Content (includes Themes) -->
      <div id="generalTabContent" class="settings-tab-content" style="padding: 30px; display: none;">
        <h3 style="margin: 0 0 20px 0; color: var(--accent);">âš™ï¸ Settings</h3>
        
        <!-- Themes Section -->
        <div style="margin-bottom: 30px;">
          <h4 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;">ðŸŽ¨ Themes</h4>
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <button class="theme-option-settings active" data-theme="light-luxury" onclick="switchThemeFromSettings('light-luxury')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid var(--accent);
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">âœ¨</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Light Luxury</div>
                <div style="font-size: 12px; color: #7f8c8d;">Clean white, gold accents</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: var(--accent);">âœ“</span>
            </button>
            
            <button class="theme-option-settings" data-theme="dark-modern" onclick="switchThemeFromSettings('dark-modern')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid #ddd;
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">ðŸŒ™</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Dark Modern</div>
                <div style="font-size: 12px; color: #7f8c8d;">Dark gradients, glowing tiles</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: #ddd;">âœ“</span>
            </button>
            
            <button class="theme-option-settings" data-theme="classic-wood" onclick="switchThemeFromSettings('classic-wood')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid #ddd;
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">ðŸŽ¨</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Classic Wood</div>
                <div style="font-size: 12px; color: #7f8c8d;">Wooden board, traditional</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: #ddd;">âœ“</span>
            </button>
            
            <button class="theme-option-settings" data-theme="neon-gaming" onclick="switchThemeFromSettings('neon-gaming')" style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: white;
              border: 2px solid #ddd;
              border-radius: 12px;
              cursor: pointer;
              transition: all 0.2s;
              text-align: left;
              position: relative;
              z-index: 10;
              pointer-events: auto;
            ">
              <span style="font-size: 28px; margin-right: 15px;">âš¡</span>
              <div style="flex: 1;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 3px;">Neon Gaming</div>
                <div style="font-size: 12px; color: #7f8c8d;">Cyberpunk neon, vibrant</div>
              </div>
              <span class="theme-check-settings" style="font-size: 20px; color: #ddd;">âœ“</span>
            </button>
          </div>
        </div>
        
        <!-- General Settings Section -->
        <h4 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;">ðŸ”§ Preferences</h4>
        <div style="background: var(--cell-bg, #f8f9fa); padding: 20px; border-radius: 12px; margin-bottom: 15px;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div>
              <div style="font-weight: bold; margin-bottom: 5px; color: var(--text);">ðŸ”Š Sound Effects</div>
              <div style="font-size: 12px; color: var(--text-secondary, #7f8c8d);">Play sounds during gameplay</div>
            </div>
            <label style="position: relative; display: inline-block; width: 50px; height: 26px; cursor: pointer; z-index: 10;">
              <input type="checkbox" id="soundToggle" checked onchange="toggleSound(this.checked)" style="opacity: 0; width: 0; height: 0; position: absolute;">
              <span style="position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--accent); transition: 0.3s; border-radius: 26px; pointer-events: all;"></span>
              <span style="position: absolute; content: ''; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; transition: 0.3s; border-radius: 50%; pointer-events: none;"></span>
            </label>
          </div>
        </div>
        
        <div style="background: #fff3cd; padding: 15px; border-radius: 12px; border-left: 4px solid #ffc107;">
          <div style="font-size: 14px; color: #856404;">
            <strong>ðŸ’¡ More settings coming soon!</strong><br>
            <span style="font-size: 12px;">Animations, notifications, and more...</span>
          </div>
        </div>
      </div>
      
      <!-- Admin Tab Content -->
      <div id="adminTabContent" class="settings-tab-content" style="padding: 20px; display: none;">
        <div style="text-align: center; padding: 60px 40px;">
          <div style="font-size: 60px; margin-bottom: 20px;">ðŸ‘®</div>
          <h3 style="margin: 0 0 15px 0; color: #667eea; font-size: 24px;">Admin Dashboard</h3>
          <p style="color: #64748b; margin-bottom: 30px; font-size: 16px;">
            The admin panel has moved to a dedicated full-screen dashboard.
          </p>
          <button onclick="openAdminDashboard()" style="
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transition: all 0.2s;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.3)'">
            Open Admin Dashboard â†’
          </button>
          <p style="color: #94a3b8; margin-top: 20px; font-size: 13px;">
            Or access directly by adding <code style="background: #f1f5f9; padding: 2px 6px; border-radius: 4px;">#admin</code> to your URL
          </p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Admin Panel Modal -->
  <div id="adminPanel" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    backdrop-filter: blur(5px);
  ">
    <div style="
      background: white;
      border-radius: 12px;
      padding: 0;
      max-width: 800px;
      width: 90%;
      max-height: 85vh;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    ">
      <!-- Header -->
      <div style="
        background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        color: white;
        padding: 20px 30px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      ">
        <h2 style="margin: 0; font-size: 24px;">ðŸ‘® Admin Panel</h2>
        <button onclick="closeAdminPanel()" style="
          background: none;
          border: none;
          color: white;
          font-size: 28px;
          cursor: pointer;
          padding: 0;
          line-height: 1;
        ">Ã—</button>
      </div>
      
      <!-- Tabs -->
      <div style="display: flex; border-bottom: 2px solid #f0f0f0; background: #f8f9fa;">
        <button id="tabPlayers" class="admin-tab active-admin-tab" onclick="switchAdminTab('players')">
          ðŸ‘¥ Players
        </button>
        <button id="tabBanned" class="admin-tab" onclick="switchAdminTab('banned')">
          ðŸš« Banned
        </button>
        <button id="tabWarnings" class="admin-tab" onclick="switchAdminTab('warnings')">
          âš ï¸ Warnings
        </button>
        <button id="tabAdmins" class="admin-tab" onclick="switchAdminTab('admins')" style="display: none;">
          ðŸ‘® Admins
        </button>
      </div>
      
      <!-- Content Area -->
      <div style="padding: 30px; overflow-y: auto; max-height: calc(85vh - 120px);">
        
        <!-- Players Tab -->
        <div id="adminTabPlayers" class="admin-tab-content">
          <div style="margin-bottom: 20px;">
            <h3 style="margin: 0 0 15px 0; color: var(--accent);">ðŸ” Search Players</h3>
            <div style="display: flex; gap: 10px;">
              <input type="text" id="adminSearchInput" placeholder="Search by username or email..." style="
                flex: 1;
                padding: 12px;
                border: 2px solid #ddd;
                border-radius: 8px;
                font-size: 14px;
              " onkeypress="if(event.key==='Enter') searchPlayers()">
              <button onclick="searchPlayers()" class="btn-primary" style="padding: 12px 30px;">
                Search
              </button>
            </div>
          </div>
          
          <div id="adminSearchResults">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Search for players to manage
            </div>
          </div>
        </div>
        
        <!-- Banned Tab -->
        <div id="adminTabBanned" class="admin-tab-content" style="display: none;">
          <h3 style="margin: 0 0 20px 0; color: var(--accent);">ðŸš« Banned Players</h3>
          <div id="bannedPlayersList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading banned players...
            </div>
          </div>
        </div>
        
        <!-- Warnings Tab -->
        <div id="adminTabWarnings" class="admin-tab-content" style="display: none;">
          <h3 style="margin: 0 0 20px 0; color: var(--accent);">âš ï¸ Player Warnings</h3>
          <div id="warningsList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading warnings...
            </div>
          </div>
        </div>
        
        <!-- Admins Tab (Super Admin Only) -->
        <div id="adminTabAdmins" class="admin-tab-content" style="display: none;">
          <h3 style="margin: 0 0 20px 0; color: var(--accent);">ðŸ‘® Admin Management</h3>
          <div id="adminsList">
            <div style="text-align: center; padding: 40px; color: #7f8c8d;">
              Loading admins...
            </div>
          </div>
        </div>
        
      </div>
    </div>
  </div>

  <!-- Ban Dialog Modal -->
  <div id="banDialog" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10002;
  ">
    <div style="
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    ">
      <h3 style="margin: 0 0 20px 0; color: #e74c3c; font-size: 22px;">ðŸš« Ban Player</h3>
      
      <p style="margin-bottom: 20px; color: #34495e;">
        You are about to ban <strong id="banPlayerName"></strong>
      </p>
      
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
        Ban Duration:
      </label>
      <select id="banDuration" style="
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        margin-bottom: 20px;
        font-family: Georgia, 'Times New Roman', serif;
      ">
        <option value="3600000">1 Hour</option>
        <option value="86400000">1 Day</option>
        <option value="259200000">3 Days</option>
        <option value="604800000" selected>7 Days</option>
        <option value="2592000000">30 Days</option>
        <option value="permanent">Permanent</option>
      </select>
      
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #2c3e50;">
        Reason (required):
      </label>
      <textarea id="banReason" placeholder="Enter reason for ban..." style="
        width: 100%;
        padding: 12px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        min-height: 100px;
        resize: vertical;
        margin-bottom: 20px;
        font-family: Georgia, 'Times New Roman', serif;
      "></textarea>
      
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button onclick="closeBanDialog()" style="
          padding: 12px 24px;
          background: #95a5a6;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 600;
          font-family: Georgia, 'Times New Roman', serif;
        ">
          Cancel
        </button>
        <button onclick="confirmBanFromDialog()" style="
          padding: 12px 24px;
          background: #e74c3c;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 600;
          font-family: Georgia, 'Times New Roman', serif;
        ">
          Ban Player
        </button>
      </div>
    </div>
  </div>

  <!-- Leaderboard Modal -->
  <div id="leaderboardModal" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 3000;
  ">
    <div style="background: white; border-radius: 12px; padding: 30px; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: var(--accent); margin: 0;">ðŸ† Leaderboard</h2>
        <button onclick="closeLeaderboard()" style="background: none; border: none; font-size: 24px; cursor: pointer;">Ã—</button>
      </div>
      <div id="leaderboardContent">
        Loading...
      </div>
    </div>
  </div>
  
  <!-- Dictionary Loading Status -->
  <div id="dict-status" style="
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #4CAF50;
    color: white;
    padding: 8px;
    text-align: center;
    z-index: 10000;
    font-size: 13px;
  ">
    ðŸ“š Loading SOWPODS dictionary (267K words)...
  </div>
  
  <h1>Scrabble</h1>
  
  <!-- Manual Test Button for Update Notification - DISABLED -->
  <!--
  <div style="position: fixed; bottom: 20px; left: 20px; z-index: 10000;">
    <button onclick="showUpdateNotification('1.0.1')" style="
      background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
      color: white;
      border: none;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(155, 89, 182, 0.4);
      transition: all 0.2s;
    " onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">
      ðŸ§ª Test Update Notification
    </button>
  </div>
  -->
  
  <div class="game-container" id="modeSelection" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Choose Game Mode</div>
      <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
        <button class="btn-primary" onclick="showDifficulty()" style="padding: 20px 40px; font-size: 1.2rem; text-align: center; min-width: 180px;">
          Play vs AI
        </button>
        <button class="btn-primary" onclick="showDeviceSelection()" style="padding: 20px 40px; font-size: 1.2rem; text-align: center; min-width: 180px;">
          Multiplayer
        </button>
      </div>
    </div>
  </div>

  <!-- Device Selection Screen -->
  <div class="game-container" id="deviceSelection" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Choose Play Mode</div>
      <div style="display: flex; flex-direction: column; gap: 20px; max-width: 500px; margin: 0 auto;">
        
        <button class="btn-primary" onclick="showPlayerNames()" style="padding: 30px; font-size: 1.1rem; text-align: left;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸ“± One Device (2 Players)</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Pass and play on the same device</div>
        </button>
        
        <button class="btn-primary" onclick="showMultiplayerSetup()" style="padding: 30px; font-size: 1.1rem; text-align: left;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸŒ Online (2-4 Players)</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Play with friends online â€¢ 2 players recommended</div>
        </button>
        <button class="btn-secondary" onclick="backToModeSelection()" style="margin-top: 20px;">
          Back
        </button>
      </div>
    </div>
  </div>

  <!-- Multiplayer Setup Screen -->
  <div class="game-container" id="multiplayerSetup" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Online Multiplayer</div>
      <div style="display: flex; flex-direction: column; gap: 20px; max-width: 500px; margin: 0 auto;">
        
        <!-- Calibration Required Banner -->
        <div id="calibrationBanner" style="display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 10px; text-align: left;">
          <div style="font-size: 1.1rem; font-weight: bold; margin-bottom: 8px;">ðŸŽ¯ Complete Calibration to Play Ranked</div>
          <div style="font-size: 0.9rem; opacity: 0.95; margin-bottom: 12px;">
            Play 3 games against AI to determine your skill level for fair matchmaking
          </div>
          <button onclick="startCalibration()" style="background: white; color: #667eea; border: none; padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.95rem;">
            Start Calibration (3 games)
          </button>
        </div>

        <!-- Ranked/Unranked Toggle -->
        <div id="rankedToggle" style="display: none; background: rgba(139, 90, 43, 0.1); padding: 15px; border-radius: 12px; margin-bottom: 10px;">
          <div style="font-size: 0.95rem; font-weight: 600; margin-bottom: 12px; text-align: left;">Game Type:</div>
          <div style="display: flex; gap: 10px;">
            <button id="rankedBtn" onclick="selectGameType('ranked')" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
              ðŸ† Ranked
            </button>
            <button id="unrankedBtn" onclick="selectGameType('unranked')" style="flex: 1; padding: 12px; background: #d0d0d0; color: #666; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
              ðŸŽ® Unranked
            </button>
          </div>
          <div id="rankedInfo" style="font-size: 0.85rem; opacity: 0.8; margin-top: 10px; text-align: left; display: none;">
            Your rating: <span id="userRatingDisplay">1000</span> â€¢ Affects your ranking
          </div>
          <div id="unrankedInfo" style="font-size: 0.85rem; opacity: 0.8; margin-top: 10px; text-align: left; display: none;">
            Casual play â€¢ No rating changes
          </div>
        </div>
        
        <!-- Name input -->
        <div>
          <label style="display: block; margin-bottom: 12px; font-weight: 600; text-align: left;">Your Name:</label>
          <input type="text" id="onlinePlayerName" placeholder="Enter your name" 
                 style="width: 100%; padding: 12px; font-size: 1rem; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;">
        </div>
        
        <button class="btn-primary" onclick="createOnlineGame()" style="padding: 30px; font-size: 1.1rem;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸŽ® Create Game</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Start a new game and share code with friend</div>
        </button>
        <button class="btn-primary" onclick="showJoinGame()" style="padding: 30px; font-size: 1.1rem;">
          <div style="font-weight: bold; margin-bottom: 8px;">ðŸ”‘ Join Game</div>
          <div style="font-size: 0.9rem; opacity: 0.9;">Enter a game code to join friend's game</div>
        </button>
        <button class="btn-secondary" onclick="backToDeviceSelection()" style="margin-top: 20px;">
          Back
        </button>
      </div>
    </div>
  </div>

  <!-- Create Game / Lobby Screen -->
  <div class="game-container" id="createGameScreen" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Game Lobby</div>
      <div style="max-width: 600px; margin: 0 auto;">
        
        <!-- Game Code Display -->
        <div id="gameCodeDisplay" style="display: none;">
          <div style="font-size: 1.1rem; margin-bottom: 15px;">Share this code with friends:</div>
          <div style="font-size: 3rem; font-weight: bold; color: var(--accent); padding: 30px; background: rgba(139, 90, 43, 0.1); border-radius: 12px; margin-bottom: 30px; letter-spacing: 8px;" id="gameCode"></div>
        </div>
        
        <!-- Connection Status -->
        <div id="connectionStatus" style="padding: 20px; background: rgba(139, 90, 43, 0.1); border-radius: 12px; margin-bottom: 20px;">
          <div style="font-size: 1.1rem; margin-bottom: 15px;">â³ Connecting to server...</div>
        </div>
        
        <!-- Players List -->
        <div id="lobbyPlayersSection" style="display: none;">
          <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 15px; text-align: left;">
            Players (<span id="playerCount">1</span>/4) 
            <span style="font-size: 0.9rem; opacity: 0.7; font-weight: normal;">â€¢ 2 recommended</span>
          </div>
          <div id="lobbyPlayersList" style="background: white; border-radius: 12px; padding: 15px; margin-bottom: 20px; text-align: left;">
            <!-- Players will be listed here -->
          </div>
          
          <!-- Host Controls -->
          <div id="hostControls" style="display: none;">
            <div style="font-size: 0.9rem; opacity: 0.8; margin-bottom: 15px;">
              âš ï¸ Need at least 2 players to start
            </div>
            <button id="startGameBtn" class="btn-primary" onclick="startLobbyGame()" disabled style="width: 100%; padding: 15px; font-size: 1.1rem; opacity: 0.5; cursor: not-allowed;">
              Start Game
            </button>
          </div>
          
          <!-- Non-host waiting -->
          <div id="waitingForHost" style="display: none;">
            <div style="font-size: 0.9rem; opacity: 0.8;">
              Waiting for host to start the game...
            </div>
          </div>
        </div>
        
        <button class="btn-secondary" onclick="cancelOnlineGame()" style="margin-top: 20px;">Leave Lobby</button>
      </div>
    </div>
  </div>

  <!-- Join Game Screen -->
  <div class="game-container" id="joinGameScreen" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Join Game</div>
      <div style="max-width: 500px; margin: 0 auto;">
        <label style="display: block; margin-bottom: 12px; font-weight: 600; text-align: left;">Enter Game Code:</label>
        <input type="text" id="joinGameCode" placeholder="XXXXXX" maxlength="6" 
               style="width: 100%; padding: 20px; font-size: 2rem; text-align: center; border: 2px solid var(--accent); border-radius: 12px; font-family: Georgia, serif; text-transform: uppercase; letter-spacing: 8px; margin-bottom: 20px;">
        <div id="joinStatus" style="min-height: 24px; color: #ff6b6b; margin-bottom: 20px;"></div>
        <div style="display: flex; gap: 15px;">
          <button class="btn-secondary" onclick="backToMultiplayerSetup()" style="flex: 1;">Back</button>
          <button class="btn-primary" onclick="joinOnlineGame()" style="flex: 1;">Join Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="game-container" id="difficultySelection" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Choose Your Opponent</div>
      <div style="max-width: 700px; margin: 0 auto;">
        
        <!-- Bot Selection Grid -->
        <div id="botGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; margin-bottom: 20px;">
          <!-- Bots will be inserted here by JavaScript -->
        </div>
        
        <button class="btn-secondary" onclick="backToModeSelection()" style="margin-top: 15px;">
          Back
        </button>
      </div>
    </div>
  </div>
  
  <style>
    /* Custom slider thumb */
    #difficultySlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: white;
      border: 3px solid var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    
    #difficultySlider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: white;
      border: 3px solid var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
  </style>

  <!-- ============================================ -->
  <!-- CALIBRATION SCREEN (v3.0.0) -->
  <!-- ============================================ -->
  <div class="game-container" id="calibrationScreen" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.8rem; margin-bottom: 10px; color: var(--accent); font-weight: bold;">ðŸŽ¯ Skill Calibration</div>
      <div style="font-size: 1rem; opacity: 0.8; margin-bottom: 30px;">Play 3 games to determine your rating</div>
      
      <div style="max-width: 600px; margin: 0 auto;">
        <!-- Progress Tracker -->
        <div style="background: rgba(139, 90, 43, 0.1); padding: 20px; border-radius: 12px; margin-bottom: 25px;">
          <div style="display: flex; justify-content: space-around; margin-bottom: 15px;">
            <div id="cal-progress-1" style="flex: 1; text-align: center; padding: 12px; border-radius: 8px; background: #e0e0e0; font-weight: 600;">
              Game 1
            </div>
            <div style="width: 15px;"></div>
            <div id="cal-progress-2" style="flex: 1; text-align: center; padding: 12px; border-radius: 8px; background: #e0e0e0; font-weight: 600;">
              Game 2
            </div>
            <div style="width: 15px;"></div>
            <div id="cal-progress-3" style="flex: 1; text-align: center; padding: 12px; border-radius: 8px; background: #e0e0e0; font-weight: 600;">
              Game 3
            </div>
          </div>
          <div id="provisionalRating" style="font-size: 1.1rem; font-weight: 600; color: var(--accent);">
            Provisional Rating: <span id="provRatingValue">---</span>
          </div>
        </div>

        <!-- Current Game Info -->
        <div id="calibrationGameInfo" style="background: white; padding: 25px; border-radius: 12px; border: 2px solid var(--accent); margin-bottom: 25px;">
          <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 12px; color: var(--accent);">
            Game <span id="calGameNumber">1</span> of 3
          </div>
          <div style="font-size: 1rem; margin-bottom: 8px;">
            Opponent: <span id="calBotName" style="font-weight: 600;">Medium Bot</span>
          </div>
          <div style="font-size: 0.95rem; opacity: 0.8;">
            Rating: <span id="calBotRating">1200</span>
          </div>
        </div>

        <!-- Start/Continue Button -->
        <button id="startCalibrationGameBtn" class="btn-primary" onclick="startCalibrationGame()" style="width: 100%; padding: 20px; font-size: 1.2rem; margin-bottom: 15px;">
          Start Game 1
        </button>

        <!-- Skip Option -->
        <button class="btn-secondary" onclick="skipCalibration()" style="width: 100%; padding: 12px;">
          Skip Calibration (Play Unranked Only)
        </button>

        <!-- How It Works -->
        <div style="margin-top: 25px; padding: 20px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; text-align: left;">
          <div style="font-weight: 600; margin-bottom: 10px; font-size: 0.95rem;">ðŸ“‹ How Calibration Works:</div>
          <ul style="margin: 0; padding-left: 20px; font-size: 0.9rem; opacity: 0.9; line-height: 1.6;">
            <li>Play 3 games against AI opponents</li>
            <li>System analyzes your move quality and results</li>
            <li>Difficulty adjusts based on your performance</li>
            <li>Final rating determines your matchmaking bracket</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Calibration Analysis Screen -->
  <div class="game-container" id="calibrationAnalysis" style="display: none;">
    <div style="text-align: center; padding: 60px 40px;">
      <div style="max-width: 500px; margin: 0 auto;">
        <div style="font-size: 1.5rem; margin-bottom: 20px; color: var(--accent); font-weight: bold;">
          <span id="analysisIcon">ðŸ”</span> Analyzing Your Performance...
        </div>
        
        <div style="background: rgba(139, 90, 43, 0.1); padding: 30px; border-radius: 12px; margin-bottom: 20px;">
          <div id="analysisProgress" style="font-size: 1rem; margin-bottom: 15px; opacity: 0.9;">
            Evaluating decision <span id="analysisMoveNum">1</span>/<span id="analysisTotalMoves">6</span>...
          </div>
          
          <!-- Progress Bar -->
          <div style="width: 100%; height: 12px; background: #e0e0e0; border-radius: 6px; overflow: hidden; margin-bottom: 10px;">
            <div id="analysisProgressBar" style="height: 100%; width: 0%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); transition: width 0.3s;"></div>
          </div>
          
          <div style="font-size: 0.85rem; opacity: 0.7; margin-top: 10px;">
            This helps determine your skill level for better matchmaking
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ============================================ -->
  <!-- ADMIN DASHBOARD (v1.7.0) -->
  <!-- ============================================ -->
  <div id="adminDashboard" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f5f7fa; z-index: 10000; overflow-y: auto;">
    <!-- Admin Header -->
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px 40px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center;">
      <div>
        <h1 style="margin: 0; font-size: 28px; font-weight: 700;">ðŸ‘® Admin Dashboard</h1>
        <p style="margin: 5px 0 0 0; opacity: 0.9; font-size: 14px;">Manage users, bans, and warnings</p>
      </div>
      <div style="display: flex; align-items: center; gap: 20px;">
        <div style="text-align: right;">
          <div style="font-size: 14px; font-weight: 600;" id="adminHeaderUsername">Admin</div>
          <div style="font-size: 12px; opacity: 0.8;" id="adminHeaderRole">Super Admin</div>
        </div>
        <button onclick="exitAdminDashboard()" style="padding: 10px 20px; background: rgba(255,255,255,0.2); border: 2px solid white; border-radius: 8px; color: white; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
          â† Back to Game
        </button>
      </div>
    </div>

    <!-- Quick Stats -->
    <div style="padding: 30px 40px; display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 20px;">
      <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); display: flex; align-items: center; gap: 15px;">
        <div style="width: 50px; height: 50px; border-radius: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; font-size: 24px;">ðŸ‘¥</div>
        <div>
          <div style="font-size: 13px; color: #64748b; margin-bottom: 4px;">Total Users</div>
          <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statTotalUsers">0</div>
        </div>
      </div>

      <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); display: flex; align-items: center; gap: 15px;">
        <div style="width: 50px; height: 50px; border-radius: 10px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); display: flex; align-items: center; justify-content: center; font-size: 24px;">ðŸŽ®</div>
        <div>
          <div style="font-size: 13px; color: #64748b; margin-bottom: 4px;">Active Games</div>
          <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statActiveGames">0</div>
        </div>
      </div>

      <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); display: flex; align-items: center; gap: 15px;">
        <div style="width: 50px; height: 50px; border-radius: 10px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); display: flex; align-items: center; justify-content: center; font-size: 24px;">ðŸš«</div>
        <div>
          <div style="font-size: 13px; color: #64748b; margin-bottom: 4px;">Banned Users</div>
          <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statBannedUsers">0</div>
        </div>
      </div>

      <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); display: flex; align-items: center; gap: 15px;">
        <div style="width: 50px; height: 50px; border-radius: 10px; background: linear-gradient(135deg, #ffa726 0%, #fb8c00 100%); display: flex; align-items: center; justify-content: center; font-size: 24px;">âš ï¸</div>
        <div>
          <div style="font-size: 13px; color: #64748b; margin-bottom: 4px;">Total Warnings</div>
          <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statTotalWarnings">0</div>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div style="padding: 0 40px 40px 40px;">
      <!-- Tabs -->
      <div style="background: white; border-radius: 12px; padding: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); margin-bottom: 20px; display: flex; gap: 8px;">
        <button onclick="switchAdminTab('users')" id="tabUsers" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
          ðŸ‘¥ Users
        </button>
        <button onclick="switchAdminTab('bans')" id="tabBans" style="flex: 1; padding: 12px; background: transparent; color: #64748b; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
          ðŸš« Banned
        </button>
        <button onclick="switchAdminTab('warnings')" id="tabWarnings" style="flex: 1; padding: 12px; background: transparent; color: #64748b; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
          âš ï¸ Warnings
        </button>
        <button onclick="switchAdminTab('admins')" id="tabAdmins" style="flex: 1; padding: 12px; background: transparent; color: #64748b; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
          ðŸ‘® Admins
        </button>
        <button onclick="switchAdminTab('calibration')" id="tabCalibration" style="flex: 1; padding: 12px; background: transparent; color: #64748b; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
          ðŸŽ¯ ELO/Calibration
        </button>
      </div>

      <!-- Users Tab Content -->
      <div id="adminTabUsers" style="background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h2 style="margin: 0; font-size: 20px; font-weight: 700; color: #1e293b;">User Management</h2>
          <input type="text" id="userSearchInput" placeholder="Search users..." onkeyup="filterAdminUsers()" style="padding: 8px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; width: 300px;">
        </div>
        <div style="overflow-x: auto;">
          <table id="usersTable" style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Display Name</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Role</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Join Date</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Last Active</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Games</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Win Rate</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Status</th>
                <th style="padding: 12px; text-align: right; font-size: 13px; font-weight: 600; color: #475569;">Actions</th>
              </tr>
            </thead>
            <tbody id="usersTableBody">
              <tr>
                <td colspan="8" style="padding: 40px; text-align: center; color: #94a3b8;">Loading users...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Bans Tab Content -->
      <div id="adminTabBans" style="display: none; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        <h2 style="margin: 0 0 20px 0; font-size: 20px; font-weight: 700; color: #1e293b;">Banned Users</h2>
        <div style="overflow-x: auto;">
          <table id="bansTable" style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">User</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Reason</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Banned By</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Banned At</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Expires</th>
                <th style="padding: 12px; text-align: right; font-size: 13px; font-weight: 600; color: #475569;">Actions</th>
              </tr>
            </thead>
            <tbody id="bansTableBody">
              <tr>
                <td colspan="6" style="padding: 40px; text-align: center; color: #94a3b8;">Loading bans...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Warnings Tab Content -->
      <div id="adminTabWarnings" style="display: none; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        <h2 style="margin: 0 0 20px 0; font-size: 20px; font-weight: 700; color: #1e293b;">Warnings Log</h2>
        <div style="overflow-x: auto;">
          <table id="warningsTable" style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">User</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Reason</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Warned By</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Date</th>
              </tr>
            </thead>
            <tbody id="warningsTableBody">
              <tr>
                <td colspan="4" style="padding: 40px; text-align: center; color: #94a3b8;">Loading warnings...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- Admins Tab Content -->
      <div id="adminTabAdmins" style="display: none; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h2 style="margin: 0; font-size: 20px; font-weight: 700; color: #1e293b;">Admin Management</h2>
          <input type="text" id="adminSearchInput" placeholder="Search by email or name..." onkeyup="filterAdmins()" style="padding: 8px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; width: 300px;">
        </div>
        <div style="overflow-x: auto;">
          <table id="adminsTable" style="width: 100%; border-collapse: collapse;">
            <thead>
              <tr style="background: #f8fafc; border-bottom: 2px solid #e2e8f0;">
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Name</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Email</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Role</th>
                <th style="padding: 12px; text-align: left; font-size: 13px; font-weight: 600; color: #475569;">Since</th>
                <th style="padding: 12px; text-align: right; font-size: 13px; font-weight: 600; color: #475569;">Actions</th>
              </tr>
            </thead>
            <tbody id="adminsTableBody">
              <tr>
                <td colspan="5" style="padding: 40px; text-align: center; color: #94a3b8;">Loading admins...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- ELO/Calibration Tab Content (v3.0.0) -->
      <div id="adminTabCalibration" style="display: none; background: white; border-radius: 12px; padding: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
        <h2 style="margin: 0 0 20px 0; font-size: 20px; font-weight: 700; color: #1e293b;">ðŸŽ¯ ELO & Calibration Management</h2>
        
        <!-- Admin Quick Actions -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 12px; margin-bottom: 24px; color: white;">
          <div style="font-size: 16px; font-weight: 600; margin-bottom: 16px;">âš¡ Admin Testing Tools</div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <!-- Skip Own Calibration -->
            <div style="background: rgba(255,255,255,0.15); padding: 16px; border-radius: 8px;">
              <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Skip Your Calibration</div>
              <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">Mark yourself as calibrated for testing</div>
              <button onclick="adminSkipOwnCalibration()" style="width: 100%; padding: 10px; background: white; color: #667eea; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                Skip My Calibration
              </button>
            </div>
            
            <!-- Set Own ELO -->
            <div style="background: rgba(255,255,255,0.15); padding: 16px; border-radius: 8px;">
              <div style="font-size: 14px; font-weight: 600; margin-bottom: 8px;">Set Your ELO</div>
              <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">Test matchmaking at different ratings</div>
              <div style="display: flex; gap: 8px;">
                <input type="number" id="adminEloInput" placeholder="Any rating" min="0" max="9999" value="1500" style="flex: 1; padding: 8px; border: none; border-radius: 6px; font-size: 13px;">
                <button onclick="adminSetOwnElo()" style="padding: 8px 16px; background: white; color: #667eea; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                  Set
                </button>
              </div>
            </div>
          </div>
          
          <div style="margin-top: 12px; font-size: 11px; opacity: 0.8; font-style: italic;">
            âš ï¸ These tools are for admin testing only. Changes affect your account.
          </div>
        </div>
        
        <!-- User ELO Management -->
        <div style="margin-bottom: 20px;">
          <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #1e293b;">Search User by Email</h3>
          <div style="display: flex; gap: 12px; margin-bottom: 16px;">
            <input type="email" id="calibrationUserEmail" placeholder="user@example.com" style="flex: 1; padding: 10px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px;">
            <button onclick="searchUserForCalibration()" style="padding: 10px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
              Search
            </button>
          </div>
          
          <!-- User Result -->
          <div id="calibrationUserResult" style="display: none; background: #f8fafc; padding: 16px; border-radius: 8px; border: 2px solid #e2e8f0;">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
              <div>
                <div style="font-weight: 600; font-size: 15px; color: #1e293b;" id="calUserName">-</div>
                <div style="font-size: 13px; color: #64748b;" id="calUserEmail">-</div>
              </div>
              <div style="text-align: right;">
                <div style="font-size: 12px; color: #64748b;">Current Rating</div>
                <div style="font-size: 20px; font-weight: 700; color: #667eea;" id="calUserRating">-</div>
              </div>
            </div>
            
            <div style="margin-bottom: 12px;">
              <div style="font-size: 13px; margin-bottom: 4px;">
                Status: <span id="calUserStatus" style="font-weight: 600;">-</span>
              </div>
              <div style="font-size: 13px;">
                Games Played: <span id="calUserGamesPlayed" style="font-weight: 600;">-</span>
              </div>
            </div>
            
            <!-- Actions -->
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; padding-top: 12px; border-top: 1px solid #e2e8f0;">
              <button onclick="resetUserCalibration()" style="padding: 8px; background: #fbbf24; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                Reset Calibration
              </button>
              <button onclick="completeUserCalibration()" style="padding: 8px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                Mark Complete
              </button>
              <button onclick="showSetUserEloModal()" style="padding: 8px; background: #667eea; color: white; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer;">
                Set ELO
              </button>
            </div>
          </div>
        </div>
        
        <!-- Calibration Statistics -->
        <div>
          <h3 style="margin: 0 0 12px 0; font-size: 16px; font-weight: 600; color: #1e293b;">Calibration Statistics</h3>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
            <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border-left: 4px solid #667eea;">
              <div style="font-size: 12px; color: #64748b; margin-bottom: 4px;">Pending Calibration</div>
              <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statPendingCal">0</div>
            </div>
            <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border-left: 4px solid #10b981;">
              <div style="font-size: 12px; color: #64748b; margin-bottom: 4px;">Completed</div>
              <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statCompletedCal">0</div>
            </div>
            <div style="background: #f8fafc; padding: 16px; border-radius: 8px; border-left: 4px solid #fbbf24;">
              <div style="font-size: 12px; color: #64748b; margin-bottom: 4px;">Avg Final Rating</div>
              <div style="font-size: 24px; font-weight: 700; color: #1e293b;" id="statAvgRating">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="game-container" id="playerNames" style="display: none;">
    <div style="text-align: center; padding: 40px;">
      <div style="font-size: 1.5rem; margin-bottom: 30px; color: var(--accent);">Enter Player Names</div>
      <div style="display: flex; flex-direction: column; gap: 20px; max-width: 400px; margin: 0 auto;">
        <div>
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">Player 1 Name:</label>
          <input type="text" id="player1Name" placeholder="Player 1" 
                 style="width: 100%; padding: 12px; font-size: 1rem; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;">
        </div>
        
        <div>
          <label style="display: block; margin-bottom: 8px; font-weight: 600;">Player 2 Name:</label>
          <input type="text" id="player2Name" placeholder="Player 2" 
                 style="width: 100%; padding: 12px; font-size: 1rem; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;">
        </div>
        
        <div style="display: flex; gap: 15px; margin-top: 20px;">
          <button class="btn-secondary" onclick="backToDeviceSelection()" style="flex: 1;">Back</button>
          <button class="btn-primary" onclick="startGameWithNames()" style="flex: 1;">Start Game</button>
        </div>
      </div>
    </div>
  </div>

  <div class="game-container" id="gameBoard" style="display: none;">
    <!-- Multi-player scores (v2.0.0) -->
    <div class="scores" id="multiplayerScores" style="display: none; flex-wrap: wrap; gap: 10px; justify-content: center;">
      <!-- Player score cards will be dynamically added here -->
    </div>
    
    <!-- Legacy 2-player scores -->
    <div class="scores" id="legacyScores">
      <div class="score-card active" id="playerScoreCard">
        <div class="score-label" id="player1Label">Player 1</div>
        <div class="score-value" id="playerScore">0</div>
      </div>
      <div class="score-card" id="aiScoreCard">
        <div class="score-label" id="player2Label">AI</div>
        <div class="score-value" id="aiScore">0</div>
      </div>
    </div>

    <!-- Turn transition overlay for 2-player mode -->
    <div id="turnTransition" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(139, 90, 43, 0.95); z-index: 1000; justify-content: center; align-items: center; flex-direction: column; gap: 30px;">
      <div style="font-size: 2.5rem; color: #f4e8d0; font-weight: bold; text-align: center;" id="transitionPlayerName"></div>
      <div style="font-size: 1.3rem; color: #e8d5b7; text-align: center; max-width: 500px; line-height: 1.6;">
        Pass the device to <span id="transitionNextPlayer" style="font-weight: bold;"></span>
      </div>
      <div style="font-size: 1rem; color: #e8d5b7; opacity: 0.9; text-align: center; max-width: 400px;">
        Your tiles will be hidden when the game starts. Click "Ready?" to begin your turn.
      </div>
      <button class="btn-primary" onclick="game.confirmTurnTransition()" style="padding: 20px 50px; font-size: 1.3rem;">
        Ready?
      </button>
    </div>

    <div class="message" id="message">Select tiles from your rack and click on the board to place them</div>
    
    <!-- Cheating penalty indicator - DISABLED
    <div id="cheatingWarning" style="display: none; text-align: center; padding: 15px; background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); border-radius: 8px; color: white; font-size: 1.1rem; font-weight: bold; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(201, 42, 42, 0.4); animation: pulse 1.5s ease-in-out infinite;">
      âš ï¸ CHEATING DETECTED! -10 Points Penalty âš ï¸
    </div>
    -->

    <div class="board-container">
      <div class="board" id="board"></div>
      <div class="info-panel">
        <div class="info-title">Game Info</div>
        <div class="info-item">
          <span>Tiles Remaining:</span>
          <span id="tilesRemaining">100</span>
        </div>
        <div class="info-item">
          <span>Your Turn:</span>
          <span id="turnIndicator">âœ“</span>
        </div>
        <div class="info-item">
          <span>Current Word Score:</span>
          <span id="currentScore">0</span>
        </div>
      </div>
    </div>

    <!-- Chat panel for online mode -->
    <div id="chatPanel" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 320px; background: var(--tile-bg); border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 100;">
      <div style="background: var(--accent); color: white; padding: 15px; border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
        <span style="font-weight: bold;">ðŸ’¬ Chat</span>
        <button onclick="toggleChat()" style="background: none; border: none; color: white; cursor: pointer; font-size: 1.2rem; padding: 0;">Ã—</button>
      </div>
      <div id="chatMessages" style="height: 250px; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; background: rgba(244, 232, 208, 0.3);">
        <!-- Messages appear here -->
      </div>
      <div style="padding: 10px; border-top: 2px solid var(--accent);">
        <div style="display: flex; gap: 8px;">
          <input type="text" id="chatInput" placeholder="Type a message..." 
                 style="flex: 1; padding: 10px; border: 2px solid var(--accent); border-radius: 8px; font-family: Georgia, serif;"
                 onkeypress="if(event.key === 'Enter') sendChatMessage()">
          <button onclick="sendChatMessage()" class="btn-primary" style="padding: 10px 20px;">Send</button>
        </div>
      </div>
    </div>

    <!-- Chat toggle button (only visible in online mode) -->
    <button id="chatToggle" onclick="toggleChat()" style="display: none; position: fixed; bottom: 20px; right: 20px; width: 60px; height: 60px; border-radius: 50%; background: var(--accent); color: white; border: none; cursor: pointer; font-size: 1.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 99;">
      ðŸ’¬
    </button>

    <div class="rack-container">
      <!-- Tile Bag Icon -->
      <div id="tileBag" style="position: absolute; top: -60px; right: 20px; font-size: 3rem; opacity: 0.7; pointer-events: none;">
        ðŸŽ’
      </div>
      <div class="rack" id="rack"></div>
      <div class="controls">
        <button class="btn-primary" id="playBtn">Play Word</button>
        <button class="btn-secondary" id="shuffleBtn">Shuffle Rack</button>
        <button class="btn-secondary" id="recallBtn">Recall Tiles</button>
        <button class="btn-secondary" id="passBtn">Pass Turn</button>
        <button class="btn-secondary" id="hideTilesBtn" style="display: none;">ðŸ‘ï¸ Hide Tiles</button>
      </div>
    </div>
  </div>

  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
    // ========================================
    // AUTHENTICATION SYSTEM (v1.5.0 - Supabase)
    // ========================================
    let currentUser = null;
    let userStats = null;
    let isAnonymousMode = false;
    
    // ============================================
    // GOOGLE OAUTH AUTHENTICATION
    // ============================================
    
    async function signInWithGoogle() {
      try {
        console.log('ðŸ” Starting Google sign in...');
        
        // Check if Supabase is loaded
        if (!window.supabase) {
          console.error('âŒ Supabase not loaded!');
          alert('Error: Authentication service not loaded. Please refresh the page.');
          return;
        }
        
        console.log('âœ… Supabase loaded:', window.supabase);
        
        // Hardcoded redirect URL for GitHub Pages
        const redirectUrl = 'https://thitikhacharoen.github.io/Scrabble/';
        console.log('ðŸ“ Redirect URL:', redirectUrl);
        
        const { data, error} = await window.supabase.auth.signInWithOAuth({
          provider: 'google',
          options: {
            redirectTo: redirectUrl,
            queryParams: {
              access_type: 'offline',
              prompt: 'consent',
            }
          }
        });
        
        if (error) {
          console.error('âŒ Google sign in error:', error);
          alert('Failed to sign in with Google: ' + error.message);
          return;
        }
        
        console.log('âœ… Redirecting to Google...');
        // User will be redirected to Google, then back to our app
        // onAuthStateChange will handle the rest when they return
      } catch (error) {
        console.error('âŒ Sign in error:', error);
        alert('An error occurred during sign in');
      }
    }
    
    // ============================================
    // ADMIN DASHBOARD FUNCTIONS (v1.7.0)
    // ============================================
    
    function openAdminDashboard() {
      // Check if user has admin permissions
      if (!currentUser || !['owner', 'admin', 'super_admin'].includes(currentUser.role)) {
        alert('Access denied. Admin permissions required.');
        return;
      }
      
      // Hide game, show admin dashboard
      window.location.hash = 'admin';
      document.getElementById('adminDashboard').style.display = 'block';
      toggleSettingsPanel(); // Close settings panel
      
      // Hide hamburger menu in admin panel
      const userMenuBtn = document.getElementById('userMenuBtn');
      if (userMenuBtn) userMenuBtn.style.display = 'none';
      
      // Update header with user info
      const displayName = currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
      document.getElementById('adminHeaderUsername').textContent = displayName;
      const roleDisplay = currentUser.role === 'super_admin' ? 'Owner' : currentUser.role.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
      document.getElementById('adminHeaderRole').textContent = roleDisplay;
      
      // Load admin data
      loadAdminStats();
      loadAdminUsers();
    }
    
    function exitAdminDashboard() {
      window.location.hash = '';
      document.getElementById('adminDashboard').style.display = 'none';
      
      // Show hamburger menu again
      const userMenuBtn = document.getElementById('userMenuBtn');
      if (userMenuBtn && !isAnonymousMode) userMenuBtn.style.display = 'flex';
    }
    
    function switchAdminTab(tab) {
      // Update tab buttons
      const tabs = ['users', 'bans', 'warnings', 'admins', 'calibration'];
      tabs.forEach(t => {
        const btn = document.getElementById('tab' + t.charAt(0).toUpperCase() + t.slice(1));
        const content = document.getElementById('adminTab' + t.charAt(0).toUpperCase() + t.slice(1));
        
        if (t === tab) {
          btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          btn.style.color = 'white';
          content.style.display = 'block';
        } else {
          btn.style.background = 'transparent';
          btn.style.color = '#64748b';
          content.style.display = 'none';
        }
      });
      
      // Load data for selected tab
      if (tab === 'users') loadAdminUsers();
      else if (tab === 'bans') loadAdminBans();
      else if (tab === 'warnings') loadAdminWarnings();
      else if (tab === 'admins') loadAdmins();
      else if (tab === 'calibration') loadCalibrationStats();
    }
    
    async function loadAdminStats() {
      try {
        // Total users
        const { count: totalUsers } = await window.supabase
          .from('users')
          .select('*', { count: 'exact', head: true });
        document.getElementById('statTotalUsers').textContent = totalUsers || 0;
        
        // Active games
        const { count: activeGames } = await window.supabase
          .from('games')
          .select('*', { count: 'exact', head: true })
          .eq('status', 'active');
        document.getElementById('statActiveGames').textContent = activeGames || 0;
        
        // Banned users
        const { count: bannedUsers } = await window.supabase
          .from('bans')
          .select('*', { count: 'exact', head: true })
          .eq('active', true);
        document.getElementById('statBannedUsers').textContent = bannedUsers || 0;
        
        // Total warnings
        const { count: totalWarnings } = await window.supabase
          .from('warnings')
          .select('*', { count: 'exact', head: true });
        document.getElementById('statTotalWarnings').textContent = totalWarnings || 0;
        
      } catch (error) {
        console.error('Error loading admin stats:', error);
      }
    }
    
    async function loadAdminUsers() {
      try {
        const { data: users, error } = await window.supabase
          .from('users')
          .select('*')
          .order('created_at', { ascending: false });
        
        if (error) throw error;
        
        const tbody = document.getElementById('usersTableBody');
        tbody.innerHTML = '';
        
        if (!users || users.length === 0) {
          tbody.innerHTML = '<tr><td colspan="8" style="padding: 40px; text-align: center; color: #94a3b8;">No users found</td></tr>';
          return;
        }
        
        users.forEach(user => {
          const displayName = user.display_name || user.email.split('@')[0];
          const joinDate = new Date(user.created_at).toLocaleDateString();
          const lastActive = user.last_active ? new Date(user.last_active).toLocaleDateString() : 'Never';
          const gamesPlayed = user.games_played || 0;
          const winRate = gamesPlayed > 0 ? ((user.wins || 0) / gamesPlayed * 100).toFixed(1) + '%' : '0%';
          const status = user.is_banned ? 'ðŸš« Banned' : 'âœ… Active';
          
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid #e2e8f0';
          row.innerHTML = `
            <td style="padding: 12px; color: #1e293b;">${displayName}</td>
            <td style="padding: 12px;"><span style="padding: 4px 12px; background: #f1f5f9; border-radius: 12px; font-size: 12px; font-weight: 600; color: #475569;">${user.role || 'user'}</span></td>
            <td style="padding: 12px; color: #64748b;">${joinDate}</td>
            <td style="padding: 12px; color: #64748b;">${lastActive}</td>
            <td style="padding: 12px; color: #64748b;">${gamesPlayed}</td>
            <td style="padding: 12px; color: #64748b;">${winRate}</td>
            <td style="padding: 12px; color: #1e293b;">${status}</td>
            <td style="padding: 12px; text-align: right;">
              <button onclick="showUserActions('${user.id}')" style="padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                Actions
              </button>
            </td>
          `;
          tbody.appendChild(row);
        });
        
      } catch (error) {
        console.error('Error loading users:', error);
        document.getElementById('usersTableBody').innerHTML = '<tr><td colspan="8" style="padding: 40px; text-align: center; color: #ef4444;">Error loading users</td></tr>';
      }
    }
    
    async function loadAdminBans() {
      try {
        const { data: bans, error } = await window.supabase
          .from('bans')
          .select('*')
          .eq('active', true)
          .order('created_at', { ascending: false });
        
        if (error) {
          console.error('Error loading bans:', error);
          if (error.code === '42P01' || error.message.includes('relation') || error.message.includes('does not exist')) {
            document.getElementById('bansTableBody').innerHTML = '<tr><td colspan="6" style="padding: 40px; text-align: center; color: #94a3b8;">âš ï¸ Bans table not set up yet. Create the table in Supabase to use this feature.</td></tr>';
            return;
          }
          throw error;
        }
        
        const tbody = document.getElementById('bansTableBody');
        tbody.innerHTML = '';
        
        if (!bans || bans.length === 0) {
          tbody.innerHTML = '<tr><td colspan="6" style="padding: 40px; text-align: center; color: #94a3b8;">No active bans</td></tr>';
          return;
        }
        
        // Load user details for each ban
        for (const ban of bans) {
          let userName = 'Unknown User';
          let bannedBy = 'System';
          
          // Try to get banned user details
          if (ban.user_id) {
            const { data: user } = await window.supabase
              .from('users')
              .select('display_name, email')
              .eq('id', ban.user_id)
              .single();
            
            if (user) {
              userName = user.display_name || user.email?.split('@')[0] || 'Unknown';
            }
          }
          
          // Try to get banned_by details
          if (ban.banned_by) {
            const { data: banAdmin } = await window.supabase
              .from('users')
              .select('display_name, email')
              .eq('id', ban.banned_by)
              .single();
            
            if (banAdmin) {
              bannedBy = banAdmin.display_name || banAdmin.email?.split('@')[0] || 'Admin';
            }
          }
          
          const bannedAt = new Date(ban.created_at).toLocaleString();
          const expires = ban.expires_at ? new Date(ban.expires_at).toLocaleString() : 'Permanent';
          
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid #e2e8f0';
          row.innerHTML = `
            <td style="padding: 12px;">${userName}</td>
            <td style="padding: 12px; color: #64748b;">${ban.reason || 'No reason provided'}</td>
            <td style="padding: 12px; color: #64748b;">${bannedBy}</td>
            <td style="padding: 12px; color: #64748b;">${bannedAt}</td>
            <td style="padding: 12px; color: #64748b;">${expires}</td>
            <td style="padding: 12px; text-align: right;">
              <button onclick="unbanUser('${ban.user_id}')" style="padding: 6px 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                Unban
              </button>
            </td>
          `;
          tbody.appendChild(row);
        }
        
      } catch (error) {
        console.error('Error loading bans:', error);
        document.getElementById('bansTableBody').innerHTML = '<tr><td colspan="6" style="padding: 40px; text-align: center; color: #ef4444;">Error loading bans: ' + error.message + '</td></tr>';
      }
    }
    
    async function loadAdminWarnings() {
      try {
        // Try to load warnings - if table doesn't exist, show friendly message
        const { data: warnings, error } = await window.supabase
          .from('warnings')
          .select('*')
          .order('created_at', { ascending: false })
          .limit(100);
        
        if (error) {
          console.error('Error loading warnings:', error);
          // Check if it's a table not found error
          if (error.code === '42P01' || error.message.includes('relation') || error.message.includes('does not exist')) {
            document.getElementById('warningsTableBody').innerHTML = '<tr><td colspan="4" style="padding: 40px; text-align: center; color: #94a3b8;">âš ï¸ Warnings table not set up yet. Create the table in Supabase to use this feature.</td></tr>';
            return;
          }
          throw error;
        }
        
        const tbody = document.getElementById('warningsTableBody');
        tbody.innerHTML = '';
        
        if (!warnings || warnings.length === 0) {
          tbody.innerHTML = '<tr><td colspan="4" style="padding: 40px; text-align: center; color: #94a3b8;">No warnings issued yet</td></tr>';
          return;
        }
        
        // Load user details for each warning
        for (const warning of warnings) {
          let userName = 'Unknown User';
          let warnedBy = 'System';
          
          // Try to get user details
          if (warning.user_id) {
            const { data: user } = await window.supabase
              .from('users')
              .select('display_name, email')
              .eq('id', warning.user_id)
              .single();
            
            if (user) {
              userName = user.display_name || user.email?.split('@')[0] || 'Unknown';
            }
          }
          
          // Try to get warned_by details
          if (warning.warned_by) {
            const { data: warningAdmin } = await window.supabase
              .from('users')
              .select('display_name, email')
              .eq('id', warning.warned_by)
              .single();
            
            if (warningAdmin) {
              warnedBy = warningAdmin.display_name || warningAdmin.email?.split('@')[0] || 'Admin';
            }
          }
          
          const date = new Date(warning.created_at).toLocaleString();
          
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid #e2e8f0';
          row.innerHTML = `
            <td style="padding: 12px;">${userName}</td>
            <td style="padding: 12px; color: #64748b;">${warning.reason || 'No reason provided'}</td>
            <td style="padding: 12px; color: #64748b;">${warnedBy}</td>
            <td style="padding: 12px; color: #64748b;">${date}</td>
          `;
          tbody.appendChild(row);
        }
        
      } catch (error) {
        console.error('Error loading warnings:', error);
        document.getElementById('warningsTableBody').innerHTML = '<tr><td colspan="4" style="padding: 40px; text-align: center; color: #ef4444;">Error loading warnings: ' + error.message + '</td></tr>';
      }
    }
    
    function filterAdminUsers() {
      const input = document.getElementById('userSearchInput').value.toLowerCase();
      const table = document.getElementById('usersTable');
      const rows = table.getElementsByTagName('tr');
      
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const text = row.textContent || row.innerText;
        row.style.display = text.toLowerCase().indexOf(input) > -1 ? '' : 'none';
      }
    }
    
    function filterAdmins() {
      const input = document.getElementById('adminSearchInput').value.toLowerCase();
      const table = document.getElementById('adminsTable');
      const rows = table.getElementsByTagName('tr');
      
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const text = row.textContent || row.innerText;
        row.style.display = text.toLowerCase().indexOf(input) > -1 ? '' : 'none';
      }
    }
    
    async function loadAdmins() {
      try {
        const { data: admins, error } = await window.supabase
          .from('users')
          .select('*')
          .in('role', ['owner', 'admin', 'super_admin'])
          .order('created_at', { ascending: true });
        
        if (error) throw error;
        
        const tbody = document.getElementById('adminsTableBody');
        tbody.innerHTML = '';
        
        if (!admins || admins.length === 0) {
          tbody.innerHTML = '<tr><td colspan="5" style="padding: 40px; text-align: center; color: #94a3b8;">No admins found</td></tr>';
          return;
        }
        
        admins.forEach(admin => {
          const displayName = admin.display_name || admin.email.split('@')[0];
          const since = new Date(admin.created_at).toLocaleDateString();
          const isCurrentUser = currentUser && admin.id === currentUser.id;
          
          // Role badge colors
          let roleColor = '#94a3b8';
          if (admin.role === 'owner') roleColor = '#ef4444';
          else if (admin.role === 'super_admin') roleColor = '#f59e0b';
          else if (admin.role === 'admin') roleColor = '#8b5cf6';
          
          const row = document.createElement('tr');
          row.style.borderBottom = '1px solid #e2e8f0';
          row.innerHTML = `
            <td style="padding: 12px; color: #1e293b;">${displayName}${isCurrentUser ? ' <span style="color: #667eea; font-size: 11px;">(You)</span>' : ''}</td>
            <td style="padding: 12px; color: #64748b;">${admin.email}</td>
            <td style="padding: 12px;"><span style="padding: 4px 12px; background: ${roleColor}; color: white; border-radius: 12px; font-size: 12px; font-weight: 600;">${admin.role === 'super_admin' ? 'OWNER' : admin.role.replace('_', ' ').toUpperCase()}</span></td>
            <td style="padding: 12px; color: #64748b;">${since}</td>
            <td style="padding: 12px; text-align: right;">
              ${admin.role !== 'owner' && admin.role !== 'super_admin' && ['owner', 'super_admin'].includes(currentUser.role) ? `
                <button onclick="changeUserRole('${admin.id}', 'user')" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                  Demote to User
                </button>
              ` : (isCurrentUser ? '<span style="color: #94a3b8; font-size: 12px;">You</span>' : '<span style="color: #94a3b8; font-size: 12px;">â€”</span>')}
            </td>
          `;
          tbody.appendChild(row);
        });
        
      } catch (error) {
        console.error('Error loading admins:', error);
        document.getElementById('adminsTableBody').innerHTML = '<tr><td colspan="5" style="padding: 40px; text-align: center; color: #ef4444;">Error loading admins</td></tr>';
      }
    }
    
    async function changeUserRole(userId, newRole) {
      if (!confirm(`Are you sure you want to change this user's role to "${newRole}"?`)) return;
      
      try {
        const { error } = await window.supabase
          .from('users')
          .update({ role: newRole })
          .eq('id', userId);
        
        if (error) throw error;
        
        alert('Role updated successfully!');
        loadAdmins(); // Reload the list
      } catch (error) {
        console.error('Error changing role:', error);
        alert('Error changing role: ' + error.message);
      }
    }
    
    function showUserActions(userId) {
      // For now, just alert. We'll add a proper modal later if needed
      alert('User actions for: ' + userId + '\n\nFeatures:\n- Warn user\n- Ban user\n- Change role\n\nComing soon!');
    }
    
    async function unbanUser(userId) {
      if (!confirm('Are you sure you want to unban this user?')) return;
      
      try {
        const { error } = await window.supabase
          .from('bans')
          .update({ active: false })
          .eq('user_id', userId)
          .eq('active', true);
        
        if (error) throw error;
        
        alert('User unbanned successfully!');
        loadAdminBans();
        loadAdminStats();
      } catch (error) {
        console.error('Error unbanning user:', error);
        alert('Failed to unban user: ' + error.message);
      }
    }
    
    // ============================================
    // v3.0.0 ADMIN CALIBRATION FUNCTIONS
    // ============================================
    
    let selectedCalibrationUser = null;
    
    async function loadCalibrationStats() {
      try {
        // Pending calibration
        const { count: pending } = await window.supabase
          .from('users')
          .select('*', { count: 'exact', head: true })
          .eq('calibration_status', 'pending');
        document.getElementById('statPendingCal').textContent = pending || 0;
        
        // Completed calibration
        const { count: completed } = await window.supabase
          .from('users')
          .select('*', { count: 'exact', head: true })
          .eq('calibration_status', 'completed');
        document.getElementById('statCompletedCal').textContent = completed || 0;
        
        // Average rating
        const { data: users } = await window.supabase
          .from('users')
          .select('rating')
          .eq('calibration_status', 'completed');
        
        if (users && users.length > 0) {
          const avg = Math.round(users.reduce((sum, u) => sum + (u.rating || 0), 0) / users.length);
          document.getElementById('statAvgRating').textContent = avg;
        } else {
          document.getElementById('statAvgRating').textContent = '0';
        }
      } catch (error) {
        console.error('Error loading calibration stats:', error);
      }
    }
    
    async function adminSkipOwnCalibration() {
      if (!confirm('Skip your own calibration?\n\nThis will mark you as calibrated with rating 1500.')) {
        return;
      }
      
      try {
        const { error } = await window.supabase
          .from('users')
          .update({
            calibration_status: 'completed',
            calibration_games_played: 3,
            rating: 1500
          })
          .eq('id', currentUser.id);
        
        if (error) throw error;
        
        currentUser.calibration_status = 'completed';
        currentUser.rating = 1500;
        
        alert('âœ… Calibration skipped! Your rating is now 1500.');
        loadCalibrationStats();
      } catch (error) {
        console.error('Error skipping calibration:', error);
        alert('Error: ' + error.message);
      }
    }
    
    async function adminSetOwnElo() {
      const rating = parseInt(document.getElementById('adminEloInput').value);
      
      if (isNaN(rating) || rating < 0) {
        alert('Please enter a valid rating (0 or higher)');
        return;
      }
      
      try {
        const { error } = await window.supabase
          .from('users')
          .update({
            rating: rating,
            calibration_status: 'completed',
            calibration_games_played: 3
          })
          .eq('id', currentUser.id);
        
        if (error) throw error;
        
        currentUser.rating = rating;
        currentUser.calibration_status = 'completed';
        
        alert(`âœ… Your ELO is now ${rating}`);
        loadCalibrationStats();
      } catch (error) {
        console.error('Error setting ELO:', error);
        alert('Error: ' + error.message);
      }
    }
    
    async function searchUserForCalibration() {
      const email = document.getElementById('calibrationUserEmail').value.trim();
      
      if (!email) {
        alert('Please enter an email address');
        return;
      }
      
      try {
        const { data, error } = await window.supabase
          .from('users')
          .select('*')
          .eq('email', email)
          .single();
        
        if (error) {
          if (error.code === 'PGRST116') {
            alert('User not found');
            return;
          }
          throw error;
        }
        
        selectedCalibrationUser = data;
        
        // Display user info
        document.getElementById('calibrationUserResult').style.display = 'block';
        document.getElementById('calUserName').textContent = data.display_name || data.email;
        document.getElementById('calUserEmail').textContent = data.email;
        document.getElementById('calUserRating').textContent = data.rating || 1000;
        document.getElementById('calUserStatus').textContent = data.calibration_status || 'pending';
        document.getElementById('calUserGamesPlayed').textContent = data.calibration_games_played || 0;
        
      } catch (error) {
        console.error('Error searching user:', error);
        alert('Error: ' + error.message);
      }
    }
    
    async function resetUserCalibration() {
      if (!selectedCalibrationUser) return;
      
      if (!confirm(`Reset calibration for ${selectedCalibrationUser.display_name}?\n\nThis will set them back to pending status.`)) {
        return;
      }
      
      try {
        const { error } = await window.supabase
          .from('users')
          .update({
            calibration_status: 'pending',
            calibration_games_played: 0,
            rating: 1000
          })
          .eq('id', selectedCalibrationUser.id);
        
        if (error) throw error;
        
        // Delete calibration games
        await window.supabase
          .from('calibration_games')
          .delete()
          .eq('user_id', selectedCalibrationUser.id);
        
        alert('âœ… Calibration reset successfully');
        searchUserForCalibration(); // Refresh
        loadCalibrationStats();
      } catch (error) {
        console.error('Error resetting calibration:', error);
        alert('Error: ' + error.message);
      }
    }
    
    async function completeUserCalibration() {
      if (!selectedCalibrationUser) return;
      
      if (!confirm(`Mark calibration as complete for ${selectedCalibrationUser.display_name}?`)) {
        return;
      }
      
      try {
        const { error } = await window.supabase
          .from('users')
          .update({
            calibration_status: 'completed',
            calibration_games_played: 3
          })
          .eq('id', selectedCalibrationUser.id);
        
        if (error) throw error;
        
        alert('âœ… Calibration marked as complete');
        searchUserForCalibration(); // Refresh
        loadCalibrationStats();
      } catch (error) {
        console.error('Error completing calibration:', error);
        alert('Error: ' + error.message);
      }
    }
    
    function showSetUserEloModal() {
      if (!selectedCalibrationUser) return;
      
      const newRating = prompt(
        `Set ELO for ${selectedCalibrationUser.display_name}\n\nCurrent: ${selectedCalibrationUser.rating || 1000}\n\nEnter new rating:`,
        selectedCalibrationUser.rating || 1000
      );
      
      if (!newRating) return;
      
      const rating = parseInt(newRating);
      if (isNaN(rating) || rating < 0) {
        alert('Invalid rating. Must be 0 or higher.');
        return;
      }
      
      setUserElo(rating);
    }
    
    async function setUserElo(rating) {
      if (!selectedCalibrationUser) return;
      
      try {
        const { error } = await window.supabase
          .from('users')
          .update({
            rating: rating,
            calibration_status: 'completed'
          })
          .eq('id', selectedCalibrationUser.id);
        
        if (error) throw error;
        
        alert(`âœ… ELO set to ${rating}`);
        searchUserForCalibration(); // Refresh
        loadCalibrationStats();
      } catch (error) {
        console.error('Error setting ELO:', error);
        alert('Error: ' + error.message);
      }
    }
    
    // Check hash on page load
    window.addEventListener('hashchange', () => {
      if (window.location.hash === '#admin') {
        openAdminDashboard();
      } else {
        exitAdminDashboard();
      }
    });
    
    async function handleAuthChange(session) {
      currentUser = session.user;
      await loadUserData(); // Wait for user data to load
      
      // Check ban status
      const isAllowed = await checkBanStatus();
      if (!isAllowed) {
        return; // User is banned, ban screen is shown
      }
      
      // Show admin options if user is admin/owner (AFTER loadUserData completes)
      console.log('ðŸ” Admin Check:', {
        username: currentUser.username,
        role: currentUser.role,
        hasAdminRole: ['owner', 'admin', 'super_admin'].includes(currentUser.role)
      });
      
      const adminPanelOption = document.getElementById('adminPanelOption');
      const adminTabBtn = document.getElementById('adminTabBtn');
      const adminSubTabAdmins = document.getElementById('adminSubTabAdmins');
      
      if (currentUser && ['owner', 'admin', 'super_admin'].includes(currentUser.role)) {
        // Show admin option in side panel menu
        if (adminPanelOption) adminPanelOption.style.display = 'flex';
        
        // Show admin tab in settings
        if (adminTabBtn) adminTabBtn.style.display = 'flex';
        
        // Show admins subtab only for owners and super_admins
        if (['owner', 'super_admin'].includes(currentUser.role) && adminSubTabAdmins) {
          adminSubTabAdmins.style.display = 'block';
        }
        
        console.log('âœ… Admin access granted');
      } else {
        // Hide admin options for regular players
        if (adminPanelOption) adminPanelOption.style.display = 'none';
        if (adminTabBtn) adminTabBtn.style.display = 'none';
        console.log('âŒ Admin access denied - not an admin');
      }
      
      // Check for warnings
      if (currentUser && currentUser.status === 'warned' && currentUser.warn_reason) {
        alert(`âš ï¸ WARNING\n\nYou have received a warning:\n${currentUser.warn_reason}\n\nPlease follow the community guidelines to avoid further action.`);
      }
      
      showGameInterface();
    }
    
    function showAuthInterface() {
      document.getElementById('authContainer').style.display = 'flex';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('settingsBtn').style.display = 'none';
    }
    
    function showGameInterface() {
      document.getElementById('authContainer').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'flex';
      
      if (!isAnonymousMode) {
        // Show user menu button (hamburger icon)
        const userMenuBtn = document.getElementById('userMenuBtn');
        if (userMenuBtn) {
          userMenuBtn.style.display = 'flex';
        }
        
        updateProfileDisplay();
      } else {
        document.getElementById('anonymousToggle').style.display = 'block';
      }
    }
    
    function playAnonymously() {
      isAnonymousMode = true;
      currentUser = null;
      userStats = null;
      showGameInterface();
      
      // Hide online multiplayer option for anonymous users
      const multiplayerBtn = document.querySelector('button[onclick="showDeviceSelection()"]');
      if (multiplayerBtn) {
        multiplayerBtn.style.display = 'none';
      }
    }
    
    function showLogin() {
      document.getElementById('loginScreen').style.display = 'block';
      document.getElementById('signupScreen').style.display = 'none';
      document.getElementById('forgotPasswordScreen').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('signupError').style.display = 'none';
    }
    
    function showSignup() {
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('signupScreen').style.display = 'block';
      document.getElementById('forgotPasswordScreen').style.display = 'none';
      document.getElementById('loginError').style.display = 'none';
      document.getElementById('signupError').style.display = 'none';
    }
    
    function showForgotPassword() {
      document.getElementById('loginScreen').style.display = 'none';
      document.getElementById('signupScreen').style.display = 'none';
      document.getElementById('forgotPasswordScreen').style.display = 'block';
      document.getElementById('resetMessage').style.display = 'none';
    }
    
    // v1.4.2: Toggle password visibility
    function togglePasswordVisibility(inputId) {
      const input = document.getElementById(inputId);
      const button = input.nextElementSibling;
      
      if (input.type === 'password') {
        input.type = 'text';
        button.textContent = 'ðŸ‘ï¸â€ðŸ—¨ï¸'; // Eye with speech bubble (hidden)
      } else {
        input.type = 'password';
        button.textContent = 'ðŸ‘ï¸'; // Regular eye (visible)
      }
    }
    

    // ============================================
    // REMOVED: Email/password auth functions
    // (handleLogin, handleSignup, handlePasswordReset)
    // Using Google OAuth only
    // ============================================

    
    async function handleLogout() {
      try {
        // Close user panel first
        const panel = document.getElementById('userSidePanel');
        const overlay = document.getElementById('panelOverlay');
        if (panel) panel.style.left = '-350px';
        if (overlay) overlay.style.display = 'none';
        
        // Sign out from Supabase
        await window.supabase.auth.signOut();
        
        console.log('âœ… Logged out');
        // onAuthStateChange will handle showing login screen
      } catch (error) {
        console.error('Logout error:', error);
      }
    }
    
    // v1.5.0: Supabase - No separate createUserDocument needed, done in handleSignup
    
    async function loadUserData() {
      try {
        // Load user data from Supabase
        const { data: userData, error } = await window.supabase
          .from('users')
          .select('*')
          .eq('id', currentUser.id)
          .single();
        
        if (error && error.code === 'PGRST116') {
          // User doesn't exist in database - create record (first-time Google OAuth user)
          console.log('ðŸ†• Creating database record for new Google user...');
          
          // Get display name from Google metadata
          let displayName = 'Player' + Date.now();
          if (currentUser.user_metadata?.full_name) {
            displayName = currentUser.user_metadata.full_name;
          } else if (currentUser.user_metadata?.name) {
            displayName = currentUser.user_metadata.name;
          } else if (currentUser.email) {
            displayName = currentUser.email.split('@')[0];
          }
          
          // Create database record
          const { data: newUser, error: insertError } = await window.supabase
            .from('users')
            .insert({
              id: currentUser.id,
              email: currentUser.email,
              display_name: displayName,
              games_played: 0,
              wins: 0,
              losses: 0,
              rating: 1000,
              highest_score: 0,
              total_points: 0
            })
            .select()
            .single();
          
          if (insertError) {
            console.error('âŒ Failed to create user record:', insertError);
            return;
          }
          
          console.log('âœ… Database record created');
          
          // Use the newly created record
          currentUser.display_name = newUser.display_name;
          currentUser.role = newUser.role || 'user';
          currentUser.status = newUser.status || 'active';
          currentUser.games_played = 0;
          currentUser.wins = 0;
          currentUser.losses = 0;
          currentUser.rating = 1000;
          currentUser.highest_score = 0;
          currentUser.total_points = 0;
          
          userStats = {
            username: newUser.display_name,
            stats: {
              gamesPlayed: 0,
              wins: 0,
              losses: 0,
              highestScore: 0,
              totalPoints: 0
            }
          };
          
          return;
        } else if (error) {
          console.error('Error loading user data:', error);
          return;
        }
        
        if (userData) {
          // Merge database data into currentUser
          currentUser.display_name = userData.display_name || userData.username || userData.email.split('@')[0];
          currentUser.role = userData.role || 'user';
          currentUser.status = userData.status || 'active';
          currentUser.games_played = userData.games_played || 0;
          currentUser.wins = userData.wins || 0;
          currentUser.losses = userData.losses || 0;
          currentUser.rating = userData.rating || 1000;
          currentUser.highest_score = userData.highest_score || 0;
          currentUser.total_points = userData.total_points || 0;
          
          // Ban info
          currentUser.ban_reason = userData.ban_reason;
          currentUser.ban_expires_at = userData.ban_expires_at;
          currentUser.ban_permanent = userData.ban_permanent;
          currentUser.banned_at = userData.banned_at;
          
          // Warn info
          currentUser.warn_reason = userData.warn_reason;
          currentUser.warned_at = userData.warned_at;
          
          // Set userStats for compatibility
          userStats = {
            username: userData.username,
            stats: {
              gamesPlayed: userData.games_played || 0,
              wins: userData.wins || 0,
              losses: userData.losses || 0,
              highestScore: userData.highest_score || 0,
              totalPoints: userData.total_points || 0
            }
          };
          
          console.log('ðŸ‘¤ User loaded:', {
            username: currentUser.username,
            role: currentUser.role,
            status: currentUser.status
          });
        }
      } catch (error) {
        console.error('Error loading user data:', error);
      }
    }
    
    function updateProfileDisplay() {
      if (!currentUser || !userStats) return;
      
      const displayName = currentUser.display_name || currentUser.user_metadata?.full_name || currentUser.email.split('@')[0];
      document.getElementById('profileUsername').textContent = displayName;
      document.getElementById('profileEmail').textContent = currentUser.email;
      
      // ELO Rating
      document.getElementById('statsEloRating').textContent = currentUser.rating || 1000;
      
      const stats = userStats.stats;
      document.getElementById('statsGamesPlayed').textContent = stats.gamesPlayed || 0;
      document.getElementById('statsWins').textContent = stats.wins || 0;
      document.getElementById('statsLosses').textContent = stats.losses || 0;
      document.getElementById('statsHighScore').textContent = stats.highestScore || 0;
      
      // Average score
      const avgScore = stats.gamesPlayed > 0 ? Math.round((stats.totalPoints || 0) / stats.gamesPlayed) : 0;
      document.getElementById('statsAvgScore').textContent = avgScore;
      
      // Total points (format with commas)
      document.getElementById('statsTotalPoints').textContent = (stats.totalPoints || 0).toLocaleString();
      
      // Win rate
      const winRate = stats.gamesPlayed > 0 ? Math.round((stats.wins / stats.gamesPlayed) * 100) : 0;
      document.getElementById('statsWinRate').textContent = winRate + '%';
      
      // Win streak
      document.getElementById('statsWinStreak').textContent = stats.winStreak || 0;
      
      // Best word
      const bestWord = stats.bestWord && stats.bestWord.word ? 
        `${stats.bestWord.word} (${stats.bestWord.points} pts)` : 'â€”';
      document.getElementById('statsBestWord').textContent = bestWord;
    }
    
    // User Side Panel Functions
    function toggleUserPanel() {
      const panel = document.getElementById('userSidePanel');
      const overlay = document.getElementById('panelOverlay');
      const isOpen = panel.style.left === '0px';
      
      if (isOpen) {
        // Close panel
        panel.style.left = '-350px';
        overlay.style.display = 'none';
      } else {
        // Open panel
        panel.style.left = '0px';
        overlay.style.display = 'block';
        
        // Update user info in header
        if (currentUser) {
          document.getElementById('panelUsername').textContent = currentUser.username || 'Player';
          document.getElementById('panelEmail').textContent = currentUser.email || '';
          document.getElementById('panelGamesPlayed').textContent = currentUser.games_played || 0;
          document.getElementById('panelWins').textContent = currentUser.wins || 0;
        }
        
        // Update stats in expandable section
        if (userStats && userStats.stats) {
          document.getElementById('menuStatsElo').textContent = currentUser.rating || 1000;
          document.getElementById('menuStatsGamesPlayed').textContent = userStats.stats.gamesPlayed || 0;
          document.getElementById('menuStatsWins').textContent = userStats.stats.wins || 0;
          document.getElementById('menuStatsLosses').textContent = userStats.stats.losses || 0;
          document.getElementById('menuStatsHighScore').textContent = userStats.stats.highestScore || 0;
          
          const gamesPlayed = userStats.stats.gamesPlayed || 0;
          const wins = userStats.stats.wins || 0;
          const winRate = gamesPlayed > 0 ? Math.round((wins / gamesPlayed) * 100) : 0;
          document.getElementById('menuStatsWinRate').textContent = winRate + '%';
        }
      }
    }
    
    // Toggle expandable sections in left panel
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);
      const toggleIcon = document.getElementById(sectionId.replace('Content', 'Toggle'));
      
      if (section.style.display === 'none' || section.style.display === '') {
        // Open section
        section.style.display = 'block';
        if (toggleIcon) toggleIcon.textContent = 'â–²';
      } else {
        // Close section
        section.style.display = 'none';
        if (toggleIcon) toggleIcon.textContent = 'â–¼';
      }
    }
    
    // Open settings panel from left menu
    function openSettingsPanel() {
      // Close left panel
      toggleUserPanel();
      
      // Open right settings panel to general tab (has themes)
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('general');
    }
    
    // Switch theme from menu (stays in menu, doesn't close)
    function switchThemeInMenu(themeName) {
      // Update body class
      document.body.className = 'theme-' + themeName;
      
      // Save preference
      localStorage.setItem('scrabble_theme', themeName);
      currentTheme = themeName;
      
      // Update active state in menu
      const menuButtons = document.querySelectorAll('.theme-option-menu');
      menuButtons.forEach(btn => {
        const isActive = btn.getAttribute('data-theme') === themeName;
        btn.style.border = isActive ? '2px solid var(--accent)' : '2px solid #ddd';
        
        const checkMark = btn.querySelector('.theme-check-menu');
        if (checkMark) {
          checkMark.style.color = isActive ? 'var(--accent)' : '#ddd';
        }
        
        if (isActive) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      console.log('âœ¨ Theme changed to:', themeName);
    }
    
    function showPanelAdmin() {
      // Close side panel
      toggleUserPanel();
      
      // Open settings panel to admin tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('admin');
    }
    
    function showAdvancedStats() {
      // Close dropdown
      document.getElementById('userDropdownMenu').style.display = 'none';
      
      // Open settings panel to profile tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('profile');
    }
    
    function showSettingsMenu() {
      // Close dropdown
      document.getElementById('userDropdownMenu').style.display = 'none';
      
      // Open settings panel to general tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('general');
    }
    
    function showAdminPanel() {
      // Close dropdown
      document.getElementById('userDropdownMenu').style.display = 'none';
      
      // Open settings panel to admin tab
      document.getElementById('settingsPanel').style.right = '0px';
      switchSettingsTab('admin');
    }
    
    function toggleSettingsPanel() {
      const panel = document.getElementById('settingsPanel');
      const settingsBtn = document.getElementById('settingsBtn');
      const isOpen = panel.style.right === '0px';
      
      panel.style.right = isOpen ? '-450px' : '0px';
      
      // v1.3.2 Fix: Hide settings button when panel is open, show when closed
      settingsBtn.style.display = isOpen ? 'block' : 'none';
      
      if (!isOpen) {
        updateProfileDisplay();
        switchSettingsTab('profile'); // Default to profile tab
        
        // Update theme selector to show current theme
        const currentTheme = document.body.className.replace('theme-', '');
        const options = document.querySelectorAll('.theme-option-settings');
        options.forEach(option => {
          const isActive = option.dataset.theme === currentTheme;
          option.style.border = isActive ? '2px solid var(--accent)' : '2px solid #ddd';
          const check = option.querySelector('.theme-check-settings');
          if (check) check.style.color = isActive ? 'var(--accent)' : '#ddd';
        });
      }
    }
    
    function switchSettingsTab(tabName) {
      // Hide all tab contents
      document.getElementById('profileTabContent').style.display = 'none';
      document.getElementById('generalTabContent').style.display = 'none';
      document.getElementById('adminTabContent').style.display = 'none';
      
      // Remove active class from all tabs
      const tabs = document.querySelectorAll('.settings-tab');
      tabs.forEach(tab => {
        tab.style.background = 'transparent';
        tab.style.borderBottom = '3px solid transparent';
        tab.style.color = '#7f8c8d';
      });
      
      // Show selected tab content and activate tab
      if (tabName === 'profile') {
        document.getElementById('profileTabContent').style.display = 'block';
        const tab = document.getElementById('profileTab');
        tab.style.background = 'white';
        tab.style.borderBottom = '3px solid var(--accent)';
        tab.style.color = 'var(--accent)';
      } else if (tabName === 'general') {
        document.getElementById('generalTabContent').style.display = 'block';
        const tab = document.getElementById('generalTab');
        tab.style.background = 'white';
        tab.style.borderBottom = '3px solid var(--accent)';
        tab.style.color = 'var(--accent)';
      } else if (tabName === 'admin') {
        document.getElementById('adminTabContent').style.display = 'block';
        const tab = document.getElementById('adminTabBtn');
        tab.style.background = 'white';
        tab.style.borderBottom = '3px solid var(--accent)';
        tab.style.color = 'var(--accent)';
        
        // Load admin data when tab is opened
        switchAdminSubTab('players');
      }
    }
    

    // REMOVED: switchAdminSubTab function (dead code - old admin panel removed)

    
    function switchThemeFromSettings(themeName) {
      // Call existing switchTheme function
      switchTheme(themeName);
      
      // Update active state in settings
      const options = document.querySelectorAll('.theme-option-settings');
      options.forEach(option => {
        const isActive = option.dataset.theme === themeName;
        option.style.border = isActive ? '2px solid var(--accent)' : '2px solid #ddd';
        const check = option.querySelector('.theme-check-settings');
        check.style.color = isActive ? 'var(--accent)' : '#ddd';
        
        if (isActive) {
          option.classList.add('active');
        } else {
          option.classList.remove('active');
        }
      });
    }
    
    function toggleSound(enabled) {
      if (typeof SFX !== 'undefined') {
        SFX.enabled = enabled;
      }
    }
    
    async function showLeaderboard() {
      document.getElementById('leaderboardModal').style.display = 'flex';
      const content = document.getElementById('leaderboardContent');
      content.innerHTML = '<div style="text-align: center; padding: 20px;">Loading...</div>';
      
      try {
        const { query, collection, orderBy, limit, getDocs } = window.firebaseDBFunctions;
        const leaderboardQuery = query(
          collection(window.firebaseDB, 'leaderboard'),
          orderBy('wins', 'desc'),
          limit(100)
        );
        
        const snapshot = await getDocs(leaderboardQuery);
        
        if (snapshot.empty) {
          content.innerHTML = '<div style="text-align: center; padding: 20px; color: #7f8c8d;">No players yet. Be the first!</div>';
          return;
        }
        
        let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
        let rank = 1;
        
        snapshot.forEach((doc) => {
          const data = doc.data();
          const isCurrentUser = currentUser && doc.id === currentUser.uid;
          
          html += `
            <div style="
              display: flex;
              align-items: center;
              padding: 15px;
              background: ${isCurrentUser ? '#fff3cd' : '#f8f9fa'};
              border-radius: 8px;
              border-left: 4px solid ${rank <= 3 ? '#f39c12' : '#dee2e6'};
            ">
              <div style="font-size: 20px; font-weight: bold; min-width: 40px; color: ${rank <= 3 ? '#f39c12' : '#7f8c8d'};">
                ${rank <= 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][rank - 1] : rank}
              </div>
              <div style="flex: 1;">
                <div style="font-weight: bold;">${data.username}${isCurrentUser ? ' (You)' : ''}</div>
                <div style="font-size: 12px; color: #7f8c8d;">
                  ${data.gamesPlayed} games â€¢ ${data.winRate}% win rate â€¢ High: ${data.highestScore}
                </div>
              </div>
              <div style="font-size: 24px; font-weight: bold; color: #27ae60;">
                ${data.wins}
              </div>
            </div>
          `;
          rank++;
        });
        
        html += '</div>';
        content.innerHTML = html;
      } catch (error) {
        console.error('Leaderboard error:', error);
        content.innerHTML = '<div style="text-align: center; padding: 20px; color: #e74c3c;">Error loading leaderboard</div>';
      }
    }
    
    function closeLeaderboard() {
      document.getElementById('leaderboardModal').style.display = 'none';
    }
    
    async function saveGameResult(playerWon, playerScore, aiScore) {
      // Skip saving for anonymous users
      if (isAnonymousMode || !currentUser || !userStats) return;
      
      const { doc, updateDoc } = window.firebaseDBFunctions;
      const userRef = doc(window.firebaseDB, 'users', currentUser.uid);
      const leaderboardRef = doc(window.firebaseDB, 'leaderboard', currentUser.uid);
      
      // Calculate new win streak
      const newWinStreak = playerWon ? (userStats.stats.winStreak || 0) + 1 : 0;
      const longestWinStreak = Math.max(userStats.stats.longestWinStreak || 0, newWinStreak);
      
      // Update stats
      const newStats = {
        gamesPlayed: userStats.stats.gamesPlayed + 1,
        wins: userStats.stats.wins + (playerWon ? 1 : 0),
        losses: userStats.stats.losses + (playerWon ? 0 : 1),
        highestScore: Math.max(userStats.stats.highestScore, playerScore),
        lowestScore: userStats.stats.lowestScore === null ? playerScore : Math.min(userStats.stats.lowestScore, playerScore),
        totalPoints: userStats.stats.totalPoints + playerScore,
        averageScore: Math.round((userStats.stats.totalPoints + playerScore) / (userStats.stats.gamesPlayed + 1)),
        winStreak: newWinStreak,
        longestWinStreak: longestWinStreak
      };
      
      // Track bots beaten
      const botName = currentBotPersonality ? currentBotPersonality.name : 'AI';
      const botsBeaten = userStats.stats.botsBeaten || {};
      if (playerWon && currentBotPersonality) {
        botsBeaten[botName] = (botsBeaten[botName] || 0) + 1;
      }
      
      // Add to game history
      const gameRecord = {
        date: new Date().toISOString(),
        won: playerWon,
        playerScore: playerScore,
        opponentScore: aiScore,
        opponent: botName,
        botRating: currentBotPersonality ? currentBotPersonality.rating : null
      };
      
      const newHistory = [gameRecord, ...(userStats.gameHistory || [])].slice(0, 10);
      
      try {
        // Update user document
        await updateDoc(userRef, {
          'stats.gamesPlayed': newStats.gamesPlayed,
          'stats.wins': newStats.wins,
          'stats.losses': newStats.losses,
          'stats.highestScore': newStats.highestScore,
          'stats.lowestScore': newStats.lowestScore,
          'stats.totalPoints': newStats.totalPoints,
          'stats.averageScore': newStats.averageScore,
          'stats.winStreak': newStats.winStreak,
          'stats.longestWinStreak': newStats.longestWinStreak,
          'stats.botsBeaten': botsBeaten,
          gameHistory: newHistory
        });
        
        // Update leaderboard
        const winRate = Math.round((newStats.wins / newStats.gamesPlayed) * 100);
        await updateDoc(leaderboardRef, {
          wins: newStats.wins,
          gamesPlayed: newStats.gamesPlayed,
          highestScore: newStats.highestScore,
          winRate: winRate,
          averageScore: newStats.averageScore
        });
        
        // Reload user data
        await loadUserData();
      } catch (error) {
        console.error('Error saving game result:', error);
      }
    }
    
    function getErrorMessage(errorCode) {
      const messages = {
        'auth/email-already-in-use': 'Email already in use',
        'auth/invalid-email': 'Invalid email address',
        'auth/weak-password': 'Password is too weak',
        'auth/user-not-found': 'No account found with this email',
        'auth/wrong-password': 'Incorrect password',
        'auth/too-many-requests': 'Too many attempts. Try again later',
        'auth/network-request-failed': 'Network error. Check your connection'
      };
      return messages[errorCode] || 'An error occurred. Please try again';
    }
    
    // v1.5.0: Supabase error messages
    function getSupabaseErrorMessage(errorMessage) {
      if (errorMessage.includes('Invalid login credentials')) {
        return 'Invalid email or password';
      }
      if (errorMessage.includes('User already registered')) {
        return 'Email already in use';
      }
      if (errorMessage.includes('Password should be at least')) {
        return 'Password must be at least 6 characters';
      }
      if (errorMessage.includes('Unable to validate email address')) {
        return 'Invalid email address';
      }
      if (errorMessage.includes('Email rate limit exceeded')) {
        return 'Too many attempts. Try again later';
      }
      return errorMessage || 'An error occurred. Please try again';
    }
    
    // ========================================
    // END AUTHENTICATION SYSTEM
    // ========================================
    
    let gameMode = null; // 'ai' or 'human' or 'online'
    let aiDifficulty = 5; // 1-10 difficulty scale
    let player1Name = 'Player 1';
    let player2Name = 'Player 2';
    let player1Code = null;
    let player2Code = null;
    let usePasscodes = false;
    let game = null; // Global game instance
    
    // Online multiplayer variables (v2.0.0 - Multi-player support)
    let peer = null;
    let connections = {}; // Map of player_id -> connection object
    let isHost = false;
    let myGameCode = null;
    let currentGameId = null; // Database game ID
    let lobbyPlayers = []; // Array of player objects in lobby
    let myPlayerId = null; // My player ID in the game
    let myPlayerOrder = null; // My turn order (1, 2, 3, or 4)
    let currentPlayerIndex = 0; // Index in lobbyPlayers array for current turn
    let myOnlineName = 'Player';
    let startingPlayer = null; // Will be randomized

    // Sound Effects System
    const SFX = {
      enabled: true,
      context: null,
      
      init() {
        if (!this.context) {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
        }
      },
      
      // Play tile click sound
      tileClick() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.value = 800;
        osc.type = 'sine';
        
        gain.gain.setValueAtTime(0.1, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.1);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.1);
      },
      
      // Play tile placement sound
      tilePlaced() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.value = 600;
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.15, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.15);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.15);
      },
      
      // Play word validation success
      wordSuccess() {
        if (!this.enabled) return;
        this.init();
        
        // Play chord of notes
        const frequencies = [523.25, 659.25, 783.99]; // C, E, G
        frequencies.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          
          osc.connect(gain);
          gain.connect(this.context.destination);
          
          osc.frequency.value = freq;
          osc.type = 'sine';
          
          const startTime = this.context.currentTime + (i * 0.05);
          gain.gain.setValueAtTime(0.1, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);
          
          osc.start(startTime);
          osc.stop(startTime + 0.3);
        });
      },
      
      // Play word validation failure
      wordFail() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.value = 200;
        osc.type = 'sawtooth';
        
        gain.gain.setValueAtTime(0.2, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.3);
      },
      
      // Play shuffle sound
      shuffle() {
        if (!this.enabled) return;
        this.init();
        
        for (let i = 0; i < 5; i++) {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          
          osc.connect(gain);
          gain.connect(this.context.destination);
          
          osc.frequency.value = 300 + Math.random() * 200;
          osc.type = 'square';
          
          const startTime = this.context.currentTime + (i * 0.05);
          gain.gain.setValueAtTime(0.05, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.08);
          
          osc.start(startTime);
          osc.stop(startTime + 0.08);
        }
      },
      
      // Play turn change sound
      turnChange() {
        if (!this.enabled) return;
        this.init();
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.connect(gain);
        gain.connect(this.context.destination);
        
        osc.frequency.setValueAtTime(400, this.context.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, this.context.currentTime + 0.2);
        osc.type = 'triangle';
        
        gain.gain.setValueAtTime(0.15, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
        
        osc.start(this.context.currentTime);
        osc.stop(this.context.currentTime + 0.3);
      },
      
      // Play game over sound
      gameOver() {
        if (!this.enabled) return;
        this.init();
        
        // Descending notes
        const frequencies = [659.25, 587.33, 523.25, 440.00]; // E, D, C, A
        frequencies.forEach((freq, i) => {
          const osc = this.context.createOscillator();
          const gain = this.context.createGain();
          
          osc.connect(gain);
          gain.connect(this.context.destination);
          
          osc.frequency.value = freq;
          osc.type = 'sine';
          
          const startTime = this.context.currentTime + (i * 0.15);
          gain.gain.setValueAtTime(0.15, startTime);
          gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);
          
          osc.start(startTime);
          osc.stop(startTime + 0.4);
        });
      }
    };

    // ========================================
    // BOT PERSONALITY SYSTEM
    // ========================================
    const BOT_PERSONALITIES = [
      {
        id: 1,
        name: 'Bot 1',
        rating: 300,
        stars: 1,
        strategy: 'Random word placement, no strategy',
        behavior: 'random',
        icon: 'ðŸ£'
      },
      {
        id: 2,
        name: 'Bot 2',
        rating: 600,
        stars: 2,
        strategy: 'Always seeks double/triple word scores',
        behavior: 'bonus_hunter',
        icon: 'ðŸ’Ž'
      },
      {
        id: 3,
        name: 'Bot 3',
        rating: 900,
        stars: 3,
        strategy: 'Prefers long words (5+ letters)',
        behavior: 'word_wizard',
        icon: 'ðŸ“š'
      },
      {
        id: 4,
        name: 'Bot 4',
        rating: 1200,
        stars: 3,
        strategy: 'Holds tiles for better opportunities',
        behavior: 'patient',
        icon: 'â³'
      },
      {
        id: 5,
        name: 'Bot 5',
        rating: 1500,
        stars: 4,
        strategy: 'Balanced approach, considers all factors',
        behavior: 'opportunist',
        icon: 'ðŸŽ¯'
      },
      {
        id: 6,
        name: 'Bot 6',
        rating: 1800,
        stars: 4,
        strategy: 'Blocks opponent, opens bonuses strategically',
        behavior: 'tactical',
        icon: 'ðŸ§ '
      },
      {
        id: 7,
        name: 'Bot 7',
        rating: 2100,
        stars: 5,
        strategy: '2-move lookahead, tournament level',
        behavior: 'master',
        icon: 'ðŸ†'
      }
    ];
    
    // ============================================
    // v3.0.0 CALIBRATION SYSTEM
    // ============================================
    
    // Calibration state
    let calibrationState = {
      inProgress: false,
      currentGame: 0,
      games: [],
      provisionalRating: null,
      gameHistory: [] // Stores moves for analysis
    };
    
    // Current game type
    let currentGameType = 'unranked'; // 'ranked' or 'unranked'
    
    // Move flagging for calibration
    let currentMoveData = {
      moveNumber: 0,
      criticalMoves: [],
      allMoves: []
    };
    
    function showDifficulty() {
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'flex';
      
      // Generate bot selection grid
      const botGrid = document.getElementById('botGrid');
      botGrid.innerHTML = '';
      
      BOT_PERSONALITIES.forEach(bot => {
        const botCard = document.createElement('button');
        botCard.className = 'bot-card';
        botCard.onclick = () => startGameWithBot(bot.id);
        
        const stars = 'â­'.repeat(bot.stars);
        
        botCard.innerHTML = `
          <div class="bot-icon">${bot.icon}</div>
          <div class="bot-name">${bot.name}</div>
          <div class="bot-stars">${stars}</div>
          <div class="bot-rating">Rating: ${bot.rating}</div>
          <div class="bot-strategy">${bot.strategy}</div>
        `;
        
        botGrid.appendChild(botCard);
      });
    }
    
    function startGameWithBot(botId) {
      const bot = BOT_PERSONALITIES.find(b => b.id === botId);
      // Map bot ID to old difficulty level for now (will update AI logic later)
      const difficultyMapping = {
        1: 1,   // Random
        2: 3,   // Bonus hunter
        3: 5,   // Word wizard
        4: 6,   // Patient
        5: 7,   // Opportunist (lookahead)
        6: 9,   // Tactical (lookahead)
        7: 10   // Master (lookahead)
      };
      
      currentBotPersonality = bot;
      startGame('ai', difficultyMapping[botId]);
    }
    
    // ============================================
    // v3.0.0 CALIBRATION FUNCTIONS
    // ============================================
    
    function selectGameType(type) {
      currentGameType = type;
      const rankedBtn = document.getElementById('rankedBtn');
      const unrankedBtn = document.getElementById('unrankedBtn');
      const rankedInfo = document.getElementById('rankedInfo');
      const unrankedInfo = document.getElementById('unrankedInfo');
      
      if (type === 'ranked') {
        rankedBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        rankedBtn.style.color = 'white';
        unrankedBtn.style.background = '#d0d0d0';
        unrankedBtn.style.color = '#666';
        rankedInfo.style.display = 'block';
        unrankedInfo.style.display = 'none';
      } else {
        rankedBtn.style.background = '#d0d0d0';
        rankedBtn.style.color = '#666';
        unrankedBtn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
        unrankedBtn.style.color = 'white';
        rankedInfo.style.display = 'none';
        unrankedInfo.style.display = 'block';
      }
    }
    
    async function checkCalibrationStatus() {
      if (!currentUser) return false;
      
      try {
        const { data, error } = await window.supabase
          .from('users')
          .select('calibration_status, rating')
          .eq('id', currentUser.id)
          .single();
        
        if (error) throw error;
        
        const needsCalibration = data.calibration_status === 'pending';
        
        // Update UI based on status
        const calibrationBanner = document.getElementById('calibrationBanner');
        const rankedToggle = document.getElementById('rankedToggle');
        const userRatingDisplay = document.getElementById('userRatingDisplay');
        
        if (needsCalibration) {
          calibrationBanner.style.display = 'block';
          rankedToggle.style.display = 'none';
          currentGameType = 'unranked'; // Force unranked
        } else {
          calibrationBanner.style.display = 'none';
          rankedToggle.style.display = 'block';
          if (userRatingDisplay) {
            userRatingDisplay.textContent = data.rating || 1000;
          }
        }
        
        return needsCalibration;
      } catch (error) {
        console.error('Error checking calibration status:', error);
        return false;
      }
    }
    
    function startCalibration() {
      // Hide multiplayer setup, show calibration screen
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('calibrationScreen').style.display = 'flex';
      
      // Reset calibration state
      calibrationState = {
        inProgress: true,
        currentGame: 1,
        games: [],
        provisionalRating: null,
        gameHistory: []
      };
      
      // Update UI for game 1
      updateCalibrationUI();
    }
    
    function skipCalibration() {
      if (!confirm('Are you sure you want to skip calibration?\n\nYou will only be able to play unranked games.')) {
        return;
      }
      
      // Return to multiplayer setup
      document.getElementById('calibrationScreen').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'flex';
    }
    
    function updateCalibrationUI() {
      const gameNum = calibrationState.currentGame;
      
      // Update progress indicators
      for (let i = 1; i <= 3; i++) {
        const elem = document.getElementById(`cal-progress-${i}`);
        if (i < gameNum) {
          elem.style.background = '#4CAF50';
          elem.style.color = 'white';
        } else if (i === gameNum) {
          elem.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          elem.style.color = 'white';
        } else {
          elem.style.background = '#e0e0e0';
          elem.style.color = '#666';
        }
      }
      
      // Update game info
      document.getElementById('calGameNumber').textContent = gameNum;
      
      // Select bot based on provisional rating or default
      let targetRating = 1200; // Start with Medium
      if (calibrationState.provisionalRating) {
        targetRating = calibrationState.provisionalRating;
      }
      
      const selectedBot = getClosestBot(targetRating);
      document.getElementById('calBotName').textContent = selectedBot.name;
      document.getElementById('calBotRating').textContent = selectedBot.rating;
      
      // Update provisional rating display
      if (calibrationState.provisionalRating !== null) {
        document.getElementById('provRatingValue').textContent = calibrationState.provisionalRating;
      } else {
        document.getElementById('provRatingValue').textContent = '---';
      }
      
      // Update button text
      const btn = document.getElementById('startCalibrationGameBtn');
      btn.textContent = `Start Game ${gameNum}`;
    }
    
    function getClosestBot(targetRating) {
      let closest = BOT_PERSONALITIES[0];
      let minDiff = Math.abs(BOT_PERSONALITIES[0].rating - targetRating);
      
      for (const bot of BOT_PERSONALITIES) {
        const diff = Math.abs(bot.rating - targetRating);
        if (diff < minDiff) {
          minDiff = diff;
          closest = bot;
        }
      }
      
      return closest;
    }
    
    function startCalibrationGame() {
      // Get the bot for current calibration game
      let targetRating = 1200;
      if (calibrationState.provisionalRating) {
        targetRating = calibrationState.provisionalRating;
      }
      
      const bot = getClosestBot(targetRating);
      currentBotPersonality = bot;
      
      // Map bot to difficulty
      const difficultyMapping = {
        1: 1, 2: 3, 3: 5, 4: 6, 5: 7, 6: 9, 7: 10
      };
      
      // Reset move tracking
      currentMoveData = {
        moveNumber: 0,
        criticalMoves: [],
        allMoves: []
      };
      
      // Hide calibration screen
      document.getElementById('calibrationScreen').style.display = 'none';
      
      // Start the game
      isCalibrationGame = true;
      startGame('ai', difficultyMapping[bot.id]);
    }
    
    // Flag moves during calibration
    function flagMoveIfCritical(board, rack, playerMove, validMoves) {
      if (!isCalibrationGame) return;
      
      currentMoveData.moveNumber++;
      
      // Store move data
      const moveData = {
        moveNum: currentMoveData.moveNumber,
        board: JSON.parse(JSON.stringify(board)),
        rack: [...rack],
        playerMove: { ...playerMove },
        timestamp: Date.now()
      };
      
      currentMoveData.allMoves.push(moveData);
      
      // Quick flagging criteria
      const topMoves = validMoves
        .sort((a, b) => b.score - a.score)
        .slice(0, 5);
      
      // Flag 1: Multiple competitive options
      const hasChoices = topMoves.length >= 3 && 
        (topMoves[0].score - topMoves[2].score) < 15;
      
      // Flag 2: Bingo available
      const hasBingo = topMoves.some(m => m.word && m.word.length === 7);
      
      // Flag 3: High-value tiles
      const hasHighValue = rack.some(t => 'QZXJK'.includes(t));
      
      // Flag 4: Endgame (last 10 tiles)
      const isEndgame = tileBag.length <= 10;
      
      // Flag 5: Premium squares available
      const hasPremium = topMoves.some(m => m.score >= 30);
      
      if (hasChoices || hasBingo || hasHighValue || isEndgame || hasPremium) {
        moveData.isCritical = true;
        currentMoveData.criticalMoves.push(moveData);
        console.log(`ðŸŽ¯ Move ${moveData.moveNum} flagged for analysis`);
      }
    }
    
    // Called when calibration game ends
    async function onCalibrationGameEnd(playerScore, botScore) {
      const gameNum = calibrationState.currentGame;
      const bot = currentBotPersonality;
      
      // Store game result
      const gameResult = {
        gameNumber: gameNum,
        botName: bot.name,
        botRating: bot.rating,
        playerScore: playerScore,
        botScore: botScore,
        totalMoves: currentMoveData.allMoves.length,
        criticalMovesCount: currentMoveData.criticalMoves.length,
        criticalMoves: currentMoveData.criticalMoves
      };
      
      calibrationState.games.push(gameResult);
      
      // Show analysis screen
      await analyzeCalibrationGame(gameResult);
    }
    
    async function analyzeCalibrationGame(gameResult) {
      // Show analysis screen
      document.getElementById('calibrationAnalysis').style.display = 'flex';
      
      const criticalMoves = gameResult.criticalMoves;
      const totalToAnalyze = Math.min(criticalMoves.length, 10); // Analyze max 10 moves
      
      document.getElementById('analysisTotalMoves').textContent = totalToAnalyze;
      
      let totalEfficiency = 0;
      let movesAnalyzed = 0;
      
      // Analyze each critical move
      for (let i = 0; i < totalToAnalyze; i++) {
        document.getElementById('analysisMoveNum').textContent = i + 1;
        const progress = ((i + 1) / totalToAnalyze) * 100;
        document.getElementById('analysisProgressBar').style.width = progress + '%';
        
        const move = criticalMoves[i];
        
        // Simulate analysis delay
        await sleep(800);
        
        // Find best move for this position
        const bestMove = await findBestMoveForPosition(move.board, move.rack);
        
        if (bestMove && bestMove.score > 0) {
          const efficiency = move.playerMove.score / bestMove.score;
          totalEfficiency += efficiency;
          movesAnalyzed++;
        }
      }
      
      // Calculate average efficiency
      const avgEfficiency = movesAnalyzed > 0 ? totalEfficiency / movesAnalyzed : 0.5;
      gameResult.moveEfficiency = avgEfficiency;
      
      // Calculate provisional rating
      const newRating = calculateProvisionalRating(gameResult, avgEfficiency);
      gameResult.provisionalRating = newRating;
      calibrationState.provisionalRating = newRating;
      
      // Save to database
      await saveCalibrationGame(gameResult);
      
      // Check if calibration is complete
      if (calibrationState.currentGame >= 3) {
        await completeCalibration();
      } else {
        // Move to next game
        calibrationState.currentGame++;
        showCalibrationNextGame();
      }
    }
    
    function calculateProvisionalRating(gameResult, moveEfficiency) {
      const { playerScore, botScore, botRating } = gameResult;
      
      // 30% from game result
      const scoreDiff = playerScore - botScore;
      const resultRating = botRating + (scoreDiff / 2);
      
      // 70% from move quality
      let efficiencyRating;
      if (moveEfficiency > 0.90) efficiencyRating = 2000;
      else if (moveEfficiency > 0.80) efficiencyRating = 1700;
      else if (moveEfficiency > 0.70) efficiencyRating = 1500;
      else if (moveEfficiency > 0.60) efficiencyRating = 1300;
      else if (moveEfficiency > 0.50) efficiencyRating = 1100;
      else efficiencyRating = 900;
      
      // Weighted average
      const rating = Math.round(resultRating * 0.3 + efficiencyRating * 0.7);
      
      // No clamp - allow any rating
      return rating;
    }
    
    async function findBestMoveForPosition(board, rack) {
      // Use existing findBestMove function (from AI)
      // This is a simplified version - the real one exists in the AI logic
      const validMoves = getAllValidMovesForRack(board, rack);
      if (validMoves.length === 0) return null;
      
      // Sort by score and return best
      validMoves.sort((a, b) => b.score - a.score);
      return validMoves[0];
    }
    
    function getAllValidMovesForRack(board, rack) {
      // This would call the existing word validation logic
      // Simplified for now - returns empty array
      // The real implementation already exists in the AI move generation
      return [];
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    async function saveCalibrationGame(gameResult) {
      if (!currentUser) return;
      
      try {
        const { data, error } = await window.supabase
          .from('calibration_games')
          .insert({
            user_id: currentUser.id,
            game_number: gameResult.gameNumber,
            bot_name: gameResult.botName,
            bot_rating: gameResult.botRating,
            player_score: gameResult.playerScore,
            bot_score: gameResult.botScore,
            total_moves: gameResult.totalMoves,
            critical_moves_count: gameResult.criticalMovesCount,
            critical_moves: gameResult.criticalMoves,
            move_efficiency: gameResult.moveEfficiency,
            provisional_rating: gameResult.provisionalRating
          });
        
        if (error) throw error;
        console.log('âœ… Calibration game saved');
      } catch (error) {
        console.error('Error saving calibration game:', error);
      }
    }
    
    function showCalibrationNextGame() {
      // Hide analysis, show calibration screen
      document.getElementById('calibrationAnalysis').style.display = 'none';
      document.getElementById('calibrationScreen').style.display = 'flex';
      
      // Update UI for next game
      updateCalibrationUI();
    }
    
    async function completeCalibration() {
      // Calculate final rating (average of 3 provisional ratings)
      const ratings = calibrationState.games.map(g => g.provisionalRating);
      const finalRating = Math.round(ratings.reduce((a, b) => a + b, 0) / ratings.length);
      
      // Update user rating in database
      try {
        const { error } = await window.supabase
          .from('users')
          .update({
            rating: finalRating,
            calibration_status: 'completed'
          })
          .eq('id', currentUser.id);
        
        if (error) throw error;
        
        // Update local user object
        currentUser.rating = finalRating;
        
        // Show completion message
        document.getElementById('calibrationAnalysis').style.display = 'none';
        
        alert(`Calibration Complete! ðŸŽ‰\n\nYour rating: ${finalRating}\n\nYou can now play ranked games!`);
        
        // Return to mode selection
        calibrationState.inProgress = false;
        isCalibrationGame = false;
        backToModeSelection();
        
      } catch (error) {
        console.error('Error completing calibration:', error);
        alert('Error saving your rating. Please try again.');
      }
    }
    

    let currentBotPersonality = null;
    let isCalibrationGame = false;
    
    // Old function for compatibility
    function startGameWithSlider() {
      startGameWithBot(5); // Default to Bot 5
    }
    
    function showDeviceSelection() {
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'flex';
    }

    function showPlayerNames() {
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('playerNames').style.display = 'flex';
    }

    async function showMultiplayerSetup() {
      document.getElementById('deviceSelection').style.display = 'none';
      
      // Check calibration status first
      if (currentUser) {
        await checkCalibrationStatus();
      }
      
      // Check for rejoinable game first
      if (currentUser) {
        const rejoinableGame = await checkForRejoinableGame();
        
        if (rejoinableGame) {
          // Show rejoin prompt
          const rejoinPrompt = confirm(
            `You have an active game in progress!\n\n` +
            `Do you want to rejoin your game?\n\n` +
            `(It will expire in 5 minutes if you don't rejoin)`
          );
          
          if (rejoinPrompt) {
            const success = await rejoinGame(rejoinableGame);
            if (success) {
              // Successfully rejoined, game will resume
              return;
            }
          }
        }
      }
      
      // No rejoinable game or user declined - show normal setup
      document.getElementById('multiplayerSetup').style.display = 'flex';
    }

    function showJoinGame() {
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'flex';
      document.getElementById('joinGameCode').value = '';
      document.getElementById('joinStatus').textContent = '';
    }

    function backToModeSelection() {
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'flex';
    }

    function backToDeviceSelection() {
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'flex';
    }

    function backToMultiplayerSetup() {
      document.getElementById('joinGameScreen').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'flex';
    }

    // ============================================
    // v2.0.0 LOBBY SYSTEM FUNCTIONS
    // ============================================
    
    function updateLobbyPlayerList() {
      const listEl = document.getElementById('lobbyPlayersList');
      const countEl = document.getElementById('playerCount');
      
      countEl.textContent = lobbyPlayers.length;
      
      listEl.innerHTML = lobbyPlayers
        .sort((a, b) => a.order - b.order)
        .map(p => `
          <div style="padding: 12px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
            <div>
              <span style="font-weight: 600; color: #1e293b;">${p.name}</span>
              ${p.isHost ? '<span style="margin-left: 8px; padding: 2px 8px; background: #667eea; color: white; border-radius: 4px; font-size: 0.75rem;">HOST</span>' : ''}
            </div>
            <div style="color: #64748b; font-size: 0.9rem;">Player ${p.order}</div>
          </div>
        `)
        .join('');
      
      // Enable start button if 2+ players and we're host
      if (isHost) {
        const startBtn = document.getElementById('startGameBtn');
        if (lobbyPlayers.length >= 2) {
          startBtn.disabled = false;
          startBtn.style.opacity = '1';
          startBtn.style.cursor = 'pointer';
          document.querySelector('#hostControls > div').style.display = 'none';
        } else {
          startBtn.disabled = true;
          startBtn.style.opacity = '0.5';
          startBtn.style.cursor = 'not-allowed';
          document.querySelector('#hostControls > div').style.display = 'block';
        }
      }
    }
    
    function setupPlayerConnection(conn) {
      const peerId = conn.peer;
      
      conn.on('open', () => {
        console.log('âœ… Player connected:', peerId);
        
        // Store connection
        connections[peerId] = conn;
        
        // Setup message handler
        conn.on('data', (data) => handlePlayerMessage(peerId, data));
        
        conn.on('close', () => {
          console.log('âŒ Player disconnected:', peerId);
          handlePlayerDisconnect(peerId);
        });
      });
      
      conn.on('error', (err) => {
        console.error('Connection error:', peerId, err);
      });
    }
    
    async function handlePlayerMessage(peerId, data) {
      console.log('ðŸ“¨ Message from', peerId, ':', data);
      
      switch (data.type) {
        case 'join':
          // Player wants to join lobby
          await handlePlayerJoin(peerId, data.playerName);
          break;
          
        case 'move':
          // Player made a move (during game)
          if (isHost) {
            // Host relays to all other players
            broadcastToAllPlayers(data);
          }
          // Apply move locally (both host and non-host)
          if (game) {
            game.applyRemoteMove(data);
          }
          break;
          
        case 'pass':
          // Player passed turn
          if (isHost) {
            // Host relays to all other players
            broadcastToAllPlayers(data);
          }
          // Apply pass locally
          if (game) {
            game.applyRemotePass(data);
          }
          break;
      }
    }
    
    async function handlePlayerJoin(peerId, playerName) {
      if (!isHost) return; // Only host handles joins
      
      // Check if lobby is full
      if (lobbyPlayers.length >= 4) {
        connections[peerId].send({
          type: 'join_failed',
          reason: 'Game is full (max 4 players)'
        });
        connections[peerId].close();
        delete connections[peerId];
        return;
      }
      
      // Add to database
      const playerData = await addPlayerToGame(playerName, peerId);
      if (!playerData) {
        connections[peerId].send({
          type: 'join_failed',
          reason: 'Database error'
        });
        return;
      }
      
      // Add to lobby
      const newPlayer = {
        id: playerData.id,
        name: playerName,
        order: playerData.player_order,
        isHost: false,
        peerId: peerId
      };
      lobbyPlayers.push(newPlayer);
      
      // Send success to joiner
      connections[peerId].send({
        type: 'join_success',
        gameId: currentGameId,
        playerId: playerData.id,
        playerOrder: playerData.player_order,
        players: lobbyPlayers
      });
      
      // Broadcast updated player list to all
      broadcastLobbyUpdate();
      updateLobbyPlayerList();
    }
    
    function broadcastLobbyUpdate() {
      const message = {
        type: 'lobby_update',
        players: lobbyPlayers
      };
      
      Object.values(connections).forEach(conn => {
        try {
          conn.send(message);
        } catch (err) {
          console.error('Error broadcasting to player:', err);
        }
      });
    }
    
    function broadcastToAllPlayers(data) {
      Object.values(connections).forEach(conn => {
        try {
          conn.send(data);
        } catch (err) {
          console.error('Error broadcasting:', err);
        }
      });
    }
    
    function handlePlayerDisconnect(peerId) {
      // Remove from lobby
      lobbyPlayers = lobbyPlayers.filter(p => p.peerId !== peerId);
      
      // Remove connection
      delete connections[peerId];
      
      // Update UI
      updateLobbyPlayerList();
      
      // Broadcast update
      if (isHost) {
        broadcastLobbyUpdate();
      }
    }
    
    async function startLobbyGame() {
      if (!isHost) return;
      if (lobbyPlayers.length < 2) {
        alert('Need at least 2 players to start!');
        return;
      }
      
      // Update game status
      await updateGameStatus('playing');
      
      // Randomize starting player
      const randomIndex = Math.floor(Math.random() * lobbyPlayers.length);
      currentPlayerIndex = randomIndex;
      
      // Broadcast game start to all players
      const startMessage = {
        type: 'game_start',
        players: lobbyPlayers,
        startingPlayerOrder: lobbyPlayers[randomIndex].order
      };
      
      broadcastToAllPlayers(startMessage);
      
      // Start game locally
      startMultiplayerGame();
    }
    
    function startMultiplayerGame() {
      // Hide lobby
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'none';
      
      // Show game board
      document.getElementById('gameBoard').style.display = 'flex';
      document.getElementById('settingsBtn').style.display = 'block';
      
      // Initialize game
      game = new ScrabbleGame('online');
      game.init();
      
      console.log('ðŸŽ® Multi-player game started!');
      console.log('Players:', lobbyPlayers);
      console.log('My order:', myPlayerOrder);
      console.log('Current turn:', lobbyPlayers[currentPlayerIndex].name);
    }
    
    // ============================================
    // END v2.0.0 LOBBY FUNCTIONS
    // ============================================
    
    function cancelOnlineGame() {
      console.log('ðŸšª Leaving lobby...');
      
      // Destroy peer connection
      if (peer) {
        peer.destroy();
        peer = null;
      }
      
      // Close all connections (v2.0.0 uses connections object, not single connection)
      Object.values(connections).forEach(conn => {
        try {
          conn.close();
        } catch (err) {
          console.log('Error closing connection:', err);
        }
      });
      connections = {};
      lobbyPlayers = [];
      
      console.log('âœ… Lobby cleaned up, returning to setup');
      backToMultiplayerSetup();
    }

    // Helper function to capitalize names properly
    function capitalizeName(name) {
      return name
        .trim()
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
    }

    async function createOnlineGame() {
      const nameInput = document.getElementById('onlinePlayerName').value.trim();
      if (!nameInput) {
        alert('Please enter your name');
        return;
      }
      
      // Use username if logged in, otherwise use entered name
      myOnlineName = currentUser && currentUser.displayName ? currentUser.displayName : capitalizeName(nameInput);
      
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'flex';
      
      isHost = true;
      myPlayerOrder = 1; // Host is always player 1
      
      // Generate random 6-digit code
      myGameCode = Math.random().toString(36).substring(2, 8).toUpperCase();
      
      // Initialize PeerJS with game code as ID
      peer = new Peer(myGameCode);
      
      peer.on('open', async (id) => {
        console.log('âœ… Peer connected with ID:', id);
        document.getElementById('connectionStatus').innerHTML = '<div style="font-size: 1.1rem; color: #4CAF50;">âœ“ Server connected!</div>';
        document.getElementById('gameCodeDisplay').style.display = 'block';
        document.getElementById('gameCode').textContent = myGameCode;
        
        // Create game record in database
        await createGameRecordV2();
        
        // Show lobby
        document.getElementById('lobbyPlayersSection').style.display = 'block';
        document.getElementById('hostControls').style.display = 'block';
        
        // Add host to lobby
        const hostPlayer = {
          id: myPlayerId,
          name: myOnlineName,
          order: 1,
          isHost: true,
          peerId: myGameCode
        };
        lobbyPlayers = [hostPlayer];
        updateLobbyPlayerList();
      });
      
      // Listen for incoming connections
      peer.on('connection', (conn) => {
        console.log('ðŸ“¥ Incoming connection from:', conn.peer);
        setupPlayerConnection(conn);
      });
      
      peer.on('error', (err) => {
        document.getElementById('connectionStatus').innerHTML = '<div style="color: #ff6b6b;">âŒ Connection error. Please try again.</div>';
        console.error('Peer error:', err);
      });
    }

    function joinOnlineGame() {
      const code = document.getElementById('joinGameCode').value.trim().toUpperCase();
      const nameInput = document.getElementById('onlinePlayerName').value.trim();
      
      if (!nameInput) {
        alert('Please enter your name');
        return;
      }
      
      if (code.length !== 6) {
        document.getElementById('joinStatus').textContent = 'Please enter a 6-character code';
        return;
      }
      
      // Use username if logged in, otherwise use entered name
      myOnlineName = currentUser && currentUser.displayName ? currentUser.displayName : capitalizeName(nameInput);
      myGameCode = code;
      
      document.getElementById('joinStatus').textContent = 'Connecting...';
      
      isHost = false;
      
      // Initialize PeerJS with random ID
      peer = new Peer();
      
      peer.on('open', (myPeerId) => {
        console.log('âœ… My peer ID:', myPeerId);
        
        // Connect to host
        const conn = peer.connect(code);
        
        conn.on('open', () => {
          console.log('âœ… Connected to host!');
          document.getElementById('joinStatus').innerHTML = '<div style="color: #4CAF50;">âœ“ Connected! Joining lobby...</div>';
          
          // Store connection
          connections[code] = conn;
          
          // Setup message handler
          conn.on('data', (data) => handleJoinerMessage(data));
          
          conn.on('close', () => {
            console.log('âŒ Disconnected from host');
            alert('Disconnected from game');
            backToMultiplayerSetup();
          });
          
          // Request to join
          conn.send({
            type: 'join',
            playerName: myOnlineName,
            peerId: myPeerId
          });
        });
        
        conn.on('error', (err) => {
          document.getElementById('joinStatus').textContent = 'âŒ Failed to connect. Check the code.';
          console.error('Connection error:', err);
        });
      });
      
      peer.on('error', (err) => {
        document.getElementById('joinStatus').textContent = 'âŒ Connection error. Please try again.';
        console.error('Peer error:', err);
      });
    }
    
    function handleJoinerMessage(data) {
      console.log('ðŸ“¨ Message from host:', data);
      
      switch (data.type) {
        case 'join_success':
          // Successfully joined lobby
          currentGameId = data.gameId;
          myPlayerId = data.playerId;
          myPlayerOrder = data.playerOrder;
          lobbyPlayers = data.players;
          
          // Show lobby screen
          document.getElementById('joinGameScreen').style.display = 'none';
          document.getElementById('createGameScreen').style.display = 'flex';
          document.getElementById('connectionStatus').innerHTML = '<div style="font-size: 1.1rem; color: #4CAF50;">âœ“ Joined lobby!</div>';
          document.getElementById('gameCodeDisplay').style.display = 'block';
          document.getElementById('gameCode').textContent = myGameCode;
          document.getElementById('lobbyPlayersSection').style.display = 'block';
          document.getElementById('waitingForHost').style.display = 'block';
          
          updateLobbyPlayerList();
          break;
          
        case 'join_failed':
          alert('Failed to join: ' + data.reason);
          backToMultiplayerSetup();
          break;
          
        case 'lobby_update':
          // Update player list
          lobbyPlayers = data.players;
          updateLobbyPlayerList();
          break;
          
        case 'game_start':
          // Game is starting
          lobbyPlayers = data.players;
          currentPlayerIndex = lobbyPlayers.findIndex(p => p.order === data.startingPlayerOrder);
          startMultiplayerGame();
          break;
          
        case 'move':
        case 'pass':
          // Game moves (will be handled during gameplay)
          if (game) {
            handleRemoteMove(data);
          }
          break;
      }
    }

    function setupConnection() {
      connection.on('data', (data) => {
        handleRemoteMove(data);
      });
      
      connection.on('close', async () => {
        console.log('ðŸ”Œ Connection closed - opponent disconnected');
        
        // Mark opponent as disconnected in database
        const playerRole = isHost ? 'guest' : 'host';
        await markDisconnected(playerRole);
        
        // Show reconnection UI
        const reconnectDiv = document.createElement('div');
        reconnectDiv.id = 'reconnectNotice';
        reconnectDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          padding: 30px;
          border-radius: 15px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.3);
          z-index: 10000;
          text-align: center;
          max-width: 400px;
        `;
        reconnectDiv.innerHTML = `
          <h3 style="margin: 0 0 15px 0; color: #e74c3c;">âš ï¸ Opponent Disconnected</h3>
          <p style="margin-bottom: 20px; color: #7f8c8d;">
            They have 5 minutes to rejoin.<br>
            If they don't return, you'll win automatically.
          </p>
          <div id="reconnectTimer" style="font-size: 24px; font-weight: bold; color: var(--accent); margin-bottom: 20px;">5:00</div>
          <button onclick="document.getElementById('reconnectNotice').remove(); backToMenu();" style="
            padding: 12px 24px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
          ">Leave Game</button>
        `;
        
        document.body.appendChild(reconnectDiv);
        
        // Start 5-minute countdown
        let timeRemaining = 300; // 5 minutes in seconds
        const timerInterval = setInterval(() => {
          timeRemaining--;
          const minutes = Math.floor(timeRemaining / 60);
          const seconds = timeRemaining % 60;
          const timerEl = document.getElementById('reconnectTimer');
          
          if (timerEl) {
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          }
          
          if (timeRemaining <= 0) {
            clearInterval(timerInterval);
            if (reconnectDiv.parentNode) {
              reconnectDiv.remove();
            }
            // Auto-forfeit handled by database function
            alert('Opponent did not rejoin. You win!');
            if (game) game.endGame();
          }
        }, 1000);
      });
      
      connection.on('error', (err) => {
        console.error('Connection error:', err);
      });
    }

    function handleRemoteMove(data) {
      if (!game) {
        // Handle setup messages before game starts
        if (data.type === 'setup' && !isHost) {
          // Joiner receives setup from host
          opponentName = data.hostName;
          startingPlayer = data.startingPlayer;
          currentGameId = data.gameId; // Receive game ID from host
          
          // Determine joiner's role based on who starts
          if (startingPlayer === 'player') {
            onlinePlayerRole = 'ai'; // Host starts, joiner is second
          } else {
            onlinePlayerRole = 'player'; // Joiner starts, joiner is first
          }
          
          // Start the game
          if (onlinePlayerRole === 'player') {
            player1Name = myOnlineName;
            player2Name = opponentName;
          } else {
            player1Name = opponentName;
            player2Name = myOnlineName;
          }
          
          startGame('online', null);
          return;
        }
        
        if (data.type === 'joinerName' && isHost) {
          // Host receives joiner's name
          opponentName = data.name;
          
          // Update game record with guest info
          if (currentGameId && currentUser) {
            updateGameRecord({
              guest_id: data.userId || null,
              guest_peer_id: data.peerId || null,
              status: 'active'
            });
          }
          
          // Start the game
          if (onlinePlayerRole === 'player') {
            player1Name = myOnlineName;
            player2Name = opponentName;
          } else {
            player1Name = opponentName;
            player2Name = myOnlineName;
          }
          
          startGame('online', null);
          return;
        }
        
        return;
      }
      
      if (data.type === 'move') {
        // Opponent played a word
        game.applyRemoteMove(data);
      } else if (data.type === 'pass') {
        // Opponent passed
        game.applyRemotePass();
      } else if (data.type === 'chat') {
        // Received chat message
        addChatMessage(data.sender, data.message, false);
      } else if (data.type === 'tilePlacement') {
        // Opponent placed a tile (preview)
        game.addOpponentPreviewTile(data);
      } else if (data.type === 'tileRecall') {
        // Opponent recalled tiles
        game.clearOpponentPreviewTiles(data.positions);
      } else if (data.type === 'reconnect') {
        // Opponent reconnected!
        console.log('âœ… Opponent reconnected');
        
        const reconnectNotice = document.getElementById('reconnectNotice');
        if (reconnectNotice) {
          reconnectNotice.remove();
        }
        
        // Update database
        const playerRole = data.playerRole;
        const updates = { status: 'active', disconnected_player: null, disconnect_timestamp: null };
        if (playerRole === 'host') {
          updates.host_connected = true;
        } else {
          updates.guest_connected = true;
        }
        updateGameRecord(updates);
        
        // Resync game state
        if (game) {
          game.saveGameState();
          // Send current game state to reconnected opponent
          connection.send({
            type: 'gameStateSync',
            gameId: currentGameId
          });
        }
      } else if (data.type === 'gameStateSync') {
        // Load game state from database
        if (game && data.gameId) {
          game.loadGameState(data.gameId);
        }
      }
    }

    function sendMove(moveData) {
      if (connection && connection.open) {
        connection.send(moveData);
      }
    }
    
    // v2.0.0: Multi-player move broadcasting
    function sendMoveV2(moveData) {
      if (isHost) {
        // Host broadcasts to all players
        broadcastToAllPlayers(moveData);
      } else {
        // Non-host sends to host (host will broadcast)
        const hostConnection = Object.values(connections)[0];
        if (hostConnection && hostConnection.open) {
          hostConnection.send(moveData);
        }
      }
    }

    // Chat functions
    let chatOpen = false;

    function toggleChat() {
      chatOpen = !chatOpen;
      const chatPanel = document.getElementById('chatPanel');
      const chatToggle = document.getElementById('chatToggle');
      
      if (chatOpen) {
        chatPanel.style.display = 'block';
        chatToggle.style.display = 'none';
        
        // Scroll to bottom
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        // Focus input
        document.getElementById('chatInput').focus();
      } else {
        chatPanel.style.display = 'none';
        chatToggle.style.display = 'block';
      }
    }

    function sendChatMessage() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      
      if (!message) return;
      
      if (connection && connection.open) {
        connection.send({
          type: 'chat',
          message: message,
          sender: myOnlineName
        });
        
        // Add to our own chat
        addChatMessage(myOnlineName, message, true);
        
        input.value = '';
      }
    }

    function addChatMessage(sender, message, isMe) {
      const chatMessages = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      
      messageDiv.style.cssText = `
        padding: 10px;
        border-radius: 8px;
        max-width: 80%;
        word-wrap: break-word;
        ${isMe ? 'background: var(--accent); color: white; margin-left: auto; text-align: right;' : 'background: rgba(139, 90, 43, 0.15);'}
      `;
      
      if (!isMe) {
        messageDiv.innerHTML = `
          <div style="font-weight: bold; font-size: 0.85rem; margin-bottom: 4px; color: var(--accent);">${sender}</div>
          <div>${message}</div>
        `;
      } else {
        messageDiv.innerHTML = `<div>${message}</div>`;
      }
      
      chatMessages.appendChild(messageDiv);
      
      // Scroll to bottom
      chatMessages.scrollTop = chatMessages.scrollHeight;
      
      // Show notification if chat is closed
      if (!chatOpen && !isMe) {
        const chatToggle = document.getElementById('chatToggle');
        chatToggle.textContent = 'ðŸ’¬ !';
        chatToggle.style.animation = 'pulse 1s ease-in-out 3';
        
        setTimeout(() => {
          chatToggle.textContent = 'ðŸ’¬';
          chatToggle.style.animation = '';
        }, 3000);
      }
    }

    function startGameWithNames() {
      const p1 = document.getElementById('player1Name').value.trim();
      const p2 = document.getElementById('player2Name').value.trim();
      
      player1Name = p1 ? capitalizeName(p1) : 'Player 1';
      player2Name = p2 ? capitalizeName(p2) : 'Player 2';
      
      startGame('human', null);
    }

    function startGame(mode, difficulty) {
      gameMode = mode;
      if (difficulty) {
        aiDifficulty = difficulty;
      }
      
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('playerNames').style.display = 'none';
      document.getElementById('difficultySelection').style.display = 'none';
      document.getElementById('deviceSelection').style.display = 'none';
      document.getElementById('multiplayerSetup').style.display = 'none';
      document.getElementById('createGameScreen').style.display = 'none';
      document.getElementById('joinGameScreen').style.display = 'none';
      document.getElementById('gameBoard').style.display = 'flex';
      
      // Show chat toggle for online mode
      if (mode === 'online') {
        document.getElementById('chatToggle').style.display = 'block';
      }
      
      if (mode === 'human') {
        document.getElementById('player1Label').textContent = player1Name;
        document.getElementById('player2Label').textContent = player2Name;
      } else if (mode === 'online') {
        document.getElementById('player1Label').textContent = player1Name;
        document.getElementById('player2Label').textContent = player2Name;
      } else {
        document.getElementById('player1Label').textContent = 'You';
        // Show bot name and rating if available
        if (currentBotPersonality) {
          document.getElementById('player2Label').textContent = `${currentBotPersonality.name} (${currentBotPersonality.rating})`;
        } else {
          document.getElementById('player2Label').textContent = 'AI';
        }
      }
      
      // Initialize game and store globally
      game = new ScrabbleGame(mode, aiDifficulty);
    }

    // Letter distribution and points
    const LETTER_DIST = {
      'A': {count: 9, points: 1}, 'B': {count: 2, points: 3}, 'C': {count: 2, points: 3},
      'D': {count: 4, points: 2}, 'E': {count: 12, points: 1}, 'F': {count: 2, points: 4},
      'G': {count: 3, points: 2}, 'H': {count: 2, points: 4}, 'I': {count: 9, points: 1},
      'J': {count: 1, points: 8}, 'K': {count: 1, points: 5}, 'L': {count: 4, points: 1},
      'M': {count: 2, points: 3}, 'N': {count: 6, points: 1}, 'O': {count: 8, points: 1},
      'P': {count: 2, points: 3}, 'Q': {count: 1, points: 10}, 'R': {count: 6, points: 1},
      'S': {count: 4, points: 1}, 'T': {count: 6, points: 1}, 'U': {count: 4, points: 1},
      'V': {count: 2, points: 4}, 'W': {count: 2, points: 4}, 'X': {count: 1, points: 8},
      'Y': {count: 2, points: 4}, 'Z': {count: 1, points: 10}, '_': {count: 2, points: 0}
    };

    // Premium squares
    const PREMIUM_SQUARES = {
      tws: [[0,0], [0,7], [0,14], [7,0], [7,14], [14,0], [14,7], [14,14]],
      dws: [[1,1], [2,2], [3,3], [4,4], [1,13], [2,12], [3,11], [4,10], 
             [13,1], [12,2], [11,3], [10,4], [13,13], [12,12], [11,11], [10,10]],
      tls: [[1,5], [1,9], [5,1], [5,5], [5,9], [5,13], [9,1], [9,5], [9,9], 
             [9,13], [13,5], [13,9]],
      dls: [[0,3], [0,11], [2,6], [2,8], [3,0], [3,7], [3,14], [6,2], [6,6], 
             [6,8], [6,12], [7,3], [7,11], [8,2], [8,6], [8,8], [8,12], [11,0], 
             [11,7], [11,14], [12,6], [12,8], [14,3], [14,11]]
    };

    // Word validation cache
    const wordCache = new Map();
    
    // Basic common words for offline validation
    // Dictionary will be loaded from GitHub on first run
    let offlineWords = new Set();
    let dictionaryLoaded = false;
    
    async function loadDictionary() {
      const statusEl = document.getElementById('dict-status');
      
      // Check localStorage cache first
      try {
        const cached = localStorage.getItem('sowpods_dict');
        const cacheTime = localStorage.getItem('sowpods_time');
        const age = Date.now() - (parseInt(cacheTime) || 0);
        
        if (cached && age < 7 * 24 * 60 * 60 * 1000) { // 7 days cache
          console.log('Loading cached dictionary...');
          offlineWords = new Set(JSON.parse(cached));
          dictionaryLoaded = true;
          if (statusEl) statusEl.style.display = 'none';
          console.log(`âœ… Loaded ${offlineWords.size} words from cache`);
          return;
        }
      } catch (e) {
        console.warn('Cache load failed:', e);
      }
      
      // Multiple fallback URLs for SOWPODS dictionary
      const dictionaryUrls = [
        'https://raw.githubusercontent.com/jesstess/Scrabble/master/scrabble/sowpods.txt',
        'https://raw.githubusercontent.com/redbo/scrabble/master/dictionary.txt',
        'https://cdn.jsdelivr.net/gh/jesstess/Scrabble@master/scrabble/sowpods.txt',
        'https://gist.githubusercontent.com/dracos/dd0668f281e685bad51479e5acaadb93/raw/6bfa15d263d6d5b63840a8e5b64e04b382fdb079/sowpods.txt',
        'https://www-cs-faculty.stanford.edu/~knuth/sgb-words.txt'
      ];
      
      // Try each URL until one works
      for (const url of dictionaryUrls) {
        try {
          console.log(`Fetching dictionary from ${url}...`);
          
          const response = await fetch(url, {
            mode: 'cors',
            cache: 'default'
          });
          
          if (!response.ok) {
            console.warn(`Failed to fetch from ${url}: HTTP ${response.status}`);
            continue; // Try next URL
          }
          
          const text = await response.text();
          const words = text.split('\n')
            .map(w => w.trim().toUpperCase())
            .filter(w => w.length > 0 && /^[A-Z]+$/.test(w));
          
          if (words.length < 1000) {
            console.warn(`Dictionary too small (${words.length} words), trying next source...`);
            continue;
          }
          
          offlineWords = new Set(words);
          dictionaryLoaded = true;
          
          // Cache for next time
          try {
            localStorage.setItem('sowpods_dict', JSON.stringify(words));
            localStorage.setItem('sowpods_time', Date.now());
          } catch (e) {
            console.warn('Cache save failed:', e);
          }
          
          if (statusEl) statusEl.style.display = 'none';
          console.log(`âœ… Loaded ${words.length} words from ${url}`);
          return; // Success! Exit function
          
        } catch (error) {
          console.error(`Failed to load from ${url}:`, error);
          // Continue to next URL
        }
      }
      
      // All URLs failed - use embedded basic dictionary
      console.error('All dictionary sources failed, using embedded basic dictionary');
      
      // Basic embedded dictionary (most common words)
      offlineWords = new Set([
        'AA', 'AB', 'AD', 'AE', 'AG', 'AH', 'AI', 'AL', 'AM', 'AN', 'AR', 'AS', 'AT', 'AW', 'AX', 'AY',
        'BA', 'BE', 'BI', 'BO', 'BY', 'DA', 'DE', 'DO', 'ED', 'EF', 'EH', 'EL', 'EM', 'EN', 'ER', 'ES', 'ET', 'EX',
        'FA', 'FE', 'GO', 'HA', 'HE', 'HI', 'HM', 'HO', 'ID', 'IF', 'IN', 'IS', 'IT',
        'JO', 'KA', 'KI', 'LA', 'LI', 'LO', 'MA', 'ME', 'MI', 'MM', 'MO', 'MU', 'MY',
        'NA', 'NE', 'NO', 'NU', 'OD', 'OE', 'OF', 'OH', 'OI', 'OM', 'ON', 'OP', 'OR', 'OS', 'OW', 'OX', 'OY',
        'PA', 'PE', 'PI', 'PO', 'QI', 'RE', 'SH', 'SI', 'SO', 'TA', 'TI', 'TO',
        'UH', 'UM', 'UN', 'UP', 'US', 'UT', 'WE', 'WO', 'XI', 'XU', 'YA', 'YE', 'YO', 'YU', 'ZA',
        'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE', 'OUR', 'OUT', 'DAY', 'GET', 'HAS', 'HIM', 'HIS', 'HOW', 'MAN', 'NEW', 'NOW', 'OLD', 'SEE', 'TWO', 'WAY', 'WHO', 'BOY', 'DID', 'ITS', 'LET', 'PUT', 'SAY', 'SHE', 'TOO', 'USE',
        'CAT', 'DOG', 'RUN', 'SIT', 'EAT', 'BIG', 'RED', 'HOT', 'SUN', 'FUN', 'PLAY', 'WORD', 'GOOD', 'MAKE', 'HELP', 'LOOK', 'CALL', 'FIND', 'GIVE', 'TELL', 'WORK', 'SEEM', 'FEEL', 'HAND', 'TURN', 'SHOW', 'PART', 'EVEN', 'LAND', 'WELL', 'BACK', 'ONLY', 'COME', 'MADE', 'FIND', 'YEAR', 'WORK', 'OVER', 'VERY', 'ALSO', 'WELL', 'DOWN', 'HIGH', 'JUST', 'LIFE', 'LONG', 'MUCH', 'SAME', 'TAKE', 'WANT', 'KNOW', 'MOVE', 'LIKE', 'FACE', 'LIVE', 'AREA', 'CITY', 'BOOK', 'FORM', 'IDEA', 'LOVE', 'FOOD', 'GAME', 'HOME', 'WORD', 'CASE', 'TIME', 'NAME', 'LINE', 'SIDE', 'HEAD', 'ROAD', 'MILE', 'FIRE', 'TREE', 'BIRD', 'FISH',
        'QUIZ', 'JAZZ', 'FIZZ', 'BUZZ'
      ]);
      
      dictionaryLoaded = true;
      
      if (statusEl) {
        statusEl.innerHTML = `
          âš ï¸ Could not load full dictionary (network issue)<br>
          <small>Using ${offlineWords.size} basic words - <a href="#" onclick="location.reload()" style="color: inherit; text-decoration: underline;">Retry</a></small>
        `;
        statusEl.style.background = '#fff3cd';
        statusEl.style.color = '#856404';
        statusEl.style.padding = '12px';
        statusEl.style.fontSize = '14px';
      }
      
      console.log(`âš ï¸ Using embedded dictionary (${offlineWords.size} words)`);
    }
    
    // Start loading immediately
    loadDictionary();
    
    // ========================================
    // VERSION CHECK SYSTEM - DISABLED FOR NOW
    // ========================================
    /*
    const CURRENT_VERSION = '1.0.0'; // Update this when releasing new version
    const VERSION_CHECK_URL = 'https://raw.githubusercontent.com/ThitiKhacharoen/Scrabble/main/version.txt';
    
    async function checkForUpdates() {
      try {
        // Check on every page load for latest version
        const now = Date.now();
        
        // Fetch latest version
        const response = await fetch(VERSION_CHECK_URL, {
          cache: 'no-cache'
        });
        
        if (!response.ok) {
          console.log('Version check failed (server issue)');
          return;
        }
        
        const latestVersion = (await response.text()).trim();
        
        // Save check time
        localStorage.setItem('last_version_check', now.toString());
        
        // Compare versions
        if (latestVersion !== CURRENT_VERSION && isNewerVersion(latestVersion, CURRENT_VERSION)) {
          // Check if user already dismissed this version
          const dismissedVersion = localStorage.getItem('dismissed_version');
          if (dismissedVersion !== latestVersion) {
            showUpdateNotification(latestVersion);
          }
        }
        
      } catch (error) {
        console.log('Version check failed:', error.message);
        // Silently fail - don't bother user
      }
    }
    
    function isNewerVersion(latest, current) {
      const latestParts = latest.split('.').map(Number);
      const currentParts = current.split('.').map(Number);
      
      for (let i = 0; i < 3; i++) {
        if (latestParts[i] > currentParts[i]) return true;
        if (latestParts[i] < currentParts[i]) return false;
      }
      return false;
    }
    
    function showUpdateNotification(newVersion) {
      const banner = document.createElement('div');
      banner.id = 'update-banner';
      banner.style.cssText = `
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        z-index: 10001;
        display: flex;
        align-items: center;
        gap: 16px;
        font-size: 14px;
        font-weight: 600;
        animation: slideUp 0.3s ease-out;
      `;
      
      banner.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <span style="font-size: 24px;">ðŸŽ‰</span>
          <div>
            <div style="font-size: 16px; margin-bottom: 4px;">New Version Available!</div>
            <div style="font-size: 12px; opacity: 0.9;">v${newVersion} is ready</div>
          </div>
        </div>
        <button onclick="
          // Hard refresh to clear cache and get latest version
          localStorage.removeItem('last_version_check');
          localStorage.removeItem('dictionary_cache');
          location.reload(true);
        " style="
          background: white;
          color: #27ae60;
          border: none;
          padding: 10px 20px;
          border-radius: 8px;
          font-weight: 700;
          cursor: pointer;
          font-size: 14px;
          transition: transform 0.2s;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          Update Now
        </button>
        <button onclick="
          localStorage.setItem('dismissed_version', '${newVersion}');
          this.parentElement.remove();
        " style="
          background: transparent;
          color: white;
          border: 1px solid rgba(255,255,255,0.5);
          padding: 10px 16px;
          border-radius: 8px;
          font-weight: 600;
          cursor: pointer;
          font-size: 14px;
        ">
          Later
        </button>
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideUp {
          from {
            transform: translateX(-50%) translateY(100px);
            opacity: 0;
          }
          to {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
          }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(banner);
      
      // Auto-hide after 30 seconds
      setTimeout(() => {
        if (banner.parentElement) {
          banner.style.animation = 'slideUp 0.3s ease-out reverse';
          setTimeout(() => banner.remove(), 300);
        }
      }, 30000);
    }
    
    // Check for updates on load (after 3 seconds to not interfere with game loading)
    setTimeout(checkForUpdates, 3000);
    */
    // ========================================
    // END VERSION CHECK SYSTEM
    // ========================================

    async function validateWord(word) {
      word = word.toUpperCase();
      
      // Handle blank tiles (_) - try all possible letters
      if (word.includes('_')) {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        
        // Try replacing each blank with each letter
        for (const letter of alphabet) {
          const testWord = word.replace('_', letter);
          
          // If still has blanks, recursively validate
          if (testWord.includes('_')) {
            const isValid = await validateWord(testWord);
            if (isValid) {
              wordCache.set(word, true);
              return true;
            }
          } else {
            // Check if this combination is valid
            if (offlineWords.has(testWord)) {
              wordCache.set(word, true);
              return true;
            }
          }
        }
        
        // None of the combinations were valid
        wordCache.set(word, false);
        return false;
      }
      
      if (wordCache.has(word)) {
        return wordCache.get(word);
      }

      // Try offline validation first
      if (offlineWords.has(word)) {
        wordCache.set(word, true);
        return true;
      }

      // Try online API
      try {
        const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`, {
          signal: AbortSignal.timeout(5000) // 5 second timeout
        });
        const isValid = response.ok;
        wordCache.set(word, isValid);
        return isValid;
      } catch (error) {
        // If offline or API fails, reject unknown words
        console.log('Dictionary API unavailable, rejecting unknown word:', word);
        wordCache.set(word, false);
        return false;
      }
    }

    class ScrabbleGame {
      constructor(mode, difficulty) {
        this.gameMode = mode; // 'ai', 'human', or 'online'
        this.aiDifficulty = difficulty || 5; // 1-10 scale (1=easiest, 10=hardest)
        this.board = Array(15).fill(null).map(() => Array(15).fill(null));
        this.tileBag = this.initializeTileBag();
        
        // v2.0.0: Multi-player support
        if (this.gameMode === 'online' && lobbyPlayers.length > 0) {
          // Online multi-player mode
          this.players = lobbyPlayers.map(p => ({
            id: p.id,
            name: p.name,
            order: p.order,
            score: 0,
            rack: [],
            isMe: p.order === myPlayerOrder
          }));
          this.currentPlayerIndex = currentPlayerIndex; // Set by lobby
        } else if (this.gameMode === 'human') {
          // Local 2-player mode
          this.players = [
            { id: 'p1', name: player1Name, order: 1, score: 0, rack: [], isMe: true },
            { id: 'p2', name: player2Name, order: 2, score: 0, rack: [], isMe: false }
          ];
          this.currentPlayerIndex = 0;
        } else {
          // AI mode (single player)
          this.players = [
            { id: 'player', name: 'You', order: 1, score: 0, rack: [], isMe: true },
            { id: 'ai', name: 'AI', order: 2, score: 0, rack: [], isMe: false }
          ];
          this.currentPlayerIndex = 0;
        }
        
        // Legacy support (for old code that still references these)
        this.playerRack = this.players[0].rack;
        this.aiRack = this.players.length > 1 ? this.players[1].rack : [];
        this.playerScore = this.players[0].score;
        this.aiScore = this.players.length > 1 ? this.players[1].score : 0;
        this.currentTurn = 'player'; // Legacy - use currentPlayerIndex instead
        
        this.placedTiles = [];
        this.selectedTile = null;
        this.selectedTileIndex = null;
        this.direction = 'horizontal';
        this.firstMove = true;
        this.consecutivePasses = 0;
        this.pendingTransition = false;
        this.opponentPreviewTiles = [];
        
        this.initializeGame();
      }

      showTurnTransition() {
        if (this.gameMode !== 'human') return; // Only for 2-player mode
        
        this.pendingTransition = true;
        // this.tilesRevealed = false; // CHEATING PENALTY DISABLED
        const currentPlayerName = this.currentTurn === 'player' ? player1Name : player2Name;
        
        // Animate the transition screen entrance
        const transitionEl = document.getElementById('turnTransition');
        transitionEl.style.display = 'flex';
        transitionEl.style.animation = 'none';
        void transitionEl.offsetWidth; // Force reflow
        transitionEl.style.animation = 'fadeIn 0.3s ease-in-out';
        
        document.getElementById('transitionPlayerName').textContent = currentPlayerName + "'s Turn";
        document.getElementById('transitionNextPlayer').textContent = currentPlayerName;
        
        // v1.3.2 Fix: Hide the rack with blur (defensive check)
        const rack = document.getElementById('rack');
        if (rack) {
          rack.style.filter = 'blur(20px)';
          rack.style.pointerEvents = 'none';
          rack.style.visibility = 'visible'; // Keep visible but blurred
        }
        
        // CHEATING PENALTY DISABLED
        // this.setupCheatingDetector();
      }

      /* CHEATING PENALTY SYSTEM - DISABLED BUT KEPT FOR REFERENCE
      setupCheatingDetector() {
        const rack = document.getElementById('rack');
        
        // Remove old detector if exists
        if (this.cheatingDetectorHandler) {
          rack.removeEventListener('click', this.cheatingDetectorHandler);
        }
        
        // Add new detector
        this.cheatingDetectorHandler = (e) => {
          // If tiles are blurred and not revealed yet, they're trying to cheat
          if (rack.style.filter === 'blur(20px)' && !this.tilesRevealed) {
            this.applyCheatingPenalty();
            e.stopPropagation();
            e.preventDefault();
          }
        };
        
        rack.addEventListener('click', this.cheatingDetectorHandler);
      }

      applyCheatingPenalty() {
        const PENALTY = 10;
        
        // Apply penalty to current player
        if (this.currentTurn === 'player') {
          this.playerScore = Math.max(0, this.playerScore - PENALTY);
        } else {
          this.aiScore = Math.max(0, this.aiScore - PENALTY);
        }
        
        this.cheatingPenalty += PENALTY;
        
        // Show warning
        const warning = document.getElementById('cheatingWarning');
        warning.style.display = 'block';
        
        // Flash animation
        warning.style.animation = 'none';
        void warning.offsetWidth;
        warning.style.animation = 'pulse 0.5s ease-in-out 3';
        
        // Update scores
        this.updateScores();
        
        // Show message
        const currentPlayerName = this.currentTurn === 'player' ? player1Name : player2Name;
        this.showMessage(`ðŸš¨ ${currentPlayerName} caught cheating! -${PENALTY} points!`);
        
        // Auto-hide warning after 5 seconds
        setTimeout(() => {
          warning.style.display = 'none';
        }, 5000);
      }
      */

      confirmTurnTransition() {
        // CHEATING PENALTY DISABLED
        // this.tilesRevealed = true;
        
        // Fade out transition
        this.pendingTransition = false;
        const transitionEl = document.getElementById('turnTransition');
        transitionEl.style.animation = 'fadeOut 0.3s ease-in-out';
        
        setTimeout(() => {
          transitionEl.style.display = 'none';
          
          // v1.3.2 Fix: Show rack unblurred with defensive clearing
          const rack = document.getElementById('rack');
          if (rack) {
            rack.style.filter = 'none';
            rack.style.pointerEvents = 'auto';
            rack.style.visibility = 'visible';
            rack.style.opacity = '1';
          }
          
          this.renderRack();
        }, 300);
      }

      initializeTileBag() {
        const bag = [];
        for (const [letter, {count, points}] of Object.entries(LETTER_DIST)) {
          for (let i = 0; i < count; i++) {
            bag.push({letter, points});
          }
        }
        return this.shuffle(bag);
      }

      shuffle(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      drawTiles(count) {
        const tiles = [];
        for (let i = 0; i < count && this.tileBag.length > 0; i++) {
          const tile = this.tileBag.pop();
          tile._isNew = true; // Mark as new for animation
          tiles.push(tile);
        }
        return tiles;
      }

      initializeGame() {
        // Draw tiles for all players
        this.players.forEach(player => {
          player.rack = this.drawTiles(7);
        });
        
        // Update legacy references
        this.playerRack = this.players[0].rack;
        if (this.players.length > 1) {
          this.aiRack = this.players[1].rack;
        }
        
        this.renderBoard();
        this.renderRack();
        this.updateScores();
        this.updateInfo();
        this.setupEventListeners();
        
        // Show starting message
        const currentPlayer = this.players[this.currentPlayerIndex];
        if (this.gameMode === 'online') {
          if (currentPlayer.isMe) {
            this.showMessage(`You go first! First word must cover the center â˜…`);
          } else {
            this.showMessage(`${currentPlayer.name} goes first. Wait for their turn...`);
          }
        } else {
          const message = currentPlayer.isMe 
            ? 'Your turn. First word must cover the center â˜…'
            : `${currentPlayer.name}'s turn. First word must cover the center â˜…`;
          this.showMessage(message);
        }
      }

      renderBoard() {
        const boardEl = document.getElementById('board');
        boardEl.innerHTML = '';
        
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row;
            cell.dataset.col = col;

            // Add premium square styling
            if (row === 7 && col === 7) {
              cell.className += ' star';
              cell.textContent = 'â˜…';
            } else if (PREMIUM_SQUARES.tws.some(([r, c]) => r === row && c === col)) {
              cell.className += ' tws';
              cell.textContent = '3W';
            } else if (PREMIUM_SQUARES.dws.some(([r, c]) => r === row && c === col)) {
              cell.className += ' dws';
              cell.textContent = '2W';
            } else if (PREMIUM_SQUARES.tls.some(([r, c]) => r === row && c === col)) {
              cell.className += ' tls';
              cell.textContent = '3L';
            } else if (PREMIUM_SQUARES.dls.some(([r, c]) => r === row && c === col)) {
              cell.className += ' dls';
              cell.textContent = '2L';
            }

            // Add existing tile
            if (this.board[row][col]) {
              cell.textContent = ''; // Clear premium square text
              const tile = document.createElement('div');
              tile.className = 'tile';
              tile.innerHTML = `${this.board[row][col].letter}<span class="points">${this.board[row][col].points}</span>`;
              cell.appendChild(tile);
              cell.className += ' occupied';
            }

            // Add preview for placed tiles
            const placedHere = this.placedTiles.find(t => t.row === row && t.col === col);
            if (placedHere) {
              cell.textContent = ''; // Clear premium square text
              const tile = document.createElement('div');
              tile.className = 'tile tile-placed';
              tile.innerHTML = `${placedHere.tile.letter}<span class="points">${placedHere.tile.points}</span>`;
              cell.appendChild(tile);
              cell.className += ' preview';
            }

            // Add opponent preview tiles (online mode only)
            if (this.gameMode === 'online') {
              const opponentTileHere = this.opponentPreviewTiles.find(t => t.row === row && t.col === col);
              if (opponentTileHere && !this.board[row][col] && !placedHere) {
                cell.textContent = ''; // Clear premium square text
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.opacity = '0.6';
                tile.innerHTML = `${opponentTileHere.letter}<span class="points">${opponentTileHere.points}</span>`;
                cell.appendChild(tile);
                cell.className += ' opponent-preview';
              }
            }

            cell.addEventListener('click', () => this.handleCellClick(row, col));
            boardEl.appendChild(cell);
          }
        }
      }

      renderRack() {
        const rackEl = document.getElementById('rack');
        
        // v1.3.2 Fix: Force clear any lingering filters/styles
        rackEl.style.filter = 'none';
        rackEl.style.pointerEvents = 'auto';
        rackEl.style.visibility = 'visible';
        rackEl.style.opacity = '1';
        
        rackEl.innerHTML = '';
        
        // v2.0.0: Get current player's rack
        const currentPlayer = this.players[this.currentPlayerIndex];
        const currentRack = currentPlayer.rack;
        
        // Only show rack if it's my turn in online mode
        if (this.gameMode === 'online' && !currentPlayer.isMe) {
          rackEl.innerHTML = '<div style="padding: 20px; text-align: center; color: #64748b;">Waiting for other player...</div>';
          return;
        }
        
        currentRack.forEach((tile, index) => {
          // v1.3.2 Fix: Defensive check for undefined/null tiles
          if (!tile) return;
          if (tile.placed) return;
          
          if (tile) {
            const tileEl = document.createElement('div');
            tileEl.className = 'rack-tile';
            
            // Check if this is a new tile (just drawn)
            if (tile._isNew) {
              tileEl.classList.add('tile-entering');
              // Clear the flag after animation
              setTimeout(() => {
                tile._isNew = false;
                // Add flip animation after entering
                tileEl.classList.remove('tile-entering');
                tileEl.classList.add('tile-flip');
              }, 600);
            }
            
            tileEl.innerHTML = `${tile.letter}<span class="points">${tile.points}</span>`;
            // Store the actual tile object reference, not just index
            tileEl._tileRef = tile;
            tileEl._tileIndex = index;
            tileEl.addEventListener('click', () => this.selectTile(tile, index));
            rackEl.appendChild(tileEl);
          }
        });
      }

      selectTile(tile, index) {
        this.selectedTile = tile;
        this.selectedTileIndex = index;
        
        // Play tile click sound
        SFX.tileClick();
        
        // Update UI to show selection
        document.querySelectorAll('.rack-tile').forEach((el) => {
          if (el._tileRef === tile) {
            el.classList.add('selected');
          } else {
            el.classList.remove('selected');
          }
        });
      }

      handleCellClick(row, col) {
        // Prevent placing tiles when not your turn in online mode
        if (this.gameMode === 'online' && this.currentTurn !== onlinePlayerRole) {
          return;
        }
        
        if (this.board[row][col]) return;
        if (this.selectedTile === null) return;

        const tile = this.selectedTile;
        if (!tile || tile.placed) return;

        // Place tile
        tile.placed = true;
        tile.row = row;
        tile.col = col;
        this.placedTiles.push({tile, row, col, index: this.selectedTileIndex});
        
        // Play tile placement sound
        SFX.tilePlaced();
        
        // Send tile placement to opponent in real-time (online mode)
        if (this.gameMode === 'online') {
          sendMove({
            type: 'tilePlacement',
            letter: tile.letter,
            points: tile.points,
            row: row,
            col: col
          });
        }
        
        this.selectedTile = null;
        this.selectedTileIndex = null;
        this.renderBoard();
        this.renderRack();
        this.calculateCurrentScore();
      }

      recallTiles() {
        // Send recall notification to opponent in online mode
        if (this.gameMode === 'online' && this.placedTiles.length > 0) {
          sendMove({
            type: 'tileRecall',
            positions: this.placedTiles.map(pt => ({ row: pt.row, col: pt.col }))
          });
        }
        
        this.placedTiles.forEach(({tile, index}) => {
          tile.placed = false;
          delete tile.row;
          delete tile.col;
        });
        this.placedTiles = [];
        this.renderBoard();
        this.renderRack();
        this.calculateCurrentScore();
      }

      calculateCurrentScore() {
        if (this.placedTiles.length === 0) {
          document.getElementById('currentScore').textContent = '0';
          return 0;
        }

        const tiles = this.placedTiles.map(t => ({...t}));
        tiles.sort((a, b) => {
          if (this.direction === 'horizontal') {
            return a.col - b.col;
          }
          return a.row - b.row;
        });

        // Get the full word range including existing tiles
        let startPos, endPos, fixedPos;
        if (this.direction === 'horizontal') {
          fixedPos = tiles[0].row;
          startPos = tiles[0].col;
          endPos = tiles[tiles.length - 1].col;
          
          // Extend to beginning
          while (startPos > 0 && this.board[fixedPos][startPos - 1]) {
            startPos--;
          }
          
          // Extend to end
          while (endPos < 14 && this.board[fixedPos][endPos + 1]) {
            endPos++;
          }
        } else {
          fixedPos = tiles[0].col;
          startPos = tiles[0].row;
          endPos = tiles[tiles.length - 1].row;
          
          // Extend to beginning
          while (startPos > 0 && this.board[startPos - 1][fixedPos]) {
            startPos--;
          }
          
          // Extend to end
          while (endPos < 14 && this.board[endPos + 1][fixedPos]) {
            endPos++;
          }
        }

        let score = 0;
        let wordMultiplier = 1;

        // Score the entire word
        for (let pos = startPos; pos <= endPos; pos++) {
          let row, col, tile;
          
          if (this.direction === 'horizontal') {
            row = fixedPos;
            col = pos;
          } else {
            row = pos;
            col = fixedPos;
          }
          
          // Get tile from board or newly placed
          if (this.board[row][col]) {
            tile = this.board[row][col];
          } else {
            const placed = this.placedTiles.find(t => t.row === row && t.col === col);
            if (placed) {
              tile = placed.tile;
            }
          }
          
          if (tile) {
            let letterScore = tile.points;
            
            // Only apply premium squares for newly placed tiles
            const isNewlyPlaced = this.placedTiles.some(t => t.row === row && t.col === col);
            if (isNewlyPlaced) {
              // Apply letter multipliers
              if (PREMIUM_SQUARES.dls.some(([r, c]) => r === row && c === col)) {
                letterScore *= 2;
              } else if (PREMIUM_SQUARES.tls.some(([r, c]) => r === row && c === col)) {
                letterScore *= 3;
              }

              // Apply word multipliers
              if (PREMIUM_SQUARES.dws.some(([r, c]) => r === row && c === col)) {
                wordMultiplier *= 2;
              } else if (PREMIUM_SQUARES.tws.some(([r, c]) => r === row && c === col)) {
                wordMultiplier *= 3;
              }
            }
            
            score += letterScore;
          }
        }

        score *= wordMultiplier;

        // Bonus for using all 7 tiles
        if (this.placedTiles.length === 7) {
          score += 50;
        }

        document.getElementById('currentScore').textContent = score;
        return score;
      }

      async playWord() {
        // v2.0.0: Multi-player turn validation
        const currentPlayer = this.players[this.currentPlayerIndex];
        if (this.gameMode === 'online' && !currentPlayer.isMe) {
          this.showMessage(`Wait for ${currentPlayer.name}'s turn`);
          return;
        }
        
        if (this.placedTiles.length === 0) {
          this.showMessage('Please place at least one tile');
          return;
        }

        // Validate placement
        if (!this.validatePlacement()) {
          this.showMessage('Invalid placement. Tiles must form a continuous line and connect to existing words.');
          return;
        }

        if (this.firstMove) {
          const centerCovered = this.placedTiles.some(({row, col}) => row === 7 && col === 7);
          if (!centerCovered) {
            this.showMessage('First word must cover the center â˜…');
            return;
          }
        }

        // Get the word formed
        const word = this.getFormedWord();
        
        // Validate word with dictionary
        this.showMessage('Validating word...');
        const isValid = await validateWord(word);
        
        if (!isValid) {
          SFX.wordFail();
          this.showMessage(`"${word}" is not a valid English word. Try again.`);
          return;
        }

        // Calculate score
        const score = this.calculateCurrentScore();
        
        // Flag move for calibration analysis (v3.0.0)
        if (isCalibrationGame && this.currentPlayerIndex === 0) {
          // Player's move - flag if critical
          const playerMove = {
            word: word,
            score: score,
            row: this.placedTiles[0].row,
            col: this.placedTiles[0].col
          };
          
          // Get all valid moves for comparison (simplified - will use AI logic)
          const validMoves = [playerMove]; // Placeholder
          flagMoveIfCritical(this.board, currentPlayer.rack, playerMove, validMoves);
        }
        
        // Play success sound
        SFX.wordSuccess();
        
        // Commit tiles to board
        this.placedTiles.forEach(({tile, row, col}) => {
          this.board[row][col] = tile;
        });

        // Update score for current player (v2.0.0 multi-player)
        // currentPlayer already declared at top of function
        currentPlayer.score += score;
        
        // Update legacy variables
        if (this.currentPlayerIndex === 0) {
          this.playerScore = currentPlayer.score;
        } else if (this.currentPlayerIndex === 1) {
          this.aiScore = currentPlayer.score;
        }
        
        this.firstMove = false;
        const tilesUsedData = this.placedTiles.map(pt => ({
          letter: pt.tile.letter,
          points: pt.tile.points,
          row: pt.row,
          col: pt.col
        }));
        this.placedTiles = [];
        this.consecutivePasses = 0;

        // Refill rack for current player
        const tilesUsed = currentPlayer.rack.filter(t => t && t.placed).length;
        const remainingTiles = currentPlayer.rack.filter(t => !t || !t.placed);
        const newTiles = this.drawTiles(tilesUsed);
        currentPlayer.rack = [...remainingTiles, ...newTiles];
        
        // Update legacy racks
        this.playerRack = this.players[0].rack;
        if (this.players.length > 1) {
          this.aiRack = this.players[1].rack;
        }

        // Send move to opponents in online mode
        if (this.gameMode === 'online') {
          sendMoveV2({
            type: 'move',
            tiles: tilesUsedData,
            score: score,
            word: word,
            newTilesCount: tilesUsed,
            playerOrder: currentPlayer.order
          });
        }

        this.updateScores();
        this.renderBoard();
        this.renderRack();
        this.updateInfo();

        // Switch turn (v2.0.0 multi-player)
        this.nextTurn();
        
        // Play turn change sound
        SFX.turnChange();
        
        // Handle AI turn or show message
        const nextPlayer = this.players[this.currentPlayerIndex];
        if (this.gameMode === 'ai' && nextPlayer.id === 'ai') {
          this.showMessage('AI is thinking...');
          setTimeout(() => this.aiTurn(), 1500);
        } else if (this.gameMode === 'human') {
          // 2-player local mode
          const message = nextPlayer.isMe ? 'Your turn' : `${nextPlayer.name}'s turn`;
          this.showMessage(message);
          this.showTurnTransition();
        } else if (this.gameMode === 'online') {
          // Online multiplayer mode
          if (this.currentTurn === onlinePlayerRole) {
            this.showMessage('Your turn!');
            this.renderRack();
          } else {
            this.showMessage("Opponent's turn...");
          }
        } else {
          // Fallback
          this.renderRack();
        }
      }

      getFormedWord() {
        const tiles = [...this.placedTiles];
        tiles.sort((a, b) => {
          if (this.direction === 'horizontal') {
            return a.col - b.col;
          }
          return a.row - b.row;
        });

        // Get the complete word including existing tiles
        if (this.direction === 'horizontal') {
          const row = tiles[0].row;
          let startCol = tiles[0].col;
          let endCol = tiles[tiles.length - 1].col;
          
          // Extend to beginning
          while (startCol > 0 && this.board[row][startCol - 1]) {
            startCol--;
          }
          
          // Extend to end
          while (endCol < 14 && this.board[row][endCol + 1]) {
            endCol++;
          }
          
          let word = '';
          for (let col = startCol; col <= endCol; col++) {
            if (this.board[row][col]) {
              word += this.board[row][col].letter;
            } else {
              const placed = this.placedTiles.find(t => t.row === row && t.col === col);
              if (placed) {
                word += placed.tile.letter;
              }
            }
          }
          return word;
        } else {
          const col = tiles[0].col;
          let startRow = tiles[0].row;
          let endRow = tiles[tiles.length - 1].row;
          
          while (startRow > 0 && this.board[startRow - 1][col]) {
            startRow--;
          }
          
          while (endRow < 14 && this.board[endRow + 1][col]) {
            endRow++;
          }
          
          let word = '';
          for (let row = startRow; row <= endRow; row++) {
            if (this.board[row][col]) {
              word += this.board[row][col].letter;
            } else {
              const placed = this.placedTiles.find(t => t.row === row && t.col === col);
              if (placed) {
                word += placed.tile.letter;
              }
            }
          }
          return word;
        }
      }

      validatePlacement() {
        if (this.placedTiles.length === 0) return false;
        
        // Auto-detect direction from placed tiles
        if (this.placedTiles.length === 1) {
          // Single tile - check if it extends an existing word
          const {row, col} = this.placedTiles[0];
          const hasHorizontalNeighbor = (col > 0 && this.board[row][col-1]) || (col < 14 && this.board[row][col+1]);
          const hasVerticalNeighbor = (row > 0 && this.board[row-1][col]) || (row < 14 && this.board[row+1][col]);
          
          if (hasHorizontalNeighbor && !hasVerticalNeighbor) {
            this.direction = 'horizontal';
          } else if (hasVerticalNeighbor && !hasHorizontalNeighbor) {
            this.direction = 'vertical';
          } else if (this.firstMove) {
            // First move, single tile - default to horizontal
            this.direction = 'horizontal';
          }
          // If both or neither, keep current direction
        } else {
          // Multiple tiles - detect from their arrangement
          const rows = this.placedTiles.map(t => t.row);
          const cols = this.placedTiles.map(t => t.col);
          const sameRow = rows.every(r => r === rows[0]);
          const sameCol = cols.every(c => c === cols[0]);
          
          if (sameRow) {
            this.direction = 'horizontal';
          } else if (sameCol) {
            this.direction = 'vertical';
          } else {
            // Tiles not in a line
            return false;
          }
        }
        
        const tiles = [...this.placedTiles];
        tiles.sort((a, b) => {
          if (this.direction === 'horizontal') {
            return a.col - b.col;
          }
          return a.row - b.row;
        });

        // Check if tiles are in a line
        if (this.direction === 'horizontal') {
          const row = tiles[0].row;
          if (!tiles.every(t => t.row === row)) return false;
          
          // Check continuity
          for (let i = 0; i < tiles.length - 1; i++) {
            const gap = tiles[i + 1].col - tiles[i].col;
            if (gap > 1) {
              // Check if gap is filled with existing tiles
              for (let col = tiles[i].col + 1; col < tiles[i + 1].col; col++) {
                if (!this.board[row][col]) return false;
              }
            }
          }
        } else {
          const col = tiles[0].col;
          if (!tiles.every(t => t.col === col)) return false;
          
          for (let i = 0; i < tiles.length - 1; i++) {
            const gap = tiles[i + 1].row - tiles[i].row;
            if (gap > 1) {
              for (let row = tiles[i].row + 1; row < tiles[i + 1].row; row++) {
                if (!this.board[row][col]) return false;
              }
            }
          }
        }

        // If not first move, check connection to existing tiles
        if (!this.firstMove) {
          let connected = false;
          for (const {row, col} of tiles) {
            const adjacent = [
              [row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]
            ];
            for (const [r, c] of adjacent) {
              if (r >= 0 && r < 15 && c >= 0 && c < 15 && this.board[r][c]) {
                connected = true;
                break;
              }
            }
            if (connected) break;
          }
          if (!connected) return false;
        }

        return true;
      }

      async aiTurn() {
        // Add thinking animation to AI score value
        const aiCard = document.getElementById('aiScoreCard');
        const aiScoreValue = aiCard.querySelector('.score-value');
        if (aiScoreValue) {
          aiScoreValue.style.animation = 'letterPulse 0.8s ease-in-out infinite';
        }
        
        // Try to find and play a valid word
        const aiMove = await this.findBestAiMove();
        
        // Remove thinking animation
        if (aiScoreValue) {
          aiScoreValue.style.animation = '';
        }
        
        if (aiMove) {
          const {tiles, startRow, startCol, direction, score, word} = aiMove;
          
          // Place tiles
          for (let i = 0; i < tiles.length; i++) {
            const row = direction === 'horizontal' ? startRow : startRow + i;
            const col = direction === 'horizontal' ? startCol + i : startCol;
            this.board[row][col] = tiles[i];
          }

          this.aiScore += score;
          this.aiRack = this.aiRack.filter(t => !tiles.includes(t));
          this.aiRack.push(...this.drawTiles(tiles.length));
          
          this.showMessage(`AI played "${word}" for ${score} points!`);
          this.firstMove = false;
          this.consecutivePasses = 0;
        } else {
          this.showMessage('AI passed their turn');
          this.consecutivePasses++;
        }

        this.renderBoard();
        this.updateScores();
        this.updateInfo();
        
        if (this.consecutivePasses >= 4) {
          this.endGame();
          return;
        }

        this.currentTurn = 'player';
        this.updateTurnIndicator();
      }

      async findBestAiMove() {
        let allPossibleMoves = [];
        
        if (this.firstMove) {
          // First move - try to place word horizontally at center
          allPossibleMoves = await this.findFirstMove();
        } else {
          // Find all possible moves on the board
          allPossibleMoves = await this.findAllPossibleMoves();
        }

        // If still no moves, try a desperation strategy with 2-letter words
        if (allPossibleMoves.length === 0 && !this.firstMove) {
          allPossibleMoves = await this.findDesperationMoves();
        }

        if (allPossibleMoves.length === 0) {
          return null; // No valid moves - will pass
        }

        // Sort by score
        allPossibleMoves.sort((a, b) => b.score - a.score);

        // Select move based on difficulty (1-10 scale)
        let selectedMove;
        const difficultyLevel = this.aiDifficulty;
        
        // Levels 1-6: Move selection based on score ranking (no lookahead)
        if (difficultyLevel === 1) {
          // Level 1: Completely random
          selectedMove = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
          
        } else if (difficultyLevel === 2) {
          // Level 2: Bottom 80%
          const moves = allPossibleMoves.slice(Math.floor(allPossibleMoves.length * 0.2));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 3) {
          // Level 3: Bottom 60%
          const moves = allPossibleMoves.slice(Math.floor(allPossibleMoves.length * 0.4));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 4) {
          // Level 4: Middle 60%
          const start = Math.floor(allPossibleMoves.length * 0.2);
          const end = Math.floor(allPossibleMoves.length * 0.8);
          const moves = allPossibleMoves.slice(start, end);
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 5) {
          // Level 5: Top 60%
          const moves = allPossibleMoves.slice(0, Math.ceil(allPossibleMoves.length * 0.6));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else if (difficultyLevel === 6) {
          // Level 6: Top 40%
          const moves = allPossibleMoves.slice(0, Math.ceil(allPossibleMoves.length * 0.4));
          selectedMove = moves[Math.floor(Math.random() * moves.length)];
          
        } else {
          // Levels 7-10: Use lookahead simulation
          const lookaheadDepth = difficultyLevel - 6; // 7->1, 8->2, 9->3, 10->4
          const topMoves = allPossibleMoves.slice(0, Math.min(5, allPossibleMoves.length)); // Consider top 5 moves
          
          let bestMoveWithLookahead = topMoves[0];
          let bestScore = -Infinity;
          
          for (const move of topMoves) {
            // Simulate this move and evaluate opponent's best response
            const evaluationScore = await this.evaluateMoveWithLookahead(move, lookaheadDepth);
            
            if (evaluationScore > bestScore) {
              bestScore = evaluationScore;
              bestMoveWithLookahead = move;
            }
          }
          
          selectedMove = bestMoveWithLookahead;
        }

        return selectedMove;
      }

      async evaluateMoveWithLookahead(move, depth) {
        if (depth === 0) {
          return move.score; // Base case: just return the immediate score
        }
        
        // Make a temporary copy of the board state
        const originalBoard = this.board.map(row => row.slice());
        const originalAiRack = [...this.aiRack];
        const originalPlayerRack = [...this.playerRack];
        
        // Simulate playing this move
        const {tiles, startRow, startCol, direction} = move;
        for (let i = 0; i < tiles.length; i++) {
          const row = direction === 'horizontal' ? startRow : startRow + i;
          const col = direction === 'horizontal' ? startCol + i : startCol;
          this.board[row][col] = tiles[i];
        }
        
        // Remove used tiles from AI rack (simulate)
        this.aiRack = this.aiRack.filter(t => !tiles.includes(t));
        
        // Simulate opponent's best counter-move
        let opponentBestScore = 0;
        
        // Quick simulation - just check top 3 opponent moves
        const opponentMoves = await this.findAllPossibleMoves();
        if (opponentMoves.length > 0) {
          opponentMoves.sort((a, b) => b.score - a.score);
          const topOpponentMove = opponentMoves[0];
          opponentBestScore = topOpponentMove.score;
          
          // Recursive lookahead if depth > 1
          if (depth > 1) {
            // Simulate opponent's move
            const {tiles: oppTiles, startRow: oppRow, startCol: oppCol, direction: oppDir} = topOpponentMove;
            for (let i = 0; i < oppTiles.length; i++) {
              const r = oppDir === 'horizontal' ? oppRow : oppRow + i;
              const c = oppDir === 'horizontal' ? oppCol + i : oppCol;
              this.board[r][c] = oppTiles[i];
            }
            
            // Recursively evaluate AI's next move
            const aiNextMoves = await this.findAllPossibleMoves();
            if (aiNextMoves.length > 0) {
              aiNextMoves.sort((a, b) => b.score - a.score);
              const futureScore = await this.evaluateMoveWithLookahead(aiNextMoves[0], depth - 1);
              opponentBestScore = futureScore; // Use the recursive evaluation
            }
          }
        }
        
        // Restore original board state
        this.board = originalBoard;
        this.aiRack = originalAiRack;
        this.playerRack = originalPlayerRack;
        
        // Evaluation: My score - Opponent's best response
        // Higher difficulty means we care more about denying opponent points
        return move.score - (opponentBestScore * 0.5);
      }

      async findDesperationMoves() {
        const moves = [];
        
        // Try all 2-letter combinations everywhere on board
        const twoLetterPerms = this.getPermutations(this.aiRack, 2);
        
        for (let row = 0; row < 15; row++) {
          for (let col = 0; col < 14; col++) {
            // Check if this position or adjacent has a tile
            const hasNearbyTile = 
              this.board[row][col] ||
              this.board[row][col+1] ||
              (row > 0 && (this.board[row-1][col] || this.board[row-1][col+1])) ||
              (row < 14 && (this.board[row+1][col] || this.board[row+1][col+1])) ||
              (col > 0 && this.board[row][col-1]) ||
              (col < 13 && this.board[row][col+2]);
            
            if (!hasNearbyTile && !this.firstMove) continue;
            
            // Try horizontal 2-letter words
            if (!this.board[row][col] && !this.board[row][col+1]) {
              for (const tiles of twoLetterPerms) {
                const word = tiles.map(t => t.letter).join('');
                if (offlineWords.has(word)) {
                  // Validate all cross-words
                  if (this.validateAllFormedWords(tiles, row, col, 'horizontal')) {
                    const score = this.calculateAiScore(tiles, row, col, 'horizontal');
                    moves.push({
                      tiles: tiles.slice(),
                      startRow: row,
                      startCol: col,
                      direction: 'horizontal',
                      score: score,
                      word: word
                    });
                  }
                }
              }
            }
          }
        }
        
        // Try vertical 2-letter words
        for (let row = 0; row < 14; row++) {
          for (let col = 0; col < 15; col++) {
            const hasNearbyTile = 
              this.board[row][col] ||
              this.board[row+1][col] ||
              (row > 0 && this.board[row-1][col]) ||
              (row < 13 && this.board[row+2][col]) ||
              (col > 0 && (this.board[row][col-1] || this.board[row+1][col-1])) ||
              (col < 14 && (this.board[row][col+1] || this.board[row+1][col+1]));
            
            if (!hasNearbyTile && !this.firstMove) continue;
            
            if (!this.board[row][col] && !this.board[row+1][col]) {
              for (const tiles of twoLetterPerms) {
                const word = tiles.map(t => t.letter).join('');
                if (offlineWords.has(word)) {
                  // Validate all cross-words
                  if (this.validateAllFormedWords(tiles, row, col, 'vertical')) {
                    const score = this.calculateAiScore(tiles, row, col, 'vertical');
                    moves.push({
                      tiles: tiles.slice(),
                      startRow: row,
                      startCol: col,
                      direction: 'vertical',
                      score: score,
                      word: word
                    });
                  }
                }
              }
            }
          }
        }
        
        return moves;
      }

      async findFirstMove() {
        const moves = [];
        
        // Difficulty controls search depth - how many permutations to check
        let maxLength = 7;
        let maxPermsToCheck = Infinity;
        
        if (this.aiDifficulty === 'easy') {
          maxLength = 4; // Try shorter words only
          maxPermsToCheck = 50; // Check fewer permutations
        } else if (this.aiDifficulty === 'medium') {
          maxLength = 6;
          maxPermsToCheck = 200;
        }
        // Hard: tries all lengths up to 7, all permutations
        
        // Try different word lengths from rack
        for (let len = 2; len <= Math.min(maxLength, this.aiRack.length); len++) {
          // Get all permutations of tiles
          const permutations = this.getPermutations(this.aiRack, len);
          const permsToCheck = Math.min(maxPermsToCheck, permutations.length);
          
          for (let i = 0; i < permsToCheck; i++) {
            const tiles = permutations[i];
            const word = tiles.map(t => t.letter).join('');
            
            // Check if it's a valid word
            if (offlineWords.has(word)) {
              const startCol = 7 - Math.floor(len / 2);
              if (startCol >= 0 && startCol + len <= 15) {
                // First move has no cross-words to check, so it's always valid
                const score = this.calculateAiScore(tiles, 7, startCol, 'horizontal');
                moves.push({
                  tiles: tiles.slice(), // Clone array
                  startRow: 7,
                  startCol: startCol,
                  direction: 'horizontal',
                  score: score,
                  word: word
                });
              }
            }
          }
        }
        
        return moves;
      }

      async findAllPossibleMoves() {
        const moves = [];
        
        // Difficulty controls search thoroughness
        let searchEveryNthCell = 1;
        let maxWordLength = 7;
        let stopEarlyThreshold = Infinity;
        
        if (this.aiDifficulty === 'easy') {
          searchEveryNthCell = 2; // Skip some cells (less thorough)
          maxWordLength = 4; // Try shorter words
          stopEarlyThreshold = 30; // Stop after finding 30 moves
        } else if (this.aiDifficulty === 'medium') {
          searchEveryNthCell = 1;
          maxWordLength = 6;
          stopEarlyThreshold = 100; // Stop after finding 100 moves
        }
        // Hard: search every cell, all word lengths, find all moves
        
        // For each empty cell adjacent to an occupied cell
        for (let row = 0; row < 15; row += searchEveryNthCell) {
          for (let col = 0; col < 15; col += searchEveryNthCell) {
            if (!this.board[row][col]) {
              // Check if adjacent to an occupied cell
              const hasAdjacentTile = 
                (row > 0 && this.board[row-1][col]) ||
                (row < 14 && this.board[row+1][col]) ||
                (col > 0 && this.board[row][col-1]) ||
                (col < 14 && this.board[row][col+1]);
              
              if (hasAdjacentTile) {
                // Try both horizontal and vertical
                const hMoves = await this.findMovesAt(row, col, 'horizontal', maxWordLength);
                const vMoves = await this.findMovesAt(row, col, 'vertical', maxWordLength);
                moves.push(...hMoves, ...vMoves);
                
                // Stop early based on difficulty
                if (moves.length >= stopEarlyThreshold) {
                  return moves;
                }
              }
            }
          }
        }
        
        return moves;
      }

      async findMovesAt(row, col, direction, maxWordLength = 7) {
        const moves = [];
        
        // Limit permutations based on difficulty
        let maxPermsPerLength = Infinity;
        if (this.aiDifficulty === 'easy') {
          maxPermsPerLength = 30; // Check fewer permutations
        } else if (this.aiDifficulty === 'medium') {
          maxPermsPerLength = 100;
        }
        // Hard: check all permutations
        
        // Try different word lengths
        for (let len = 2; len <= Math.min(maxWordLength, this.aiRack.length); len++) {
          // Get all permutations
          const permutations = this.getPermutations(this.aiRack, len);
          const permsToCheck = Math.min(maxPermsPerLength, permutations.length);
          
          for (let i = 0; i < permsToCheck; i++) {
            const tiles = permutations[i];
            // Try different starting positions for this word
            for (let offset = 0; offset < len; offset++) {
              const startRow = direction === 'vertical' ? row - offset : row;
              const startCol = direction === 'horizontal' ? col - offset : col;
              
              if (startRow < 0 || startCol < 0) continue;
              
              const endRow = direction === 'vertical' ? startRow + len - 1 : startRow;
              const endCol = direction === 'horizontal' ? startCol + len - 1 : startCol;
              
              if (endRow >= 15 || endCol >= 15) continue;
              
              // Check if placement is valid (all cells empty or one matches existing)
              let canPlace = true;
              let touchesExisting = false;
              
              for (let i = 0; i < len; i++) {
                const r = direction === 'vertical' ? startRow + i : startRow;
                const c = direction === 'horizontal' ? startCol + i : startCol;
                
                if (this.board[r][c]) {
                  canPlace = false;
                  break;
                }
                
                // Check if adjacent to existing tile
                const adjacent = 
                  (r > 0 && this.board[r-1][c]) ||
                  (r < 14 && this.board[r+1][c]) ||
                  (c > 0 && this.board[r][c-1]) ||
                  (c < 14 && this.board[r][c+1]);
                
                if (adjacent) touchesExisting = true;
              }
              
              if (canPlace && touchesExisting) {
                const word = tiles.map(t => t.letter).join('');
                
                // Check if main word is valid
                if (offlineWords.has(word)) {
                  // CRITICAL: Check all cross-words formed
                  const allWordsValid = this.validateAllFormedWords(tiles, startRow, startCol, direction);
                  
                  if (allWordsValid) {
                    const score = this.calculateAiScore(tiles, startRow, startCol, direction);
                    moves.push({
                      tiles: tiles.slice(), // Clone array
                      startRow: startRow,
                      startCol: startCol,
                      direction: direction,
                      score: score,
                      word: word
                    });
                  }
                }
              }
            }
          }
        }
        
        return moves;
      }

      validateAllFormedWords(tiles, startRow, startCol, direction) {
        // Temporarily place tiles to check all formed words
        const tempPlacements = [];
        
        for (let i = 0; i < tiles.length; i++) {
          const r = direction === 'vertical' ? startRow + i : startRow;
          const c = direction === 'horizontal' ? startCol + i : startCol;
          this.board[r][c] = tiles[i];
          tempPlacements.push({r, c});
        }
        
        let allValid = true;
        
        // FIRST: Check the main word (including any tiles it connects to in-line)
        let mainWord = '';
        if (direction === 'horizontal') {
          let startC = startCol;
          let endC = startCol + tiles.length - 1;
          
          // Extend to beginning of existing word
          while (startC > 0 && this.board[startRow][startC - 1]) {
            startC--;
          }
          
          // Extend to end of existing word
          while (endC < 14 && this.board[startRow][endC + 1]) {
            endC++;
          }
          
          // Build complete word
          for (let col = startC; col <= endC; col++) {
            mainWord += this.board[startRow][col].letter;
          }
        } else {
          let startR = startRow;
          let endR = startRow + tiles.length - 1;
          
          // Extend to beginning of existing word
          while (startR > 0 && this.board[startR - 1][startCol]) {
            startR--;
          }
          
          // Extend to end of existing word
          while (endR < 14 && this.board[endR + 1][startCol]) {
            endR++;
          }
          
          // Build complete word
          for (let row = startR; row <= endR; row++) {
            mainWord += this.board[row][startCol].letter;
          }
        }
        
        // Validate main word (if longer than just the placed tiles, it's extending an existing word)
        if (mainWord.length > tiles.length && !offlineWords.has(mainWord)) {
          allValid = false;
        }
        
        // SECOND: Check each placed tile for cross-words (perpendicular)
        if (allValid) {
          for (let i = 0; i < tiles.length; i++) {
            const r = direction === 'vertical' ? startRow + i : startRow;
            const c = direction === 'horizontal' ? startCol + i : startCol;
            
            // Check perpendicular direction
            let crossWord = '';
            if (direction === 'horizontal') {
              // Check vertical cross-word
              let startR = r;
              let endR = r;
              
              // Find start of word
              while (startR > 0 && this.board[startR - 1][c]) {
                startR--;
              }
              
              // Find end of word
              while (endR < 14 && this.board[endR + 1][c]) {
                endR++;
              }
              
              // Build word
              if (startR !== endR) { // There's a cross-word
                for (let row = startR; row <= endR; row++) {
                  crossWord += this.board[row][c].letter;
                }
              }
            } else {
              // Check horizontal cross-word
              let startC = c;
              let endC = c;
              
              // Find start of word
              while (startC > 0 && this.board[r][startC - 1]) {
                startC--;
              }
              
              // Find end of word
              while (endC < 14 && this.board[r][endC + 1]) {
                endC++;
              }
              
              // Build word
              if (startC !== endC) { // There's a cross-word
                for (let col = startC; col <= endC; col++) {
                  crossWord += this.board[r][col].letter;
                }
              }
            }
            
            // Validate cross-word if it exists and is more than 1 letter
            if (crossWord.length > 1 && !offlineWords.has(crossWord)) {
              allValid = false;
              break;
            }
          }
        }
        
        // Remove temporary placements
        for (const {r, c} of tempPlacements) {
          this.board[r][c] = null;
        }
        
        return allValid;
      }

      getPermutations(tiles, length) {
        if (length === 0) return [[]];
        if (tiles.length === 0) return [];
        if (length > tiles.length) return [];
        
        const result = [];
        
        for (let i = 0; i < tiles.length; i++) {
          const current = tiles[i];
          const remaining = [...tiles.slice(0, i), ...tiles.slice(i + 1)];
          const perms = this.getPermutations(remaining, length - 1);
          
          for (const perm of perms) {
            result.push([current, ...perm]);
          }
        }
        
        return result;
      }

      calculateAiScore(tiles, row, col, direction) {
        // Get the full word range including existing tiles
        let startPos = direction === 'horizontal' ? col : row;
        let endPos = startPos + tiles.length - 1;
        let fixedPos = direction === 'horizontal' ? row : col;
        
        // Extend to beginning
        if (direction === 'horizontal') {
          while (startPos > 0 && this.board[fixedPos][startPos - 1]) {
            startPos--;
          }
          // Extend to end
          while (endPos < 14 && this.board[fixedPos][endPos + 1]) {
            endPos++;
          }
        } else {
          while (startPos > 0 && this.board[startPos - 1][fixedPos]) {
            startPos--;
          }
          // Extend to end
          while (endPos < 14 && this.board[endPos + 1][fixedPos]) {
            endPos++;
          }
        }

        let score = 0;
        let wordMultiplier = 1;

        // Score the entire word
        for (let pos = startPos; pos <= endPos; pos++) {
          let r, c, tile;
          
          if (direction === 'horizontal') {
            r = fixedPos;
            c = pos;
          } else {
            r = pos;
            c = fixedPos;
          }
          
          // Get tile from board or newly placed tiles
          if (this.board[r][c]) {
            tile = this.board[r][c];
          } else {
            // Find in newly placed tiles
            const tileIndex = direction === 'horizontal' ? (c - col) : (r - row);
            if (tileIndex >= 0 && tileIndex < tiles.length) {
              tile = tiles[tileIndex];
            }
          }
          
          if (tile) {
            let letterScore = tile.points;
            
            // Only apply premium squares for newly placed tiles
            const isNewlyPlaced = direction === 'horizontal' ? 
              (r === row && c >= col && c < col + tiles.length) :
              (c === col && r >= row && r < row + tiles.length);
            
            if (isNewlyPlaced) {
              // Apply letter multipliers
              if (PREMIUM_SQUARES.dls.some(([pr, pc]) => pr === r && pc === c)) {
                letterScore *= 2;
              } else if (PREMIUM_SQUARES.tls.some(([pr, pc]) => pr === r && pc === c)) {
                letterScore *= 3;
              }

              // Apply word multipliers
              if (PREMIUM_SQUARES.dws.some(([pr, pc]) => pr === r && pc === c)) {
                wordMultiplier *= 2;
              } else if (PREMIUM_SQUARES.tws.some(([pr, pc]) => pr === r && pc === c)) {
                wordMultiplier *= 3;
              }
            }
            
            score += letterScore;
          }
        }

        score *= wordMultiplier;

        // Bonus for using all 7 tiles
        if (tiles.length === 7) {
          score += 50;
        }

        return score;
      }

      passTurn() {
        // v2.0.0: Multi-player turn validation
        const currentPlayer = this.players[this.currentPlayerIndex];
        if (this.gameMode === 'online' && !currentPlayer.isMe) {
          this.showMessage(`Wait for ${currentPlayer.name}'s turn`);
          return;
        }
        
        // Recall any placed tiles before passing
        this.recallTiles();
        
        this.consecutivePasses++;
        
        // Send pass to opponents in online mode
        if (this.gameMode === 'online') {
          sendMoveV2({ 
            type: 'pass',
            playerOrder: currentPlayer.order
          });
        }
        
        this.showMessage(`${currentPlayer.name} passed their turn`);
        
        // End game if everyone passes (2x number of players)
        if (this.consecutivePasses >= this.players.length * 2) {
          this.endGame();
          return;
        }

        // Switch to next turn
        this.nextTurn();
        
        // Handle AI or human turn
        const nextPlayer = this.players[this.currentPlayerIndex];
        if (this.gameMode === 'ai' && nextPlayer.id === 'ai') {
          setTimeout(() => this.aiTurn(), 1500);
        } else if (this.gameMode === 'human') {
          const message = nextPlayer.isMe ? 'Your turn' : `${nextPlayer.name}'s turn`;
          this.showMessage(message);
          this.showTurnTransition();
        } else if (this.gameMode === 'online') {
          if (nextPlayer.isMe) {
            this.showMessage('Your turn!');
            this.renderRack();
          } else {
            this.showMessage("Opponent's turn...");
          }
        }
      }

      endGame() {
        // Play game over sound
        SFX.gameOver();
        
        // v2.0.0: Multi-player end game
        // Sort players by score
        const sortedPlayers = [...this.players].sort((a, b) => b.score - a.score);
        const highestScore = sortedPlayers[0].score;
        const winners = sortedPlayers.filter(p => p.score === highestScore);
        
        let resultMessage;
        if (winners.length > 1) {
          // Tie
          const winnerNames = winners.map(p => p.name).join(' and ');
          resultMessage = `It's a tie! ${winnerNames} tied with ${highestScore} points!`;
        } else {
          // Single winner
          resultMessage = `${winners[0].name} wins with ${highestScore} points!`;
        }
        
        // Build score summary
        const scoreList = sortedPlayers
          .map((p, idx) => `${idx + 1}. ${p.name}: ${p.score}`)
          .join(' | ');
        
        this.showMessage(`Game Over! ${resultMessage}\n\nFinal Scores: ${scoreList}`);
        
        // Update database status
        if (this.gameMode === 'online' && currentGameId) {
          updateGameStatus('finished');
        }
        
        // Save stats for user
        if (this.gameMode === 'ai' && currentUser) {
          const playerWon = this.players[0].score > (this.players[1]?.score || 0);
          
          // Check if this is a calibration game
          if (isCalibrationGame) {
            const playerScore = this.players[0].score;
            const botScore = this.players[1]?.score || 0;
            
            // Trigger calibration analysis
            setTimeout(() => {
              onCalibrationGameEnd(playerScore, botScore);
            }, 2000);
            
            return; // Don't save normal stats for calibration games
          }
          
          saveGameResult(playerWon, this.players[0].score, this.players[1]?.score || 0);
        }
        
        // Show play again button
        const playAgainBtn = document.createElement('button');
        playAgainBtn.className = 'btn-primary';
        playAgainBtn.textContent = 'Play Again';
        playAgainBtn.style.marginTop = '20px';
        playAgainBtn.onclick = () => location.reload();
        
        const messageEl = document.getElementById('message');
        messageEl.appendChild(document.createElement('br'));
        messageEl.appendChild(playAgainBtn);
        
        // Disable game controls
        document.getElementById('playBtn').disabled = true;
        document.getElementById('shuffleBtn').disabled = true;
        document.getElementById('recallBtn').disabled = true;
        document.getElementById('passBtn').disabled = true;
      }

      shuffleRack() {
        SFX.shuffle();
        this.playerRack = this.shuffle(this.playerRack);
        this.renderRack();
      }

      updateScores() {
        // v2.0.0: Multi-player support
        if (this.players.length > 2) {
          // Show multi-player scores
          document.getElementById('legacyScores').style.display = 'none';
          document.getElementById('multiplayerScores').style.display = 'flex';
          
          const container = document.getElementById('multiplayerScores');
          container.innerHTML = this.players.map((player, idx) => {
            const isActive = idx === this.currentPlayerIndex;
            const isMe = player.isMe;
            return `
              <div class="score-card ${isActive ? 'active' : ''}" style="min-width: 120px;">
                <div class="score-label" style="font-size: 0.9rem;">
                  ${player.name}${isMe ? ' (You)' : ''}
                </div>
                <div class="score-value">${player.score}</div>
              </div>
            `;
          }).join('');
        } else {
          // Use legacy 2-player display
          document.getElementById('legacyScores').style.display = 'flex';
          document.getElementById('multiplayerScores').style.display = 'none';
          
          // Update legacy scores
          this.playerScore = this.players[0].score;
          this.aiScore = this.players.length > 1 ? this.players[1].score : 0;
          
          document.getElementById('playerScore').textContent = this.playerScore;
          document.getElementById('aiScore').textContent = this.aiScore;
        }
      }

      updateInfo() {
        document.getElementById('tilesRemaining').textContent = this.tileBag.length;
      }

      // v2.0.0: Multi-player turn rotation
      nextTurn() {
        this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length;
        
        // Update legacy currentTurn for compatibility
        if (this.players.length === 2) {
          this.currentTurn = this.currentPlayerIndex === 0 ? 'player' : 'ai';
        }
        
        this.updateTurnIndicator();
        
        // Show turn message
        const currentPlayer = this.players[this.currentPlayerIndex];
        if (this.gameMode === 'online') {
          if (currentPlayer.isMe) {
            this.showMessage('Your turn!');
          } else {
            this.showMessage(`Waiting for ${currentPlayer.name}...`);
          }
        }
      }

      updateTurnIndicator() {
        document.getElementById('turnIndicator').textContent = this.currentTurn === 'player' ? 'âœ“' : 'âœ—';
        
        const playerCard = document.getElementById('playerScoreCard');
        const aiCard = document.getElementById('aiScoreCard');
        
        // Remove all animation classes first
        playerCard.classList.remove('active', 'inactive', 'turn-flip');
        aiCard.classList.remove('active', 'inactive', 'turn-flip');
        
        // Force reflow to restart animation
        void playerCard.offsetWidth;
        void aiCard.offsetWidth;
        
        // Add classes with animation
        if (this.currentTurn === 'player') {
          playerCard.classList.add('active', 'turn-flip');
          aiCard.classList.add('inactive');
        } else {
          aiCard.classList.add('active', 'turn-flip');
          playerCard.classList.add('inactive');
        }
      }

      showMessage(text) {
        document.getElementById('message').textContent = text;
      }

      setupEventListeners() {
        document.getElementById('playBtn').addEventListener('click', () => this.playWord());
        document.getElementById('shuffleBtn').addEventListener('click', () => this.shuffleRack());
        document.getElementById('recallBtn').addEventListener('click', () => this.recallTiles());
        document.getElementById('passBtn').addEventListener('click', () => this.passTurn());
      }

      // Online multiplayer methods
      applyRemoteMove(data) {
        // Clear opponent preview tiles since they're now playing
        this.opponentPreviewTiles = [];
        
        // v2.0.0: Find which player made this move
        const playerWhoMoved = this.players.find(p => p.order === data.playerOrder);
        if (!playerWhoMoved) {
          console.error('Unknown player order:', data.playerOrder);
          return;
        }
        
        // Apply move to board
        data.tiles.forEach(({letter, points, row, col}) => {
          this.board[row][col] = {letter, points};
        });

        // Update that player's score
        playerWhoMoved.score += data.score;
        
        // Update legacy scores
        if (playerWhoMoved.order === 1) {
          this.playerScore = playerWhoMoved.score;
        } else if (playerWhoMoved.order === 2) {
          this.aiScore = playerWhoMoved.score;
        }

        this.firstMove = false;
        this.consecutivePasses = 0;
        
        this.showMessage(`${playerWhoMoved.name} played "${data.word}" for ${data.score} points!`);
        
        // Switch to next turn
        this.nextTurn();
        
        // Update UI
        this.updateScores();
        this.renderBoard();
        this.renderRack();
        
        // Save game state to database
        if (this.gameMode === 'online') {
          this.saveGameState();
        }
      }

      applyRemotePass(data) {
        // v2.0.0: Find which player passed
        const playerWhoPassed = data && data.playerOrder ? 
          this.players.find(p => p.order === data.playerOrder) :
          this.players[this.currentPlayerIndex]; // Fallback for old 2-player
        
        this.consecutivePasses++;
        
        const playerName = playerWhoPassed ? playerWhoPassed.name : 'Player';
        this.showMessage(`${playerName} passed their turn`);
        
        // End game if too many passes
        if (this.consecutivePasses >= this.players.length * 2) {
          this.endGame();
          return;
        }
        
        // Switch to next turn
        this.nextTurn();
        
        // Update UI
        this.updateScores();
        this.renderBoard();
        this.renderRack();
        
        // Save game state to database
        if (this.gameMode === 'online') {
          this.saveGameState();
        }
      }

      // Handle opponent tile placement preview
      addOpponentPreviewTile(data) {
        this.opponentPreviewTiles.push({
          letter: data.letter,
          points: data.points,
          row: data.row,
          col: data.col
        });
        this.renderBoard();
      }

      // Handle opponent recalling tiles
      clearOpponentPreviewTiles(positions) {
        if (positions && positions.length > 0) {
          // Remove specific positions
          this.opponentPreviewTiles = this.opponentPreviewTiles.filter(tile => {
            return !positions.some(pos => pos.row === tile.row && pos.col === tile.col);
          });
        } else {
          // Clear all
          this.opponentPreviewTiles = [];
        }
        this.renderBoard();
      }
      
      // ============================================
      // GAME STATE MANAGEMENT (v1.6.3 - Rejoin System)
      // ============================================
      
      async saveGameState() {
        if (this.mode !== 'online' || !currentGameId) return;
        
        try {
          const gameState = {
            board: this.board,
            playerScore: this.playerScore,
            aiScore: this.aiScore,
            bag: this.bag,
            firstMove: this.firstMove,
            consecutivePasses: this.consecutivePasses,
            gameOver: this.gameOver,
            // Don't save racks - they're private to each player
            player1Name: player1Name,
            player2Name: player2Name
          };
          
          const currentTurnPlayer = this.currentTurn === 'player' ? 'host' : 'guest';
          
          const { error } = await window.supabase
            .from('games')
            .update({
              game_state: gameState,
              current_turn: currentTurnPlayer,
              last_update: new Date().toISOString()
            })
            .eq('id', currentGameId);
          
          if (error) {
            console.error('Error saving game state:', error);
          }
        } catch (error) {
          console.error('Error saving game state:', error);
        }
      }
      
      async loadGameState(gameId) {
        try {
          const { data, error } = await window.supabase
            .from('games')
            .select('*')
            .eq('id', gameId)
            .single();
          
          if (error) throw error;
          
          if (data && data.game_state) {
            const state = data.game_state;
            this.board = state.board || this.board;
            this.playerScore = state.playerScore || 0;
            this.aiScore = state.aiScore || 0;
            this.bag = state.bag || this.bag;
            this.firstMove = state.firstMove !== undefined ? state.firstMove : true;
            this.consecutivePasses = state.consecutivePasses || 0;
            this.gameOver = state.gameOver || false;
            
            // Restore turn
            this.currentTurn = data.current_turn === 'host' ? 'player' : 'ai';
            
            // Re-render everything
            this.renderBoard();
            this.updateScores();
            this.updateTurnIndicator();
            this.renderRack();
            
            console.log('âœ… Game state loaded');
            return true;
          }
          
          return false;
        } catch (error) {
          console.error('Error loading game state:', error);
          return false;
        }
      }
    }

    // ============================================
    // GAME RECONNECTION SYSTEM (v1.6.3)
    // ============================================
    
    // currentGameId already declared in global variables section (line ~3936)
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 3;
    
    async function createGameRecord() {
      if (!currentUser) return null;
      
      try {
        const { data, error } = await window.supabase
          .from('games')
          .insert({
            host_id: currentUser.id,
            host_peer_id: myGameCode,
            status: 'waiting',
            host_connected: true,
            game_state: {}
          })
          .select()
          .single();
        
        if (error) throw error;
        
        currentGameId = data.id;
        console.log('âœ… Game record created:', currentGameId);
        return data.id;
      } catch (error) {
        console.error('Error creating game record:', error);
        return null;
      }
    }
    
    // ============================================
    // v2.0.0 MULTI-PLAYER DATABASE FUNCTIONS
    // ============================================
    
    async function createGameRecordV2() {
      try {
        // Create game record
        const { data: gameData, error: gameError } = await window.supabase
          .from('online_games')
          .insert({
            game_code: myGameCode,
            host_id: currentUser ? currentUser.id : null,
            status: 'waiting',
            max_players: 4
          })
          .select()
          .single();
        
        if (gameError) throw gameError;
        
        currentGameId = gameData.id;
        myPlayerId = gameData.id + '-host'; // Temporary ID for host
        
        // Add host as first player
        const { data: playerData, error: playerError } = await window.supabase
          .from('game_players')
          .insert({
            game_id: currentGameId,
            player_id: currentUser ? currentUser.id : null,
            player_name: myOnlineName,
            player_order: 1,
            is_host: true,
            peer_id: myGameCode
          })
          .select()
          .single();
        
        if (playerError) throw playerError;
        
        myPlayerId = playerData.id;
        console.log('âœ… Game created:', currentGameId, 'Player ID:', myPlayerId);
        return currentGameId;
      } catch (error) {
        console.error('Error creating game:', error);
        document.getElementById('connectionStatus').innerHTML = '<div style="color: #ff6b6b;">âŒ Database error. Please try again.</div>';
        return null;
      }
    }
    
    async function addPlayerToGame(playerName, peerId) {
      try {
        // Get current player count
        const { data: players, error: countError } = await window.supabase
          .from('game_players')
          .select('player_order')
          .eq('game_id', currentGameId)
          .order('player_order', { ascending: false })
          .limit(1);
        
        if (countError) throw countError;
        
        const nextOrder = players && players.length > 0 ? players[0].player_order + 1 : 1;
        
        if (nextOrder > 4) {
          console.error('Game is full');
          return null;
        }
        
        // Add player
        const { data: playerData, error: playerError } = await window.supabase
          .from('game_players')
          .insert({
            game_id: currentGameId,
            player_id: null, // Anonymous for now
            player_name: playerName,
            player_order: nextOrder,
            is_host: false,
            peer_id: peerId
          })
          .select()
          .single();
        
        if (playerError) throw playerError;
        
        console.log('âœ… Player added:', playerData);
        return playerData;
      } catch (error) {
        console.error('Error adding player:', error);
        return null;
      }
    }
    
    async function getGamePlayers() {
      try {
        const { data, error } = await window.supabase
          .from('game_players')
          .select('*')
          .eq('game_id', currentGameId)
          .order('player_order', { ascending: true });
        
        if (error) throw error;
        return data || [];
      } catch (error) {
        console.error('Error getting players:', error);
        return [];
      }
    }
    
    async function updateGameStatus(status) {
      try {
        const updates = { status };
        if (status === 'playing') {
          updates.started_at = new Date().toISOString();
        } else if (status === 'finished') {
          updates.finished_at = new Date().toISOString();
        }
        
        const { error } = await window.supabase
          .from('online_games')
          .update(updates)
          .eq('id', currentGameId);
        
        if (error) throw error;
        console.log('âœ… Game status updated:', status);
      } catch (error) {
        console.error('Error updating game status:', error);
      }
    }
    
    // ============================================
    // END v2.0.0 FUNCTIONS
    // ============================================
    
    async function updateGameRecord(updates) {
      if (!currentGameId) return;
      
      try {
        const { error } = await window.supabase
          .from('games')
          .update({
            ...updates,
            last_update: new Date().toISOString()
          })
          .eq('id', currentGameId);
        
        if (error) throw error;
      } catch (error) {
        console.error('Error updating game record:', error);
      }
    }
    
    async function markDisconnected(playerRole) {
      if (!currentGameId) return;
      
      try {
        const updates = {
          status: 'disconnected',
          disconnected_player: playerRole,
          disconnect_timestamp: new Date().toISOString()
        };
        
        if (playerRole === 'host') {
          updates.host_connected = false;
        } else {
          updates.guest_connected = false;
        }
        
        await updateGameRecord(updates);
        console.log('ðŸ”Œ Marked as disconnected:', playerRole);
      } catch (error) {
        console.error('Error marking disconnected:', error);
      }
    }
    
    async function checkForRejoinableGame() {
      if (!currentUser) return null;
      
      try {
        // Look for active or disconnected games where user is a player
        const { data, error } = await window.supabase
          .from('games')
          .select('*')
          .or(`host_id.eq.${currentUser.id},guest_id.eq.${currentUser.id}`)
          .in('status', ['active', 'disconnected'])
          .order('last_update', { ascending: false })
          .limit(1);
        
        if (error) throw error;
        
        if (data && data.length > 0) {
          const game = data[0];
          
          // Check if within 5-minute rejoin window
          const disconnectTime = new Date(game.disconnect_timestamp || game.last_update);
          const now = new Date();
          const minutesElapsed = (now - disconnectTime) / 1000 / 60;
          
          if (minutesElapsed < 5) {
            return game;
          } else {
            // Game expired, mark as forfeited
            await window.supabase
              .from('games')
              .update({ status: 'forfeited' })
              .eq('id', game.id);
            
            return null;
          }
        }
        
        return null;
      } catch (error) {
        console.error('Error checking for rejoinable game:', error);
        return null;
      }
    }
    
    async function rejoinGame(gameData) {
      try {
        currentGameId = gameData.id;
        const isHost = gameData.host_id === currentUser.id;
        const playerRole = isHost ? 'host' : 'guest';
        
        // Update connection status
        const updates = {
          status: 'active',
          disconnected_player: null,
          disconnect_timestamp: null
        };
        
        if (isHost) {
          updates.host_connected = true;
        } else {
          updates.guest_connected = true;
        }
        
        await updateGameRecord(updates);
        
        // Reconnect to peer
        const opponentPeerId = isHost ? gameData.guest_peer_id : gameData.host_peer_id;
        
        if (opponentPeerId) {
          // Initialize new peer
          peer = new Peer();
          
          peer.on('open', (newId) => {
            // Update our peer ID in database
            const peerUpdate = isHost ? { host_peer_id: newId } : { guest_peer_id: newId };
            updateGameRecord(peerUpdate);
            
            // Try to connect to opponent
            connection = peer.connect(opponentPeerId);
            
            connection.on('open', () => {
              console.log('âœ… Reconnected to opponent');
              setupConnection();
              
              // Notify opponent of reconnection
              connection.send({
                type: 'reconnect',
                playerRole: playerRole
              });
              
              // Load game state and resume
              if (game) {
                game.loadGameState(currentGameId);
              }
            });
          });
        }
        
        console.log('âœ… Rejoined game:', currentGameId);
        return true;
      } catch (error) {
        console.error('Error rejoining game:', error);
        return false;
      }
    }

    // ============================================
    // ADMIN PANEL FUNCTIONS (v1.4.0)
    // ============================================
    
    let currentBanUserId = null;
    let currentBanUsername = null;

    function openAdminPanel() {
      const panel = document.getElementById('adminPanel');
      panel.style.display = 'flex';
      
      // Load data for current tab
      switchAdminTab('players');
    }

    function closeAdminPanel() {
      document.getElementById('adminPanel').style.display = 'none';
    }


    // REMOVED: Duplicate switchAdminTab function (line 6831-6852)



    async function checkBanStatus() {
      if (!currentUser) return true; // Allow if no user
      
      try {
        const { data: userData, error } = await supabase
          .from('users')
          .select('*')
          .eq('id', currentUser.id)
          .single();
        
        if (error || !userData || userData.status !== 'banned') {
          return true; // Not banned, allow access
        }
        
        // Check if temporary ban has expired
        if (!userData.ban_permanent && userData.ban_expires_at) {
          if (Date.now() >= userData.ban_expires_at) {
            // Ban expired, auto-unban
            await supabase
              .from('users')
              .update({
                status: 'active',
                ban_reason: null,
                banned_at: null,
                banned_by: null,
                ban_duration: null,
                ban_expires_at: null,
                ban_permanent: null
              })
              .eq('id', currentUser.id);
            
            // Remove from bans table
            await supabase
              .from('bans')
              .delete()
              .eq('user_id', currentUser.id);
            
            alert('Your ban has expired. Welcome back!');
            return true; // Allow access
          }
        }
        
        // User is banned, show ban screen
        showBanScreen(userData);
        return false;
        
      } catch (error) {
        console.error('Check ban status error:', error);
        return true; // Allow on error
      }
    }

    function showBanScreen(userData) {
      // Hide all other interfaces
      document.getElementById('authContainer').style.display = 'none';
      document.getElementById('modeSelection').style.display = 'none';
      document.getElementById('gameBoard').style.display = 'none';
      document.getElementById('settingsBtn').style.display = 'none';
      document.getElementById('adminPanelBtn').style.display = 'none';
      
      // Create and show ban screen
      let banScreen = document.getElementById('banScreen');
      if (!banScreen) {
        banScreen = document.createElement('div');
        banScreen.id = 'banScreen';
        document.body.appendChild(banScreen);
      }
      
      const isPermanent = userData.ban_permanent;
      const remainingTime = !isPermanent && userData.ban_expires_at ? formatTimeRemaining(userData.ban_expires_at) : null;
      
      banScreen.innerHTML = `
        <div style="
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 20000;
        ">
          <div style="
            background: white;
            border-radius: 16px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
          ">
            <div style="font-size: 80px; margin-bottom: 20px;">ðŸš«</div>
            <h2 style="margin: 0 0 20px 0; color: #e74c3c; font-size: 28px;">
              Account ${isPermanent ? 'Permanently ' : 'Temporarily '}Banned
            </h2>
            
            <div style="background: #ffebee; border-left: 4px solid #e74c3c; padding: 20px; margin: 20px 0; border-radius: 8px; text-align: left;">
              <strong style="color: #c0392b; display: block; margin-bottom: 10px;">Reason:</strong>
              <div style="color: #2c3e50;">${userData.ban_reason || 'No reason provided'}</div>
            </div>
            
            ${!isPermanent && remainingTime ? `
              <div style="background: #fff3cd; border-left: 4px solid #f39c12; padding: 20px; margin: 20px 0; border-radius: 8px;">
                <strong style="color: #e67e22; display: block; margin-bottom: 10px;">Time Remaining:</strong>
                <div style="font-size: 24px; font-weight: 600; color: #2c3e50;">${remainingTime}</div>
              </div>
            ` : ''}
            
            ${isPermanent ? `
              <p style="color: #7f8c8d; margin: 20px 0;">
                This ban is permanent. If you believe this is a mistake, please contact support.
              </p>
            ` : ''}
            
            <button onclick="handleLogout()" style="
              background: #95a5a6;
              color: white;
              border: none;
              padding: 15px 40px;
              border-radius: 8px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              margin-top: 20px;
              font-family: Georgia, 'Times New Roman', serif;
            ">
              Logout
            </button>
          </div>
        </div>
      `;
      
      banScreen.style.display = 'block';
    }

    // ============================================
    // END ADMIN PANEL FUNCTIONS
    // ============================================

    // ============================================
    // AUTH INITIALIZATION (at end so all functions exist)
    // ============================================
    document.addEventListener('DOMContentLoaded', async () => {
      console.log('ðŸ” Initializing auth...');
      
      // Attach auth button listeners
      const googleBtn = document.getElementById('googleSignInBtn');
      if (googleBtn) {
        googleBtn.addEventListener('click', (e) => {
          console.log('ðŸ–±ï¸ Google button clicked!', e);
          signInWithGoogle();
        });
        console.log('âœ… Google button listener attached');
      } else {
        console.error('âŒ Google button not found in DOM!');
      }
      
      const guestBtn = document.getElementById('guestPlayBtn');
      if (guestBtn) {
        guestBtn.addEventListener('click', playAnonymously);
        console.log('âœ… Guest button listener attached');
      }
      
      // On fresh browser session (not refresh), reset theme to default
      // sessionStorage is cleared when browser/tab is closed
      if (!sessionStorage.getItem('scrabble_session_started')) {
        localStorage.setItem('scrabble_theme', 'light-luxury');
        sessionStorage.setItem('scrabble_session_started', 'true');
      }
      
      try {
        // Get initial session
        const { data: { session }, error } = await window.supabase.auth.getSession();
        
        console.log('ðŸ“¦ Session check:', session ? 'Found' : 'None', error ? 'Error: ' + error.message : '');
        
        if (session) {
          console.log('âœ… Existing session found for:', session.user.email);
          await handleAuthChange(session);
        } else {
          console.log('âŒ No session, showing auth');
          showAuthInterface();
        }
        
        // Listen for auth changes
        window.supabase.auth.onAuthStateChange(async (event, session) => {
          console.log('ðŸ” Auth event:', event, session ? session.user.email : 'no session');
          
          if (session) {
            await handleAuthChange(session);
          } else {
            currentUser = null;
            userStats = null;
            showAuthInterface();
          }
        });
        
        console.log('âœ… Auth initialization complete');
      } catch (error) {
        console.error('âŒ Auth initialization error:', error);
        showAuthInterface();
      }
    });

  </script>
  
  <!-- Theme Switcher UI (Hidden - now in Settings) -->
  <div class="theme-selector" style="display: none;">
    <button class="theme-toggle-btn" onclick="toggleThemeMenu()">
      <span class="theme-icon">ðŸŽ¨</span>
      <span class="theme-label">Themes</span>
    </button>
    <div class="theme-menu" id="theme-menu" style="display: none;">
      <div class="theme-menu-header">Choose Theme</div>
      <button class="theme-option active" onclick="switchTheme('light-luxury')">
        <span class="theme-option-icon">âœ¨</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Light Luxury</div>
          <div class="theme-option-desc">Clean white, gold accents, elegant</div>
        </div>
        <span class="theme-check">âœ“</span>
      </button>
      <button class="theme-option" onclick="switchTheme('dark-modern')">
        <span class="theme-option-icon">ðŸŒ™</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Dark Modern</div>
          <div class="theme-option-desc">Dark gradients, glowing tiles, futuristic</div>
        </div>
      </button>
      <button class="theme-option" onclick="switchTheme('classic-wood')">
        <span class="theme-option-icon">ðŸŽ¨</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Classic Wood</div>
          <div class="theme-option-desc">Wooden board, traditional aesthetic</div>
        </div>
      </button>
      <button class="theme-option" onclick="switchTheme('neon-gaming')">
        <span class="theme-option-icon">âš¡</span>
        <div class="theme-option-info">
          <div class="theme-option-name">Neon Gaming</div>
          <div class="theme-option-desc">Cyberpunk neon, vibrant colors</div>
        </div>
      </button>
    </div>
  </div>
  
  <!-- Theme Switcher JavaScript -->
  <script>
    let currentTheme = localStorage.getItem('scrabble_theme') || 'light-luxury';
    
    // Apply saved theme on load
    document.body.className = 'theme-' + currentTheme;
    
    function toggleThemeMenu() {
      const menu = document.getElementById('theme-menu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
    
    function switchTheme(themeId) {
      // Update body class
      document.body.className = 'theme-' + themeId;
      
      // Save preference
      localStorage.setItem('scrabble_theme', themeId);
      currentTheme = themeId;
      
      // Update UI - only if theme menu exists
      const themeOptions = document.querySelectorAll('.theme-option');
      if (themeOptions.length > 0) {
        themeOptions.forEach(option => {
          option.classList.remove('active');
          const check = option.querySelector('.theme-check');
          if (check) check.remove();
        });
        
        // Find the option matching this theme
        const activeOption = document.querySelector(`.theme-option[data-theme="${themeId}"]`);
        if (activeOption) {
          activeOption.classList.add('active');
          const checkmark = document.createElement('span');
          checkmark.className = 'theme-check';
          checkmark.textContent = 'âœ“';
          activeOption.appendChild(checkmark);
          
          // Show message
          const messageEl = document.getElementById('message');
          if (messageEl) {
            const oldText = messageEl.textContent;
            const themeName = activeOption.textContent.split(' ')[0];
            messageEl.textContent = `Theme changed to ${themeName}`;
            setTimeout(() => {
              messageEl.textContent = oldText;
            }, 2000);
          }
        }
        
        // Close menu if it exists
        const themeMenu = document.getElementById('themeMenu');
        if (themeMenu && themeMenu.style.display === 'block') {
          toggleThemeMenu();
        }
      }
    }
  </script>
</body>
</html>
